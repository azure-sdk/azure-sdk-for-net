// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Threading;
using System.Threading.Tasks;
using Autorest.CSharp.Core;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.AI.Projects.1DP
{

/// <summary> List all versions of the given DatasetVersion. </summary>
/// <param name="name"> The name of the resource. </param>
/// <param name="maxCount"> Top count of results, top count cannot be greater than the page size. If topCount &gt; page size, results with be default page size count will be returned. </param>
/// <param name="skip"> Continuation token for pagination. </param>
/// <param name="tags"> Comma-separated list of tag names (and optionally values). Example: tag1,tag2=value2. </param>
/// <param name="listViewType"> [ListViewType.ActiveOnly, ListViewType.ArchivedOnly, ListViewType.All] View type for including/excluding (for example) archived entities. </param>
/// <param name="cancellationToken"> The cancellation token to use. </param>
/// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
/// <exception cref="ArgumentException"> <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
/// <include file="Docs/Datasets.xml" path="doc/members/member[@name='GetVersions(string,int?,string,string,ListViewType?,CancellationToken)']/*" />
public virtual Azure.Pageable<Projects.1DP.DatasetVersion> GetVersions(string name, int? maxCount = null, string skip = null, string tags = null, Projects.1DP.ListViewType? listViewType = (Projects.1DP.ListViewType?)null,CancellationToken cancellationToken = default)
{
Projects.1DP.Argument.AssertNotNullOrEmpty(name, nameof(name));

RequestContext context = cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null;
HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetVersionsRequest(name, maxCount, skip, tags, listViewType?.ToString(), context);
HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetVersionsNextPageRequest(nextLink, name, maxCount, skip, tags, listViewType?.ToString(), context);
return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => Projects.1DP.DatasetVersion.DeserializeDatasetVersion(e), ClientDiagnostics, _pipeline, "Datasets.GetVersions", "value", "nextLink", context);
}

/// <summary>
/// [Protocol Method] List all versions of the given DatasetVersion
/// <list type="bullet">
/// <item>
/// <description>
/// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
/// </description>
/// </item>
/// <item>
/// <description>
/// Please try the simpler <see cref="GetVersionsAsync(string,int?,string,string,Projects.1DP.ListViewType?,global::System.Threading.CancellationToken)"/> convenience overload with strongly typed models first.
/// </description>
/// </item>
/// </list>
/// </summary>
/// <param name="name"> The name of the resource. </param>
/// <param name="maxCount"> Top count of results, top count cannot be greater than the page size. If topCount &gt; page size, results with be default page size count will be returned. </param>
/// <param name="skip"> Continuation token for pagination. </param>
/// <param name="tags"> Comma-separated list of tag names (and optionally values). Example: tag1,tag2=value2. </param>
/// <param name="listViewType"> [ListViewType.ActiveOnly, ListViewType.ArchivedOnly, ListViewType.All] View type for including/excluding (for example) archived entities. Allowed values: "ActiveOnly" | "ArchivedOnly" | "All". </param>
/// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
/// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
/// <exception cref="ArgumentException"> <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
/// <exception cref="Azure.RequestFailedException"> Service returned a non-success status code. </exception>
/// <returns> The <see cref="Azure.AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
/// <include file="Docs/Datasets.xml" path="doc/members/member[@name='GetVersionsAsync(string,int?,string,string,string,RequestContext)']/*" />
public virtual Azure.AsyncPageable<BinaryData> GetVersionsAsync(string name, int? maxCount, string skip, string tags, string listViewType, Azure.RequestContext context)
{
    Azure.AI.Projects.1DP.Argument.AssertNotNullOrEmpty(name, nameof(name));

    HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetVersionsRequest(name, maxCount, skip, tags, listViewType, context);
    HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetVersionsNextPageRequest(nextLink, name, maxCount, skip, tags, listViewType, context);
    return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, e => BinaryData.FromString(e.GetRawText()), ClientDiagnostics, _pipeline, "Datasets.GetVersions", "value", "nextLink", context);
}

/// <summary>
/// [Protocol Method] List all versions of the given DatasetVersion
/// <list type="bullet">
/// <item>
/// <description>
/// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
/// </description>
/// </item>
/// <item>
/// <description>
/// Please try the simpler <see cref="GetVersions(string,int?,string,string,Projects.1DP.ListViewType?,global::System.Threading.CancellationToken)"/> convenience overload with strongly typed models first.
/// </description>
/// </item>
/// </list>
/// </summary>
/// <param name="name"> The name of the resource. </param>
/// <param name="maxCount"> Top count of results, top count cannot be greater than the page size. If topCount &gt; page size, results with be default page size count will be returned. </param>
/// <param name="skip"> Continuation token for pagination. </param>
/// <param name="tags"> Comma-separated list of tag names (and optionally values). Example: tag1,tag2=value2. </param>
/// <param name="listViewType"> [ListViewType.ActiveOnly, ListViewType.ArchivedOnly, ListViewType.All] View type for including/excluding (for example) archived entities. Allowed values: "ActiveOnly" | "ArchivedOnly" | "All". </param>
/// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
/// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
/// <exception cref="ArgumentException"> <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
/// <exception cref="Azure.RequestFailedException"> Service returned a non-success status code. </exception>
/// <returns> The <see cref="Azure.Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
/// <include file="Docs/Datasets.xml" path="doc/members/member[@name='GetVersions(string,int?,string,string,string,RequestContext)']/*" />
public virtual Azure.Pageable<BinaryData> GetVersions(string name, int? maxCount, string skip, string tags, string listViewType, Azure.RequestContext context)
{
    Azure.AI.Projects.1DP.Argument.AssertNotNullOrEmpty(name, nameof(name));

    HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetVersionsRequest(name, maxCount, skip, tags, listViewType, context);
    HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetVersionsNextPageRequest(nextLink, name, maxCount, skip, tags, listViewType, context);
    return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => BinaryData.FromString(e.GetRawText()), ClientDiagnostics, _pipeline, "Datasets.GetVersions", "value", "nextLink", context);
}

/// <summary> List the latest version of each DatasetVersion. </summary>
/// <param name="maxCount"> Top count of results, top count cannot be greater than the page size. If topCount &gt; page size, results with be default page size count will be returned. </param>
/// <param name="skip"> Continuation token for pagination. </param>
/// <param name="tags"> Comma-separated list of tag names (and optionally values). Example: tag1,tag2=value2. </param>
/// <param name="listViewType"> [ListViewType.ActiveOnly, ListViewType.ArchivedOnly, ListViewType.All] View type for including/excluding (for example) archived entities. </param>
/// <param name="cancellationToken"> The cancellation token to use. </param>
/// <include file="Docs/Datasets.xml" path="doc/members/member[@name='GetLatestsAsync(int?,string,string,ListViewType?,CancellationToken)']/*" />
public virtual Azure.AsyncPageable<Azure.AI.Projects.1DP.DatasetVersion> GetLatestsAsync(int? maxCount = null, string skip = null, string tags = null, Azure.AI.Projects.1DP.ListViewType? listViewType = (Azure.AI.Projects.1DP.ListViewType?)null,CancellationToken cancellationToken = default)
{
    Azure.RequestContext context = cancellationToken.CanBeCanceled ? new Azure.RequestContext { CancellationToken = cancellationToken } : null;
    HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetLatestsRequest(maxCount, skip, tags, listViewType?.ToString(), context);
    HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetLatestsNextPageRequest(nextLink, maxCount, skip, tags, listViewType?.ToString(), context);
    return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, e => Azure.AI.Projects.1DP.DatasetVersion.DeserializeDatasetVersion(e), ClientDiagnostics, _pipeline, "Datasets.GetLatests", "value", "nextLink", context);
}

/// <summary> List the latest version of each DatasetVersion. </summary>
/// <param name="maxCount"> Top count of results, top count cannot be greater than the page size. If topCount &gt; page size, results with be default page size count will be returned. </param>
/// <param name="skip"> Continuation token for pagination. </param>
/// <param name="tags"> Comma-separated list of tag names (and optionally values). Example: tag1,tag2=value2. </param>
/// <param name="listViewType"> [ListViewType.ActiveOnly, ListViewType.ArchivedOnly, ListViewType.All] View type for including/excluding (for example) archived entities. </param>
/// <param name="cancellationToken"> The cancellation token to use. </param>
/// <include file="Docs/Datasets.xml" path="doc/members/member[@name='GetLatests(int?,string,string,ListViewType?,CancellationToken)']/*" />
public virtual Azure.Pageable<Azure.AI.Projects.1DP.DatasetVersion> GetLatests(int? maxCount = null, string skip = null, string tags = null, Azure.AI.Projects.1DP.ListViewType? listViewType = (Azure.AI.Projects.1DP.ListViewType?)null,CancellationToken cancellationToken = default)
{
    Azure.RequestContext context = cancellationToken.CanBeCanceled ? new Azure.RequestContext { CancellationToken = cancellationToken } : null;
    HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetLatestsRequest(maxCount, skip, tags, listViewType?.ToString(), context);
    HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetLatestsNextPageRequest(nextLink, maxCount, skip, tags, listViewType?.ToString(), context);
    return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => Azure.AI.Projects.1DP.DatasetVersion.DeserializeDatasetVersion(e), ClientDiagnostics, _pipeline, "Datasets.GetLatests", "value", "nextLink", context);
}

/// <summary>
/// [Protocol Method] List the latest version of each DatasetVersion
/// <list type="bullet">
/// <item>
/// <description>
/// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
/// </description>
/// </item>
/// <item>
/// <description>
/// Please try the simpler <see cref="GetLatestsAsync(int?,string,string,Projects.1DP.ListViewType?,global::System.Threading.CancellationToken)"/> convenience overload with strongly typed models first.
/// </description>
/// </item>
/// </list>
/// </summary>
/// <param name="maxCount"> Top count of results, top count cannot be greater than the page size. If topCount &gt; page size, results with be default page size count will be returned. </param>
/// <param name="skip"> Continuation token for pagination. </param>
/// <param name="tags"> Comma-separated list of tag names (and optionally values). Example: tag1,tag2=value2. </param>
/// <param name="listViewType"> [ListViewType.ActiveOnly, ListViewType.ArchivedOnly, ListViewType.All] View type for including/excluding (for example) archived entities. Allowed values: "ActiveOnly" | "ArchivedOnly" | "All". </param>
/// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
/// <exception cref="Azure.RequestFailedException"> Service returned a non-success status code. </exception>
/// <returns> The <see cref="Azure.AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
/// <include file="Docs/Datasets.xml" path="doc/members/member[@name='GetLatestsAsync(int?,string,string,string,RequestContext)']/*" />
public virtual Azure.AsyncPageable<BinaryData> GetLatestsAsync(int? maxCount, string skip, string tags, string listViewType, Azure.RequestContext context)
{
    HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetLatestsRequest(maxCount, skip, tags, listViewType, context);
    HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetLatestsNextPageRequest(nextLink, maxCount, skip, tags, listViewType, context);
    return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, e => BinaryData.FromString(e.GetRawText()), ClientDiagnostics, _pipeline, "Datasets.GetLatests", "value", "nextLink", context);
}

/// <summary>
/// [Protocol Method] List the latest version of each DatasetVersion
/// <list type="bullet">
/// <item>
/// <description>
/// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
/// </description>
/// </item>
/// <item>
/// <description>
/// Please try the simpler <see cref="GetLatests(int?,string,string,Projects.1DP.ListViewType?,global::System.Threading.CancellationToken)"/> convenience overload with strongly typed models first.
/// </description>
/// </item>
/// </list>
/// </summary>
/// <param name="maxCount"> Top count of results, top count cannot be greater than the page size. If topCount &gt; page size, results with be default page size count will be returned. </param>
/// <param name="skip"> Continuation token for pagination. </param>
/// <param name="tags"> Comma-separated list of tag names (and optionally values). Example: tag1,tag2=value2. </param>
/// <param name="listViewType"> [ListViewType.ActiveOnly, ListViewType.ArchivedOnly, ListViewType.All] View type for including/excluding (for example) archived entities. Allowed values: "ActiveOnly" | "ArchivedOnly" | "All". </param>
/// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
/// <exception cref="Azure.RequestFailedException"> Service returned a non-success status code. </exception>
/// <returns> The <see cref="Azure.Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
/// <include file="Docs/Datasets.xml" path="doc/members/member[@name='GetLatests(int?,string,string,string,RequestContext)']/*" />
public virtual Azure.Pageable<BinaryData> GetLatests(int? maxCount, string skip, string tags, string listViewType, Azure.RequestContext context)
{
    HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetLatestsRequest(maxCount, skip, tags, listViewType, context);
    HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetLatestsNextPageRequest(nextLink, maxCount, skip, tags, listViewType, context);
    return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => BinaryData.FromString(e.GetRawText()), ClientDiagnostics, _pipeline, "Datasets.GetLatests", "value", "nextLink", context);
}

internal HttpMessage CreateGetVersionsRequest(string name, int? maxCount, string skip, string tags, string listViewType, Azure.RequestContext context)
{
    var message = _pipeline.CreateMessage(context, ResponseClassifier200);
    var request = message.Request;
    request.Method = RequestMethod.Get;
    var uri = new RawRequestUriBuilder();
    uri.Reset(_endpoint);
    uri.AppendPath("/datasets/", false);
    uri.AppendPath(name, true);
    uri.AppendPath("/versions", false);
    uri.AppendQuery("api-version", _apiVersion, true);
    if (maxCount != null)
    {
        uri.AppendQuery("top", maxCount.Value, true);
    }
    if (skip != null)
    {
        uri.AppendQuery("skip", skip, true);
    }
    if (tags != null)
    {
        uri.AppendQuery("tags", tags, true);
    }
    if (listViewType != null)
    {
        uri.AppendQuery("listViewType", listViewType, true);
    }
    request.Uri = uri;
    request.Headers.Add("Accept", "application/json");
    return message;
}

internal HttpMessage CreateGetLatestsRequest(int? maxCount, string skip, string tags, string listViewType, Azure.RequestContext context)
{
    var message = _pipeline.CreateMessage(context, ResponseClassifier200);
    var request = message.Request;
    request.Method = RequestMethod.Get;
    var uri = new RawRequestUriBuilder();
    uri.Reset(_endpoint);
    uri.AppendPath("/datasets", false);
    uri.AppendQuery("api-version", _apiVersion, true);
    if (maxCount != null)
    {
        uri.AppendQuery("top", maxCount.Value, true);
    }
    if (skip != null)
    {
        uri.AppendQuery("skip", skip, true);
    }
    if (tags != null)
    {
        uri.AppendQuery("tags", tags, true);
    }
    if (listViewType != null)
    {
        uri.AppendQuery("listViewType", listViewType, true);
    }
    request.Uri = uri;
    request.Headers.Add("Accept", "application/json");
    return message;
}

internal HttpMessage CreateGetVersionRequest(string name, string version, Azure.RequestContext context)
{
    var message = _pipeline.CreateMessage(context, ResponseClassifier200);
    var request = message.Request;
    request.Method = RequestMethod.Get;
    var uri = new RawRequestUriBuilder();
    uri.Reset(_endpoint);
    uri.AppendPath("/datasets/", false);
    uri.AppendPath(name, true);
    uri.AppendPath("/versions/", false);
    uri.AppendPath(version, true);
    uri.AppendQuery("api-version", _apiVersion, true);
    request.Uri = uri;
    request.Headers.Add("Accept", "application/json");
    return message;
}

internal HttpMessage CreateDeleteVersionRequest(string name, string version, Azure.RequestContext context)
{
    var message = _pipeline.CreateMessage(context, ResponseClassifier204);
    var request = message.Request;
    request.Method = RequestMethod.Delete;
    var uri = new RawRequestUriBuilder();
    uri.Reset(_endpoint);
    uri.AppendPath("/datasets/", false);
    uri.AppendPath(name, true);
    uri.AppendPath("/versions/", false);
    uri.AppendPath(version, true);
    uri.AppendQuery("api-version", _apiVersion, true);
    request.Uri = uri;
    request.Headers.Add("Accept", "application/json");
    return message;
}

internal HttpMessage CreateCreateRequest(string name, RequestContent content, Azure.RequestContext context)
{
    var message = _pipeline.CreateMessage(context, ResponseClassifier200);
    var request = message.Request;
    request.Method = RequestMethod.Post;
    var uri = new RawRequestUriBuilder();
    uri.Reset(_endpoint);
    uri.AppendPath("/datasets/", false);
    uri.AppendPath(name, true);
    uri.AppendPath("/versions", false);
    uri.AppendQuery("api-version", _apiVersion, true);
    request.Uri = uri;
    request.Headers.Add("Accept", "application/json");
    request.Headers.Add("Repeatability-Request-ID", Guid.NewGuid());
    request.Headers.Add("Repeatability-First-Sent", DateTimeOffset.Now, "R");
    request.Headers.Add("Content-Type", "application/json");
    request.Content = content;
    return message;
}

internal HttpMessage CreateCreateVersionRequest(string name, string version, RequestContent content, Azure.RequestContext context)
{
    var message = _pipeline.CreateMessage(context, ResponseClassifier200201);
    var request = message.Request;
    request.Method = RequestMethod.Put;
    var uri = new RawRequestUriBuilder();
    uri.Reset(_endpoint);
    uri.AppendPath("/datasets/", false);
    uri.AppendPath(name, true);
    uri.AppendPath("/versions/", false);
    uri.AppendPath(version, true);
    uri.AppendQuery("api-version", _apiVersion, true);
    request.Uri = uri;
    request.Headers.Add("Accept", "application/json");
    request.Headers.Add("Content-Type", "application/json");
    request.Content = content;
    return message;
}

internal HttpMessage CreateStartPendingUploadVersionRequest(string name, string version, RequestContent content, Azure.RequestContext context)
{
    var message = _pipeline.CreateMessage(context, ResponseClassifier200);
    var request = message.Request;
    request.Method = RequestMethod.Post;
    var uri = new RawRequestUriBuilder();
    uri.Reset(_endpoint);
    uri.AppendPath("/datasets/", false);
    uri.AppendPath(name, true);
    uri.AppendPath("/versions/", false);
    uri.AppendPath(version, true);
    uri.AppendPath("/startPendingUpload", false);
    uri.AppendQuery("api-version", _apiVersion, true);
    request.Uri = uri;
    request.Headers.Add("Accept", "application/json");
    request.Headers.Add("Content-Type", "application/json");
    request.Content = content;
    return message;
}

internal HttpMessage CreateStartPendingUploadRequest(string name, RequestContent content, Azure.RequestContext context)
{
    var message = _pipeline.CreateMessage(context, ResponseClassifier200);
    var request = message.Request;
    request.Method = RequestMethod.Post;
    var uri = new RawRequestUriBuilder();
    uri.Reset(_endpoint);
    uri.AppendPath("/datasets/", false);
    uri.AppendPath(name, true);
    uri.AppendPath("/startPendingUpload", false);
    uri.AppendQuery("api-version", _apiVersion, true);
    request.Uri = uri;
    request.Headers.Add("Accept", "application/json");
    request.Headers.Add("Content-Type", "application/json");
    request.Content = content;
    return message;
}

internal HttpMessage CreateGetVersionsNextPageRequest(string nextLink, string name, int? maxCount, string skip, string tags, string listViewType, Azure.RequestContext context)
{
    var message = _pipeline.CreateMessage(context, ResponseClassifier200);
    var request = message.Request;
    request.Method = RequestMethod.Get;
    var uri = new RawRequestUriBuilder();
    uri.Reset(_endpoint);
    uri.AppendRawNextLink(nextLink, false);
    request.Uri = uri;
    request.Headers.Add("Accept", "application/json");
    return message;
}

internal HttpMessage CreateGetLatestsNextPageRequest(string nextLink, int? maxCount, string skip, string tags, string listViewType, Azure.RequestContext context)
{
    var message = _pipeline.CreateMessage(context, ResponseClassifier200);
    var request = message.Request;
    request.Method = RequestMethod.Get;
    var uri = new RawRequestUriBuilder();
    uri.Reset(_endpoint);
    uri.AppendRawNextLink(nextLink, false);
    request.Uri = uri;
    request.Headers.Add("Accept", "application/json");
    return message;
}

private static Azure.RequestContext DefaultRequestContext = new Azure.RequestContext();
internal static Azure.RequestContext FromCancellationToken(CancellationToken cancellationToken = default)
{
    if (!cancellationToken.CanBeCanceled)
    {
        return DefaultRequestContext;
    }

    return new Azure.RequestContext() { CancellationToken = cancellationToken };
}

private static ResponseClassifier _responseClassifier200;
private static ResponseClassifier ResponseClassifier200 => _responseClassifier200 ??= new StatusCodeClassifier(stackalloc ushort[] { 200 });
private static ResponseClassifier _responseClassifier204;
private static ResponseClassifier ResponseClassifier204 => _responseClassifier204 ??= new StatusCodeClassifier(stackalloc ushort[] { 204 });
private static ResponseClassifier _responseClassifier200201;
private static ResponseClassifier ResponseClassifier200201 => _responseClassifier200201 ??= new StatusCodeClassifier(stackalloc ushort[] { 200, 201 });
}
}
