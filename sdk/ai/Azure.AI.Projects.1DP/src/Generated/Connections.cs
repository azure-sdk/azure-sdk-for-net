// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Threading;
using System.Threading.Tasks;
using Autorest.CSharp.Core;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.AI.Projects.1DP
{

/// <summary> List all connections in the project, without populating connection credentials. </summary>
/// <param name="connectionType"> List connections of this specific type. </param>
/// <param name="defaultConnection"> List connections that are default connections. </param>
/// <param name="maxCount"> The number of result items to return. </param>
/// <param name="skip"> The number of result items to skip. </param>
/// <param name="maxpagesize"> The maximum number of result items per page. </param>
/// <param name="cancellationToken"> The cancellation token to use. </param>
/// <include file="Docs/Connections.xml" path="doc/members/member[@name='GetConnections(ConnectionType?,bool?,int?,int?,int?,CancellationToken)']/*" />
public virtual Azure.Pageable<Projects.1DP.Connection> GetConnections(Projects.1DP.ConnectionType? connectionType = (Projects.1DP.ConnectionType?)null,bool? defaultConnection = null,int? maxCount = null,int? skip = null,int? maxpagesize = null, global::System.Threading.CancellationToken cancellationToken = default)
{
RequestContext context = cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null;
HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetConnectionsRequest(connectionType?.ToString(), defaultConnection, maxCount, skip, pageSizeHint, context);
HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetConnectionsNextPageRequest(nextLink, connectionType?.ToString(), defaultConnection, maxCount, skip, pageSizeHint, context);
return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => Projects.1DP.Connection.DeserializeConnection(e), ClientDiagnostics, _pipeline, "Connections.GetConnections", "value", "nextLink", maxpagesize, context);
}

/// <summary>
/// [Protocol Method] List all connections in the project, without populating connection credentials
/// <list type="bullet">
/// <item>
/// <description>
/// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
/// </description>
/// </item>
/// <item>
/// <description>
/// Please try the simpler <see cref="GetConnectionsAsync(Projects.1DP.ConnectionType?,bool?,int?,int?,int?,global::System.Threading.CancellationToken)"/> convenience overload with strongly typed models first.
/// </description>
/// </item>
/// </list>
/// </summary>
/// <param name="connectionType"> List connections of this specific type. Allowed values: "AzureOpenAI" | "AzureBlob" | "AzureStorageAccount" | "CognitiveSearch" | "CosmosDB" | "ApiKey" | "AppConfig" | "AppInsights" | "CustomKeys". </param>
/// <param name="defaultConnection"> List connections that are default connections. </param>
/// <param name="maxCount"> The number of result items to return. </param>
/// <param name="skip"> The number of result items to skip. </param>
/// <param name="maxpagesize"> The maximum number of result items per page. </param>
/// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
/// <exception cref="Azure.RequestFailedException"> Service returned a non-success status code. </exception>
/// <returns> The <see cref="Azure.AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
/// <include file="Docs/Connections.xml" path="doc/members/member[@name='GetConnectionsAsync(string,bool?,int?,int?,int?,RequestContext)']/*" />
public virtual Azure.AsyncPageable<BinaryData> GetConnectionsAsync(string connectionType, bool? defaultConnection, int? maxCount, int? skip, int? maxpagesize, Azure.RequestContext context)
{
    HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetConnectionsRequest(connectionType, defaultConnection, maxCount, skip, pageSizeHint, context);
    HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetConnectionsNextPageRequest(nextLink, connectionType, defaultConnection, maxCount, skip, pageSizeHint, context);
    return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, e => BinaryData.FromString(e.GetRawText()), ClientDiagnostics, _pipeline, "Connections.GetConnections", "value", "nextLink", maxpagesize, context);
}

/// <summary>
/// [Protocol Method] List all connections in the project, without populating connection credentials
/// <list type="bullet">
/// <item>
/// <description>
/// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
/// </description>
/// </item>
/// <item>
/// <description>
/// Please try the simpler <see cref="GetConnections(Projects.1DP.ConnectionType?,bool?,int?,int?,int?,global::System.Threading.CancellationToken)"/> convenience overload with strongly typed models first.
/// </description>
/// </item>
/// </list>
/// </summary>
/// <param name="connectionType"> List connections of this specific type. Allowed values: "AzureOpenAI" | "AzureBlob" | "AzureStorageAccount" | "CognitiveSearch" | "CosmosDB" | "ApiKey" | "AppConfig" | "AppInsights" | "CustomKeys". </param>
/// <param name="defaultConnection"> List connections that are default connections. </param>
/// <param name="maxCount"> The number of result items to return. </param>
/// <param name="skip"> The number of result items to skip. </param>
/// <param name="maxpagesize"> The maximum number of result items per page. </param>
/// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
/// <exception cref="Azure.RequestFailedException"> Service returned a non-success status code. </exception>
/// <returns> The <see cref="Azure.Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
/// <include file="Docs/Connections.xml" path="doc/members/member[@name='GetConnections(string,bool?,int?,int?,int?,RequestContext)']/*" />
public virtual Azure.Pageable<BinaryData> GetConnections(string connectionType, bool? defaultConnection, int? maxCount, int? skip, int? maxpagesize, Azure.RequestContext context)
{
    HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetConnectionsRequest(connectionType, defaultConnection, maxCount, skip, pageSizeHint, context);
    HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetConnectionsNextPageRequest(nextLink, connectionType, defaultConnection, maxCount, skip, pageSizeHint, context);
    return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => BinaryData.FromString(e.GetRawText()), ClientDiagnostics, _pipeline, "Connections.GetConnections", "value", "nextLink", maxpagesize, context);
}

/// <summary> List all connections in the project, with their connection credentials. </summary>
/// <param name="connectionType"> List connections of this specific type. </param>
/// <param name="defaultConnection"> List connections that are default connections. </param>
/// <param name="maxCount"> The number of result items to return. </param>
/// <param name="skip"> The number of result items to skip. </param>
/// <param name="maxpagesize"> The maximum number of result items per page. </param>
/// <param name="cancellationToken"> The cancellation token to use. </param>
/// <include file="Docs/Connections.xml" path="doc/members/member[@name='GetWithCredentialsAsync(ConnectionType?,bool?,int?,int?,int?,CancellationToken)']/*" />
public virtual Azure.AsyncPageable<Azure.AI.Projects.1DP.Connection> GetWithCredentialsAsync(Azure.AI.Projects.1DP.ConnectionType? connectionType = (Azure.AI.Projects.1DP.ConnectionType?)null,bool? defaultConnection = null,int? maxCount = (int?)null,int? skip = null,int? maxpagesize = (int?)null,CancellationToken cancellationToken = default)
{
    Azure.RequestContext context = cancellationToken.CanBeCanceled ? new Azure.RequestContext { CancellationToken = cancellationToken } : null;
    HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetWithCredentialsRequest(connectionType?.ToString(), defaultConnection, maxCount, skip, pageSizeHint, context);
    HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetWithCredentialsNextPageRequest(nextLink, connectionType?.ToString(), defaultConnection, maxCount, skip, pageSizeHint, context);
    return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, e => Azure.AI.Projects.1DP.Connection.DeserializeConnection(e), ClientDiagnostics, _pipeline, "Connections.GetWithCredentials", "value", "nextLink", maxpagesize, context);
}

/// <summary> List all connections in the project, with their connection credentials. </summary>
/// <param name="connectionType"> List connections of this specific type. </param>
/// <param name="defaultConnection"> List connections that are default connections. </param>
/// <param name="maxCount"> The number of result items to return. </param>
/// <param name="skip"> The number of result items to skip. </param>
/// <param name="maxpagesize"> The maximum number of result items per page. </param>
/// <param name="cancellationToken"> The cancellation token to use. </param>
/// <include file="Docs/Connections.xml" path="doc/members/member[@name='GetWithCredentials(ConnectionType?,bool?,int?,int?,int?,CancellationToken)']/*" />
public virtual Azure.Pageable<Azure.AI.Projects.1DP.Connection> GetWithCredentials(Azure.AI.Projects.1DP.ConnectionType? connectionType = (Azure.AI.Projects.1DP.ConnectionType?)null,bool? defaultConnection = null,int? maxCount = (int?)null,int? skip = null,int? maxpagesize = (int?)null,CancellationToken cancellationToken = default)
{
    Azure.RequestContext context = cancellationToken.CanBeCanceled ? new Azure.RequestContext { CancellationToken = cancellationToken } : null;
    HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetWithCredentialsRequest(connectionType?.ToString(), defaultConnection, maxCount, skip, pageSizeHint, context);
    HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetWithCredentialsNextPageRequest(nextLink, connectionType?.ToString(), defaultConnection, maxCount, skip, pageSizeHint, context);
    return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => Azure.AI.Projects.1DP.Connection.DeserializeConnection(e), ClientDiagnostics, _pipeline, "Connections.GetWithCredentials", "value", "nextLink", maxpagesize, context);
}

/// <summary>
/// [Protocol Method] List all connections in the project, with their connection credentials
/// <list type="bullet">
/// <item>
/// <description>
/// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
/// </description>
/// </item>
/// <item>
/// <description>
/// Please try the simpler <see cref="GetWithCredentialsAsync(Projects.1DP.ConnectionType?,bool?,int?,int?,int?,global::System.Threading.CancellationToken)"/> convenience overload with strongly typed models first.
/// </description>
/// </item>
/// </list>
/// </summary>
/// <param name="connectionType"> List connections of this specific type. Allowed values: "AzureOpenAI" | "AzureBlob" | "AzureStorageAccount" | "CognitiveSearch" | "CosmosDB" | "ApiKey" | "AppConfig" | "AppInsights" | "CustomKeys". </param>
/// <param name="defaultConnection"> List connections that are default connections. </param>
/// <param name="maxCount"> The number of result items to return. </param>
/// <param name="skip"> The number of result items to skip. </param>
/// <param name="maxpagesize"> The maximum number of result items per page. </param>
/// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
/// <exception cref="Azure.RequestFailedException"> Service returned a non-success status code. </exception>
/// <returns> The <see cref="Azure.AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
/// <include file="Docs/Connections.xml" path="doc/members/member[@name='GetWithCredentialsAsync(string,bool?,int?,int?,int?,RequestContext)']/*" />
public virtual Azure.AsyncPageable<BinaryData> GetWithCredentialsAsync(string connectionType, bool? defaultConnection, int? maxCount, int? skip, int? maxpagesize, Azure.RequestContext context)
{
    HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetWithCredentialsRequest(connectionType, defaultConnection, maxCount, skip, pageSizeHint, context);
    HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetWithCredentialsNextPageRequest(nextLink, connectionType, defaultConnection, maxCount, skip, pageSizeHint, context);
    return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, e => BinaryData.FromString(e.GetRawText()), ClientDiagnostics, _pipeline, "Connections.GetWithCredentials", "value", "nextLink", maxpagesize, context);
}

/// <summary>
/// [Protocol Method] List all connections in the project, with their connection credentials
/// <list type="bullet">
/// <item>
/// <description>
/// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
/// </description>
/// </item>
/// <item>
/// <description>
/// Please try the simpler <see cref="GetWithCredentials(Projects.1DP.ConnectionType?,bool?,int?,int?,int?,global::System.Threading.CancellationToken)"/> convenience overload with strongly typed models first.
/// </description>
/// </item>
/// </list>
/// </summary>
/// <param name="connectionType"> List connections of this specific type. Allowed values: "AzureOpenAI" | "AzureBlob" | "AzureStorageAccount" | "CognitiveSearch" | "CosmosDB" | "ApiKey" | "AppConfig" | "AppInsights" | "CustomKeys". </param>
/// <param name="defaultConnection"> List connections that are default connections. </param>
/// <param name="maxCount"> The number of result items to return. </param>
/// <param name="skip"> The number of result items to skip. </param>
/// <param name="maxpagesize"> The maximum number of result items per page. </param>
/// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
/// <exception cref="Azure.RequestFailedException"> Service returned a non-success status code. </exception>
/// <returns> The <see cref="Azure.Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
/// <include file="Docs/Connections.xml" path="doc/members/member[@name='GetWithCredentials(string,bool?,int?,int?,int?,RequestContext)']/*" />
public virtual Azure.Pageable<BinaryData> GetWithCredentials(string connectionType, bool? defaultConnection, int? maxCount, int? skip, int? maxpagesize, Azure.RequestContext context)
{
    HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetWithCredentialsRequest(connectionType, defaultConnection, maxCount, skip, pageSizeHint, context);
    HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetWithCredentialsNextPageRequest(nextLink, connectionType, defaultConnection, maxCount, skip, pageSizeHint, context);
    return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => BinaryData.FromString(e.GetRawText()), ClientDiagnostics, _pipeline, "Connections.GetWithCredentials", "value", "nextLink", maxpagesize, context);
}

internal HttpMessage CreateGetConnectionRequest(string name, Azure.RequestContext context)
{
    var message = _pipeline.CreateMessage(context, ResponseClassifier200);
    var request = message.Request;
    request.Method = RequestMethod.Get;
    var uri = new RawRequestUriBuilder();
    uri.Reset(_endpoint);
    uri.AppendPath("/connections/", false);
    uri.AppendPath(name, true);
    uri.AppendQuery("api-version", _apiVersion, true);
    request.Uri = uri;
    request.Headers.Add("Accept", "application/json");
    return message;
}

internal HttpMessage CreateWithCredentialsRequest(string name, Azure.RequestContext context)
{
    var message = _pipeline.CreateMessage(context, ResponseClassifier200);
    var request = message.Request;
    request.Method = RequestMethod.Post;
    var uri = new RawRequestUriBuilder();
    uri.Reset(_endpoint);
    uri.AppendPath("/connections/", false);
    uri.AppendPath(name, true);
    uri.AppendPath(":withCredentials", false);
    uri.AppendQuery("api-version", _apiVersion, true);
    request.Uri = uri;
    request.Headers.Add("Accept", "application/json");
    return message;
}

internal HttpMessage CreateGetConnectionsRequest(string connectionType, bool? defaultConnection, int? maxCount, int? skip, int? maxpagesize, Azure.RequestContext context)
{
    var message = _pipeline.CreateMessage(context, ResponseClassifier200);
    var request = message.Request;
    request.Method = RequestMethod.Get;
    var uri = new RawRequestUriBuilder();
    uri.Reset(_endpoint);
    uri.AppendPath("/connections", false);
    uri.AppendQuery("api-version", _apiVersion, true);
    if (connectionType != null)
    {
        uri.AppendQuery("connectionType", connectionType, true);
    }
    if (defaultConnection != null)
    {
        uri.AppendQuery("defaultConnection", defaultConnection.Value, true);
    }
    if (maxCount != null)
    {
        uri.AppendQuery("top", maxCount.Value, true);
    }
    if (skip != null)
    {
        uri.AppendQuery("skip", skip.Value, true);
    }
    if (maxpagesize != null)
    {
        uri.AppendQuery("maxpagesize", maxpagesize.Value, true);
    }
    request.Uri = uri;
    request.Headers.Add("Accept", "application/json");
    return message;
}

internal HttpMessage CreateGetWithCredentialsRequest(string connectionType, bool? defaultConnection, int? maxCount, int? skip, int? maxpagesize, Azure.RequestContext context)
{
    var message = _pipeline.CreateMessage(context, ResponseClassifier200);
    var request = message.Request;
    request.Method = RequestMethod.Post;
    var uri = new RawRequestUriBuilder();
    uri.Reset(_endpoint);
    uri.AppendPath("/connections:withCredentials", false);
    uri.AppendQuery("api-version", _apiVersion, true);
    if (connectionType != null)
    {
        uri.AppendQuery("connectionType", connectionType, true);
    }
    if (defaultConnection != null)
    {
        uri.AppendQuery("defaultConnection", defaultConnection.Value, true);
    }
    if (maxCount != null)
    {
        uri.AppendQuery("top", maxCount.Value, true);
    }
    if (skip != null)
    {
        uri.AppendQuery("skip", skip.Value, true);
    }
    if (maxpagesize != null)
    {
        uri.AppendQuery("maxpagesize", maxpagesize.Value, true);
    }
    request.Uri = uri;
    request.Headers.Add("Accept", "application/json");
    return message;
}

internal HttpMessage CreateGetConnectionsNextPageRequest(string nextLink, string connectionType, bool? defaultConnection, int? maxCount, int? skip, int? maxpagesize, Azure.RequestContext context)
{
    var message = _pipeline.CreateMessage(context, ResponseClassifier200);
    var request = message.Request;
    request.Method = RequestMethod.Get;
    var uri = new RawRequestUriBuilder();
    uri.Reset(_endpoint);
    uri.AppendRawNextLink(nextLink, false);
    request.Uri = uri;
    request.Headers.Add("Accept", "application/json");
    return message;
}

internal HttpMessage CreateGetWithCredentialsNextPageRequest(string nextLink, string connectionType, bool? defaultConnection, int? maxCount, int? skip, int? maxpagesize, Azure.RequestContext context)
{
    var message = _pipeline.CreateMessage(context, ResponseClassifier200);
    var request = message.Request;
    request.Method = RequestMethod.Get;
    var uri = new RawRequestUriBuilder();
    uri.Reset(_endpoint);
    uri.AppendRawNextLink(nextLink, false);
    request.Uri = uri;
    request.Headers.Add("Accept", "application/json");
    return message;
}

private static Azure.RequestContext DefaultRequestContext = new Azure.RequestContext();
internal static Azure.RequestContext FromCancellationToken(CancellationToken cancellationToken = default)
{
    if (!cancellationToken.CanBeCanceled)
    {
        return DefaultRequestContext;
    }

    return new Azure.RequestContext() { CancellationToken = cancellationToken };
}

private static ResponseClassifier _responseClassifier200;
private static ResponseClassifier ResponseClassifier200 => _responseClassifier200 ??= new StatusCodeClassifier(stackalloc ushort[] { 200 });
}
}
