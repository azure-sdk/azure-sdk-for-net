// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Threading;
using System.Threading.Tasks;
using Autorest.CSharp.Core;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.AI.Projects.1DP
{

/// <summary> List all deployed models in the project. </summary>
/// <param name="modelPublisher"> Model publisher to filter models by. </param>
/// <param name="modelName"> Model name (the publisher specific name) to filter models by. </param>
/// <param name="deploymentType"> Type of deployment to filter list by. </param>
/// <param name="maxCount"> The number of result items to return. </param>
/// <param name="skip"> The number of result items to skip. </param>
/// <param name="maxpagesize"> The maximum number of result items per page. </param>
/// <param name="cancellationToken"> The cancellation token to use. </param>
/// <include file="Docs/Deployments.xml" path="doc/members/member[@name='GetDeployments(string,string,DeploymentType?,int?,int?,int?,CancellationToken)']/*" />
public virtual Azure.Pageable<Projects.1DP.Deployment> GetDeployments(string modelPublisher = null, string modelName = null, Projects.1DP.DeploymentType? deploymentType = (Projects.1DP.DeploymentType?)null,int? maxCount = null,int? skip = null,int? maxpagesize = null, global::System.Threading.CancellationToken cancellationToken = default)
{
RequestContext context = cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null;
HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetDeploymentsRequest(modelPublisher, modelName, deploymentType?.ToString(), maxCount, skip, pageSizeHint, context);
HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetDeploymentsNextPageRequest(nextLink, modelPublisher, modelName, deploymentType?.ToString(), maxCount, skip, pageSizeHint, context);
return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => Projects.1DP.Deployment.DeserializeDeployment(e), ClientDiagnostics, _pipeline, "Deployments.GetDeployments", "value", "nextLink", maxpagesize, context);
}

/// <summary>
/// [Protocol Method] List all deployed models in the project
/// <list type="bullet">
/// <item>
/// <description>
/// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
/// </description>
/// </item>
/// <item>
/// <description>
/// Please try the simpler <see cref="GetDeploymentsAsync(string,string,Projects.1DP.DeploymentType?,int?,int?,int?,global::System.Threading.CancellationToken)"/> convenience overload with strongly typed models first.
/// </description>
/// </item>
/// </list>
/// </summary>
/// <param name="modelPublisher"> Model publisher to filter models by. </param>
/// <param name="modelName"> Model name (the publisher specific name) to filter models by. </param>
/// <param name="deploymentType"> Type of deployment to filter list by. Allowed values: "ModelDeployment". </param>
/// <param name="maxCount"> The number of result items to return. </param>
/// <param name="skip"> The number of result items to skip. </param>
/// <param name="maxpagesize"> The maximum number of result items per page. </param>
/// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
/// <exception cref="Azure.RequestFailedException"> Service returned a non-success status code. </exception>
/// <returns> The <see cref="Azure.AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
/// <include file="Docs/Deployments.xml" path="doc/members/member[@name='GetDeploymentsAsync(string,string,string,int?,int?,int?,RequestContext)']/*" />
public virtual Azure.AsyncPageable<BinaryData> GetDeploymentsAsync(string modelPublisher, string modelName, string deploymentType, int? maxCount, int? skip, int? maxpagesize, Azure.RequestContext context)
{
    HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetDeploymentsRequest(modelPublisher, modelName, deploymentType, maxCount, skip, pageSizeHint, context);
    HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetDeploymentsNextPageRequest(nextLink, modelPublisher, modelName, deploymentType, maxCount, skip, pageSizeHint, context);
    return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, e => BinaryData.FromString(e.GetRawText()), ClientDiagnostics, _pipeline, "Deployments.GetDeployments", "value", "nextLink", maxpagesize, context);
}

/// <summary>
/// [Protocol Method] List all deployed models in the project
/// <list type="bullet">
/// <item>
/// <description>
/// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
/// </description>
/// </item>
/// <item>
/// <description>
/// Please try the simpler <see cref="GetDeployments(string,string,Projects.1DP.DeploymentType?,int?,int?,int?,global::System.Threading.CancellationToken)"/> convenience overload with strongly typed models first.
/// </description>
/// </item>
/// </list>
/// </summary>
/// <param name="modelPublisher"> Model publisher to filter models by. </param>
/// <param name="modelName"> Model name (the publisher specific name) to filter models by. </param>
/// <param name="deploymentType"> Type of deployment to filter list by. Allowed values: "ModelDeployment". </param>
/// <param name="maxCount"> The number of result items to return. </param>
/// <param name="skip"> The number of result items to skip. </param>
/// <param name="maxpagesize"> The maximum number of result items per page. </param>
/// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
/// <exception cref="Azure.RequestFailedException"> Service returned a non-success status code. </exception>
/// <returns> The <see cref="Azure.Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
/// <include file="Docs/Deployments.xml" path="doc/members/member[@name='GetDeployments(string,string,string,int?,int?,int?,RequestContext)']/*" />
public virtual Azure.Pageable<BinaryData> GetDeployments(string modelPublisher, string modelName, string deploymentType, int? maxCount, int? skip, int? maxpagesize, Azure.RequestContext context)
{
    HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetDeploymentsRequest(modelPublisher, modelName, deploymentType, maxCount, skip, pageSizeHint, context);
    HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetDeploymentsNextPageRequest(nextLink, modelPublisher, modelName, deploymentType, maxCount, skip, pageSizeHint, context);
    return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => BinaryData.FromString(e.GetRawText()), ClientDiagnostics, _pipeline, "Deployments.GetDeployments", "value", "nextLink", maxpagesize, context);
}

internal HttpMessage CreateGetDeploymentRequest(string name, Azure.RequestContext context)
{
    var message = _pipeline.CreateMessage(context, ResponseClassifier200);
    var request = message.Request;
    request.Method = RequestMethod.Get;
    var uri = new RawRequestUriBuilder();
    uri.Reset(_endpoint);
    uri.AppendPath("/deployments/", false);
    uri.AppendPath(name, true);
    uri.AppendQuery("api-version", _apiVersion, true);
    request.Uri = uri;
    request.Headers.Add("Accept", "application/json");
    return message;
}

internal HttpMessage CreateGetDeploymentsRequest(string modelPublisher, string modelName, string deploymentType, int? maxCount, int? skip, int? maxpagesize, Azure.RequestContext context)
{
    var message = _pipeline.CreateMessage(context, ResponseClassifier200);
    var request = message.Request;
    request.Method = RequestMethod.Get;
    var uri = new RawRequestUriBuilder();
    uri.Reset(_endpoint);
    uri.AppendPath("/deployments", false);
    uri.AppendQuery("api-version", _apiVersion, true);
    if (modelPublisher != null)
    {
        uri.AppendQuery("modelPublisher", modelPublisher, true);
    }
    if (modelName != null)
    {
        uri.AppendQuery("modelName", modelName, true);
    }
    if (deploymentType != null)
    {
        uri.AppendQuery("deploymentType", deploymentType, true);
    }
    if (maxCount != null)
    {
        uri.AppendQuery("top", maxCount.Value, true);
    }
    if (skip != null)
    {
        uri.AppendQuery("skip", skip.Value, true);
    }
    if (maxpagesize != null)
    {
        uri.AppendQuery("maxpagesize", maxpagesize.Value, true);
    }
    request.Uri = uri;
    request.Headers.Add("Accept", "application/json");
    return message;
}

internal HttpMessage CreateGetDeploymentsNextPageRequest(string nextLink, string modelPublisher, string modelName, string deploymentType, int? maxCount, int? skip, int? maxpagesize, Azure.RequestContext context)
{
    var message = _pipeline.CreateMessage(context, ResponseClassifier200);
    var request = message.Request;
    request.Method = RequestMethod.Get;
    var uri = new RawRequestUriBuilder();
    uri.Reset(_endpoint);
    uri.AppendRawNextLink(nextLink, false);
    request.Uri = uri;
    request.Headers.Add("Accept", "application/json");
    return message;
}

private static Azure.RequestContext DefaultRequestContext = new Azure.RequestContext();
internal static Azure.RequestContext FromCancellationToken(CancellationToken cancellationToken = default)
{
    if (!cancellationToken.CanBeCanceled)
    {
        return DefaultRequestContext;
    }

    return new Azure.RequestContext() { CancellationToken = cancellationToken };
}

private static ResponseClassifier _responseClassifier200;
private static ResponseClassifier ResponseClassifier200 => _responseClassifier200 ??= new StatusCodeClassifier(stackalloc ushort[] { 200 });
}
}
