// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.Monitor.Ingestion
{
    // Data plane generated client.
    /// <summary> The Metrics service client. </summary>
    public partial class MetricsClient
    {
        private static readonly string[] AuthorizationScopes = new string[] { "https://monitor.azure.com//.default" };
        private readonly TokenCredential _tokenCredential;
        private readonly HttpPipeline _pipeline;
        private readonly string _endpoint;
        private readonly string _apiVersion;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of MetricsClient for mocking. </summary>
        protected MetricsClient()
        {
        }

        /// <summary> Initializes a new instance of MetricsClient. </summary>
        /// <param name="endpoint"> The regional endpoint to use, for example https://eastus.metrics.monitor.azure.com. The region should match the region of the requested resources. For global resources, the region should be 'global'. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="endpoint"/> or <paramref name="credential"/> is null. </exception>
        public MetricsClient(string endpoint, TokenCredential credential) : this(endpoint, credential, new MetricsClientOptions())
        {
        }

        /// <summary> Initializes a new instance of MetricsClient. </summary>
        /// <param name="endpoint"> The regional endpoint to use, for example https://eastus.metrics.monitor.azure.com. The region should match the region of the requested resources. For global resources, the region should be 'global'. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="endpoint"/> or <paramref name="credential"/> is null. </exception>
        public MetricsClient(string endpoint, TokenCredential credential, MetricsClientOptions options)
        {
            Argument.AssertNotNull(endpoint, nameof(endpoint));
            Argument.AssertNotNull(credential, nameof(credential));
            options ??= new MetricsClientOptions();

            ClientDiagnostics = new ClientDiagnostics(options, true);
            _tokenCredential = credential;
            _pipeline = HttpPipelineBuilder.Build(options, Array.Empty<HttpPipelinePolicy>(), new HttpPipelinePolicy[] { new BearerTokenAuthenticationPolicy(_tokenCredential, AuthorizationScopes) }, new ResponseClassifier());
            _endpoint = endpoint;
            _apiVersion = options.Version;
        }

        /// <summary>
        /// [Protocol Method] Lists the metric values for multiple resources.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The subscription identifier for the resources in this batch. </param>
        /// <param name="metricnamespace"> Metric namespace that contains the requested metric names. </param>
        /// <param name="metricnames"> The names of the metrics (comma separated) to retrieve. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="starttime">
        /// The start time of the query. It is a string in the format 'yyyy-MM-ddTHH:mm:ss.fffZ'. If you have specified the endtime parameter, then this parameter is required.
        /// If only starttime is specified, then endtime defaults to the current time.
        /// If no time interval is specified, the default is 1 hour.
        /// </param>
        /// <param name="endtime"> The end time of the query. It is a string in the format 'yyyy-MM-ddTHH:mm:ss.fffZ'. </param>
        /// <param name="interval">
        /// The interval (i.e. timegrain) of the query in ISO 8601 duration format. Defaults to PT1M. Special case for 'FULL' value that returns single datapoint for entire time span requested.
        /// *Examples: PT15M, PT1H, P1D*, FULL
        /// </param>
        /// <param name="aggregation"> The list of aggregation types (comma separated) to retrieve. </param>
        /// <param name="top">
        /// The maximum number of records to retrieve.
        /// Valid only if $filter is specified.
        /// Defaults to 10.
        /// </param>
        /// <param name="orderby">
        /// The aggregation to use for sorting results and the direction of the sort.
        /// Only one order can be specified.
        /// Examples: sum asc.
        /// </param>
        /// <param name="filter"> The filter is used to reduce the set of metric data returned.&lt;br&gt;Example:&lt;br&gt;Metric contains metadata A, B and C.&lt;br&gt;- Return all time series of C where A = a1 and B = b1 or b2&lt;br&gt;**filter=A eq ‘a1’ and B eq ‘b1’ or B eq ‘b2’ and C eq ‘*’**&lt;br&gt;- Invalid variant:&lt;br&gt;**filter=A eq ‘a1’ and B eq ‘b1’ and C eq ‘*’ or B = ‘b2’**&lt;br&gt;This is invalid because the logical or operator cannot separate two different metadata names.&lt;br&gt;- Return all time series where A = a1, B = b1 and C = c1:&lt;br&gt;**filter=A eq ‘a1’ and B eq ‘b1’ and C eq ‘c1’**&lt;br&gt;- Return all time series where A = a1&lt;br&gt;**filter=A eq ‘a1’ and B eq ‘*’ and C eq ‘*’**. </param>
        /// <param name="autoAdjustTimegrain"> When set to true, if the timespan passed in is not supported by this metric, the API will return the result using the closest supported timespan. When set to false, an error is returned for invalid timespan parameters. Defaults to false. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="metricnamespace"/>, <paramref name="metricnames"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/MetricsClient.xml" path="doc/members/member[@name='BatchAsync(Guid,string,IEnumerable{string},RequestContent,string,string,string,string,int?,string,string,bool?,RequestContext)']/*" />
        public virtual async Task<Response> BatchAsync(Guid subscriptionId, string metricnamespace, IEnumerable<string> metricnames, RequestContent content, string starttime = null, string endtime = null, string interval = null, string aggregation = null, int? top = null, string orderby = null, string filter = null, bool? autoAdjustTimegrain = null, RequestContext context = null)
        {
            Argument.AssertNotNull(metricnamespace, nameof(metricnamespace));
            Argument.AssertNotNull(metricnames, nameof(metricnames));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("MetricsClient.Batch");
            scope.Start();
            try
            {
                using HttpMessage message = CreateBatchRequest(subscriptionId, metricnamespace, metricnames, content, starttime, endtime, interval, aggregation, top, orderby, filter, autoAdjustTimegrain, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Lists the metric values for multiple resources.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The subscription identifier for the resources in this batch. </param>
        /// <param name="metricnamespace"> Metric namespace that contains the requested metric names. </param>
        /// <param name="metricnames"> The names of the metrics (comma separated) to retrieve. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="starttime">
        /// The start time of the query. It is a string in the format 'yyyy-MM-ddTHH:mm:ss.fffZ'. If you have specified the endtime parameter, then this parameter is required.
        /// If only starttime is specified, then endtime defaults to the current time.
        /// If no time interval is specified, the default is 1 hour.
        /// </param>
        /// <param name="endtime"> The end time of the query. It is a string in the format 'yyyy-MM-ddTHH:mm:ss.fffZ'. </param>
        /// <param name="interval">
        /// The interval (i.e. timegrain) of the query in ISO 8601 duration format. Defaults to PT1M. Special case for 'FULL' value that returns single datapoint for entire time span requested.
        /// *Examples: PT15M, PT1H, P1D*, FULL
        /// </param>
        /// <param name="aggregation"> The list of aggregation types (comma separated) to retrieve. </param>
        /// <param name="top">
        /// The maximum number of records to retrieve.
        /// Valid only if $filter is specified.
        /// Defaults to 10.
        /// </param>
        /// <param name="orderby">
        /// The aggregation to use for sorting results and the direction of the sort.
        /// Only one order can be specified.
        /// Examples: sum asc.
        /// </param>
        /// <param name="filter"> The filter is used to reduce the set of metric data returned.&lt;br&gt;Example:&lt;br&gt;Metric contains metadata A, B and C.&lt;br&gt;- Return all time series of C where A = a1 and B = b1 or b2&lt;br&gt;**filter=A eq ‘a1’ and B eq ‘b1’ or B eq ‘b2’ and C eq ‘*’**&lt;br&gt;- Invalid variant:&lt;br&gt;**filter=A eq ‘a1’ and B eq ‘b1’ and C eq ‘*’ or B = ‘b2’**&lt;br&gt;This is invalid because the logical or operator cannot separate two different metadata names.&lt;br&gt;- Return all time series where A = a1, B = b1 and C = c1:&lt;br&gt;**filter=A eq ‘a1’ and B eq ‘b1’ and C eq ‘c1’**&lt;br&gt;- Return all time series where A = a1&lt;br&gt;**filter=A eq ‘a1’ and B eq ‘*’ and C eq ‘*’**. </param>
        /// <param name="autoAdjustTimegrain"> When set to true, if the timespan passed in is not supported by this metric, the API will return the result using the closest supported timespan. When set to false, an error is returned for invalid timespan parameters. Defaults to false. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="metricnamespace"/>, <paramref name="metricnames"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/MetricsClient.xml" path="doc/members/member[@name='Batch(Guid,string,IEnumerable{string},RequestContent,string,string,string,string,int?,string,string,bool?,RequestContext)']/*" />
        public virtual Response Batch(Guid subscriptionId, string metricnamespace, IEnumerable<string> metricnames, RequestContent content, string starttime = null, string endtime = null, string interval = null, string aggregation = null, int? top = null, string orderby = null, string filter = null, bool? autoAdjustTimegrain = null, RequestContext context = null)
        {
            Argument.AssertNotNull(metricnamespace, nameof(metricnamespace));
            Argument.AssertNotNull(metricnames, nameof(metricnames));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("MetricsClient.Batch");
            scope.Start();
            try
            {
                using HttpMessage message = CreateBatchRequest(subscriptionId, metricnamespace, metricnames, content, starttime, endtime, interval, aggregation, top, orderby, filter, autoAdjustTimegrain, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateBatchRequest(Guid subscriptionId, string metricnamespace, IEnumerable<string> metricnames, RequestContent content, string starttime, string endtime, string interval, string aggregation, int? top, string orderby, string filter, bool? autoAdjustTimegrain, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_endpoint, false);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/metrics:getBatch", false);
            uri.AppendQuery("metricnamespace", metricnamespace, true);
            if (metricnames != null && Optional.IsCollectionDefined(metricnames))
            {
                uri.AppendQueryDelimited("metricnames", metricnames, ",", true);
            }
            if (starttime != null)
            {
                uri.AppendQuery("starttime", starttime, true);
            }
            if (endtime != null)
            {
                uri.AppendQuery("endtime", endtime, true);
            }
            if (interval != null)
            {
                uri.AppendQuery("interval", interval, true);
            }
            if (aggregation != null)
            {
                uri.AppendQuery("aggregation", aggregation, true);
            }
            if (top != null)
            {
                uri.AppendQuery("top", top.Value, true);
            }
            if (orderby != null)
            {
                uri.AppendQuery("orderby", orderby, true);
            }
            if (filter != null)
            {
                uri.AppendQuery("filter", filter, true);
            }
            if (autoAdjustTimegrain != null)
            {
                uri.AppendQuery("AutoAdjustTimegrain", autoAdjustTimegrain.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        private static ResponseClassifier _responseClassifier200;
        private static ResponseClassifier ResponseClassifier200 => _responseClassifier200 ??= new StatusCodeClassifier(stackalloc ushort[] { 200 });
    }
}
