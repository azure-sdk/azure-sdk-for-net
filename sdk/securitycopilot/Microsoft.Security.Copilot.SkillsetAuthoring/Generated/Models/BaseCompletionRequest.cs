// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;
using Azure.Core;

namespace Microsoft.Security.Copilot.SkillsetAuthoring.Models
{
    /// <summary> Represents the base completion request with common parameters. </summary>
    public partial class BaseCompletionRequest
    {
        /// <summary> Initializes a new instance of BaseCompletionRequest. </summary>
        /// <param name="stop"> Stop sequences to terminate generation. </param>
        /// <param name="logitBias"> Adjusts likelihood of specific tokens. </param>
        /// <param name="responseFormat"> The response format specification. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="stop"/>, <paramref name="logitBias"/> or <paramref name="responseFormat"/> is null. </exception>
        internal BaseCompletionRequest(IEnumerable<string> stop, IReadOnlyDictionary<string, int> logitBias, BinaryData responseFormat)
        {
            Argument.AssertNotNull(stop, nameof(stop));
            Argument.AssertNotNull(logitBias, nameof(logitBias));
            Argument.AssertNotNull(responseFormat, nameof(responseFormat));

            Stop = stop.ToList();
            LogitBias = logitBias;
            ResponseFormat = responseFormat;
        }

        /// <summary> Initializes a new instance of BaseCompletionRequest. </summary>
        /// <param name="maxTokens"> The maximum number of tokens to generate. </param>
        /// <param name="temperature"> The sampling temperature to use. </param>
        /// <param name="topP"> The nucleus sampling parameter. </param>
        /// <param name="n"> The number of completions to generate. </param>
        /// <param name="stream"> Specifies whether to stream the response. </param>
        /// <param name="logprobs"> The number of log probabilities to include. </param>
        /// <param name="echo"> Whether to include the prompt in the output. </param>
        /// <param name="stop"> Stop sequences to terminate generation. </param>
        /// <param name="presencePenalty"> The penalty for repeating words in the presence. </param>
        /// <param name="frequencyPenalty"> The penalty for repeating tokens. </param>
        /// <param name="bestOf"> The number of completions to choose the best from. </param>
        /// <param name="logitBias"> Adjusts likelihood of specific tokens. </param>
        /// <param name="responseFormat"> The response format specification. </param>
        internal BaseCompletionRequest(int? maxTokens, double? temperature, double? topP, int? n, bool? stream, int? logprobs, bool? echo, IReadOnlyList<string> stop, double? presencePenalty, double? frequencyPenalty, int? bestOf, IReadOnlyDictionary<string, int> logitBias, BinaryData responseFormat)
        {
            MaxTokens = maxTokens;
            Temperature = temperature;
            TopP = topP;
            N = n;
            Stream = stream;
            Logprobs = logprobs;
            Echo = echo;
            Stop = stop;
            PresencePenalty = presencePenalty;
            FrequencyPenalty = frequencyPenalty;
            BestOf = bestOf;
            LogitBias = logitBias;
            ResponseFormat = responseFormat;
        }

        /// <summary> The maximum number of tokens to generate. </summary>
        public int? MaxTokens { get; }
        /// <summary> The sampling temperature to use. </summary>
        public double? Temperature { get; }
        /// <summary> The nucleus sampling parameter. </summary>
        public double? TopP { get; }
        /// <summary> The number of completions to generate. </summary>
        public int? N { get; }
        /// <summary> Specifies whether to stream the response. </summary>
        public bool? Stream { get; }
        /// <summary> The number of log probabilities to include. </summary>
        public int? Logprobs { get; }
        /// <summary> Whether to include the prompt in the output. </summary>
        public bool? Echo { get; }
        /// <summary> Stop sequences to terminate generation. </summary>
        public IReadOnlyList<string> Stop { get; }
        /// <summary> The penalty for repeating words in the presence. </summary>
        public double? PresencePenalty { get; }
        /// <summary> The penalty for repeating tokens. </summary>
        public double? FrequencyPenalty { get; }
        /// <summary> The number of completions to choose the best from. </summary>
        public int? BestOf { get; }
        /// <summary> Adjusts likelihood of specific tokens. </summary>
        public IReadOnlyDictionary<string, int> LogitBias { get; }
        /// <summary>
        /// The response format specification.
        /// <para>
        /// To assign an object to this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formated json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        public BinaryData ResponseFormat { get; }
    }
}
