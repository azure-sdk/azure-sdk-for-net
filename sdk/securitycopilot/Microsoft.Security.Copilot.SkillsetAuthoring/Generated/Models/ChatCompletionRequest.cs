// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;
using Azure.Core;

namespace Microsoft.Security.Copilot.SkillsetAuthoring.Models
{
    /// <summary> Represents a chat completion request. </summary>
    public partial class ChatCompletionRequest : BaseCompletionRequest
    {
        /// <summary> Initializes a new instance of ChatCompletionRequest. </summary>
        /// <param name="stop"> Stop sequences to terminate generation. </param>
        /// <param name="logitBias"> Adjusts likelihood of specific tokens. </param>
        /// <param name="responseFormat"> The response format specification. </param>
        /// <param name="messages"> The messages associated with the request. </param>
        /// <param name="functions"> The functions associated with the request. </param>
        /// <param name="functionCall"> Specifies the function to call. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="stop"/>, <paramref name="logitBias"/>, <paramref name="responseFormat"/>, <paramref name="messages"/>, <paramref name="functions"/> or <paramref name="functionCall"/> is null. </exception>
        public ChatCompletionRequest(IEnumerable<string> stop, IReadOnlyDictionary<string, int> logitBias, BinaryData responseFormat, IEnumerable<Message> messages, IEnumerable<GPTFunction> functions, string functionCall) : base(stop, logitBias, responseFormat)
        {
            Argument.AssertNotNull(stop, nameof(stop));
            Argument.AssertNotNull(logitBias, nameof(logitBias));
            Argument.AssertNotNull(responseFormat, nameof(responseFormat));
            Argument.AssertNotNull(messages, nameof(messages));
            Argument.AssertNotNull(functions, nameof(functions));
            Argument.AssertNotNull(functionCall, nameof(functionCall));

            Messages = messages.ToList();
            Functions = functions.ToList();
            FunctionCall = functionCall;
            Tools = new ChangeTrackingList<Tools>();
        }

        /// <summary> Initializes a new instance of ChatCompletionRequest. </summary>
        /// <param name="maxTokens"> The maximum number of tokens to generate. </param>
        /// <param name="temperature"> The sampling temperature to use. </param>
        /// <param name="topP"> The nucleus sampling parameter. </param>
        /// <param name="n"> The number of completions to generate. </param>
        /// <param name="stream"> Specifies whether to stream the response. </param>
        /// <param name="logprobs"> The number of log probabilities to include. </param>
        /// <param name="echo"> Whether to include the prompt in the output. </param>
        /// <param name="stop"> Stop sequences to terminate generation. </param>
        /// <param name="presencePenalty"> The penalty for repeating words in the presence. </param>
        /// <param name="frequencyPenalty"> The penalty for repeating tokens. </param>
        /// <param name="bestOf"> The number of completions to choose the best from. </param>
        /// <param name="logitBias"> Adjusts likelihood of specific tokens. </param>
        /// <param name="responseFormat"> The response format specification. </param>
        /// <param name="messages"> The messages associated with the request. </param>
        /// <param name="functions"> The functions associated with the request. </param>
        /// <param name="functionCall"> Specifies the function to call. </param>
        /// <param name="tools"> The tools available for this request. </param>
        /// <param name="toolChoice"> The selected tool for execution. </param>
        /// <param name="parallelToolCalls"> Indicates whether tools can be called in parallel. </param>
        internal ChatCompletionRequest(int? maxTokens, double? temperature, double? topP, int? n, bool? stream, int? logprobs, bool? echo, IReadOnlyList<string> stop, double? presencePenalty, double? frequencyPenalty, int? bestOf, IReadOnlyDictionary<string, int> logitBias, BinaryData responseFormat, IList<Message> messages, IList<GPTFunction> functions, string functionCall, IList<Tools> tools, string toolChoice, bool? parallelToolCalls) : base(maxTokens, temperature, topP, n, stream, logprobs, echo, stop, presencePenalty, frequencyPenalty, bestOf, logitBias, responseFormat)
        {
            Messages = messages;
            Functions = functions;
            FunctionCall = functionCall;
            Tools = tools;
            ToolChoice = toolChoice;
            ParallelToolCalls = parallelToolCalls;
        }

        /// <summary> The messages associated with the request. </summary>
        public IList<Message> Messages { get; }
        /// <summary> The functions associated with the request. </summary>
        public IList<GPTFunction> Functions { get; }
        /// <summary> Specifies the function to call. </summary>
        public string FunctionCall { get; }
        /// <summary> The tools available for this request. </summary>
        public IList<Tools> Tools { get; }
        /// <summary> The selected tool for execution. </summary>
        public string ToolChoice { get; set; }
        /// <summary> Indicates whether tools can be called in parallel. </summary>
        public bool? ParallelToolCalls { get; set; }
    }
}
