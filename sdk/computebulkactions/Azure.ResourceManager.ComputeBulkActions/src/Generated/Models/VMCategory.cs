// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ComponentModel;
using Azure.ResourceManager.ComputeBulkActions;

namespace Azure.ResourceManager.ComputeBulkActions.Models
{
    /// <summary>
    ///       VMCategories defined for Azure VMs.
    ///       See: https://learn.microsoft.com/en-us/azure/virtual-machines/sizes/overview?tabs=breakdownseries%2Cgeneralsizelist%2Ccomputesizelist%2Cmemorysizelist%2Cstoragesizelist%2Cgpusizelist%2Cfpgasizelist%2Chpcsizelist#general-purpose
    /// </summary>
    public readonly partial struct VMCategory : IEquatable<VMCategory>
    {
        private readonly string _value;
        /// <summary>     General purpose VM sizes provide balanced CPU-to-memory ratio. Ideal for testing and development, small to medium databases, and low to medium traffic web servers. </summary>
        private const string GeneralPurposeValue = "GeneralPurpose";
        /// <summary>     Compute optimized VM sizes have a high CPU-to-memory ratio. These sizes are good for medium traffic web servers, network appliances, batch processes, and application servers. </summary>
        private const string ComputeOptimizedValue = "ComputeOptimized";
        /// <summary>     Memory optimized VM sizes offer a high memory-to-CPU ratio that is great for relational database servers, medium to large caches, and in-memory analytics. </summary>
        private const string MemoryOptimizedValue = "MemoryOptimized";
        /// <summary>
        ///     Storage optimized virtual machine (VM) sizes offer high disk throughput and IO, and are ideal for Big Data, SQL, NoSQL databases, data warehousing, and large transactional databases. 
        ///     Examples include Cassandra, MongoDB, Cloudera, and Redis.
        /// </summary>
        private const string StorageOptimizedValue = "StorageOptimized";
        /// <summary>
        ///     GPU optimized VM sizes are specialized virtual machines available with single, multiple, or fractional GPUs. 
        ///     These sizes are designed for compute-intensive, graphics-intensive, and visualization workloads.
        /// </summary>
        private const string GpuAcceleratedValue = "GpuAccelerated";
        /// <summary>
        ///     FPGA optimized VM sizes are specialized virtual machines available with single or multiple FPGA. 
        ///     These sizes are designed for compute-intensive workloads. This article provides information about the number and type of FPGA, vCPUs, data disks, and NICs. 
        ///     Storage throughput and network bandwidth are also included for each size in this grouping.
        /// </summary>
        private const string FpgaAcceleratedValue = "FpgaAccelerated";
        /// <summary>
        ///     Azure High Performance Compute VMs are optimized for various HPC workloads such as computational fluid dynamics, finite element analysis, frontend and backend EDA, 
        ///     rendering, molecular dynamics, computational geo science, weather simulation, and financial risk analysis.
        /// </summary>
        private const string HighPerformanceComputeValue = "HighPerformanceCompute";

        /// <summary> Initializes a new instance of <see cref="VMCategory"/>. </summary>
        /// <param name="value"> The value. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="value"/> is null. </exception>
        public VMCategory(string value)
        {
            Argument.AssertNotNull(value, nameof(value));

            _value = value;
        }

        /// <summary>     General purpose VM sizes provide balanced CPU-to-memory ratio. Ideal for testing and development, small to medium databases, and low to medium traffic web servers. </summary>
        public static VMCategory GeneralPurpose { get; } = new VMCategory(GeneralPurposeValue);

        /// <summary>     Compute optimized VM sizes have a high CPU-to-memory ratio. These sizes are good for medium traffic web servers, network appliances, batch processes, and application servers. </summary>
        public static VMCategory ComputeOptimized { get; } = new VMCategory(ComputeOptimizedValue);

        /// <summary>     Memory optimized VM sizes offer a high memory-to-CPU ratio that is great for relational database servers, medium to large caches, and in-memory analytics. </summary>
        public static VMCategory MemoryOptimized { get; } = new VMCategory(MemoryOptimizedValue);

        /// <summary>
        ///     Storage optimized virtual machine (VM) sizes offer high disk throughput and IO, and are ideal for Big Data, SQL, NoSQL databases, data warehousing, and large transactional databases. 
        ///     Examples include Cassandra, MongoDB, Cloudera, and Redis.
        /// </summary>
        public static VMCategory StorageOptimized { get; } = new VMCategory(StorageOptimizedValue);

        /// <summary>
        ///     GPU optimized VM sizes are specialized virtual machines available with single, multiple, or fractional GPUs. 
        ///     These sizes are designed for compute-intensive, graphics-intensive, and visualization workloads.
        /// </summary>
        public static VMCategory GpuAccelerated { get; } = new VMCategory(GpuAcceleratedValue);

        /// <summary>
        ///     FPGA optimized VM sizes are specialized virtual machines available with single or multiple FPGA. 
        ///     These sizes are designed for compute-intensive workloads. This article provides information about the number and type of FPGA, vCPUs, data disks, and NICs. 
        ///     Storage throughput and network bandwidth are also included for each size in this grouping.
        /// </summary>
        public static VMCategory FpgaAccelerated { get; } = new VMCategory(FpgaAcceleratedValue);

        /// <summary>
        ///     Azure High Performance Compute VMs are optimized for various HPC workloads such as computational fluid dynamics, finite element analysis, frontend and backend EDA, 
        ///     rendering, molecular dynamics, computational geo science, weather simulation, and financial risk analysis.
        /// </summary>
        public static VMCategory HighPerformanceCompute { get; } = new VMCategory(HighPerformanceComputeValue);

        /// <summary> Determines if two <see cref="VMCategory"/> values are the same. </summary>
        /// <param name="left"> The left value to compare. </param>
        /// <param name="right"> The right value to compare. </param>
        public static bool operator ==(VMCategory left, VMCategory right) => left.Equals(right);

        /// <summary> Determines if two <see cref="VMCategory"/> values are not the same. </summary>
        /// <param name="left"> The left value to compare. </param>
        /// <param name="right"> The right value to compare. </param>
        public static bool operator !=(VMCategory left, VMCategory right) => !left.Equals(right);

        /// <summary> Converts a string to a <see cref="VMCategory"/>. </summary>
        /// <param name="value"> The value. </param>
        public static implicit operator VMCategory(string value) => new VMCategory(value);

        /// <summary> Converts a string to a <see cref="VMCategory"/>. </summary>
        /// <param name="value"> The value. </param>
        public static implicit operator VMCategory?(string value) => value == null ? null : new VMCategory(value);

        /// <inheritdoc/>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object obj) => obj is VMCategory other && Equals(other);

        /// <inheritdoc/>
        public bool Equals(VMCategory other) => string.Equals(_value, other._value, StringComparison.InvariantCultureIgnoreCase);

        /// <inheritdoc/>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value != null ? StringComparer.InvariantCultureIgnoreCase.GetHashCode(_value) : 0;

        /// <inheritdoc/>
        public override string ToString() => _value;
    }
}
