// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.AI.Vision.Face
{
    // Data plane generated client.
    /// <summary> The FaceAdministration service client. </summary>
    public partial class FaceAdministrationClient
    {
        private const string AuthorizationHeader = "Ocp-Apim-Subscription-Key";
        private readonly AzureKeyCredential _keyCredential;
        private static readonly string[] AuthorizationScopes = new string[] { "https://cognitiveservices.azure.com/.default" };
        private readonly TokenCredential _tokenCredential;
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;
        private readonly string _apiVersion;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of FaceAdministrationClient for mocking. </summary>
        protected FaceAdministrationClient()
        {
        }

        /// <summary> Initializes a new instance of FaceAdministrationClient. </summary>
        /// <param name="endpoint">
        /// Supported Cognitive Services endpoints (protocol and hostname, for example:
        /// https://{resource-name}.cognitiveservices.azure.com).
        /// </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="endpoint"/> or <paramref name="credential"/> is null. </exception>
        public FaceAdministrationClient(Uri endpoint, AzureKeyCredential credential) : this(endpoint, credential, new AzureAIVisionFaceClientOptions())
        {
        }

        /// <summary> Initializes a new instance of FaceAdministrationClient. </summary>
        /// <param name="endpoint">
        /// Supported Cognitive Services endpoints (protocol and hostname, for example:
        /// https://{resource-name}.cognitiveservices.azure.com).
        /// </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="endpoint"/> or <paramref name="credential"/> is null. </exception>
        public FaceAdministrationClient(Uri endpoint, TokenCredential credential) : this(endpoint, credential, new AzureAIVisionFaceClientOptions())
        {
        }

        /// <summary> Initializes a new instance of FaceAdministrationClient. </summary>
        /// <param name="endpoint">
        /// Supported Cognitive Services endpoints (protocol and hostname, for example:
        /// https://{resource-name}.cognitiveservices.azure.com).
        /// </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="endpoint"/> or <paramref name="credential"/> is null. </exception>
        public FaceAdministrationClient(Uri endpoint, AzureKeyCredential credential, AzureAIVisionFaceClientOptions options)
        {
            Argument.AssertNotNull(endpoint, nameof(endpoint));
            Argument.AssertNotNull(credential, nameof(credential));
            options ??= new AzureAIVisionFaceClientOptions();

            ClientDiagnostics = new ClientDiagnostics(options, true);
            _keyCredential = credential;
            _pipeline = HttpPipelineBuilder.Build(options, Array.Empty<HttpPipelinePolicy>(), new HttpPipelinePolicy[] { new AzureKeyCredentialPolicy(_keyCredential, AuthorizationHeader) }, new ResponseClassifier());
            _endpoint = endpoint;
            _apiVersion = options.Version;
        }

        /// <summary> Initializes a new instance of FaceAdministrationClient. </summary>
        /// <param name="endpoint">
        /// Supported Cognitive Services endpoints (protocol and hostname, for example:
        /// https://{resource-name}.cognitiveservices.azure.com).
        /// </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="endpoint"/> or <paramref name="credential"/> is null. </exception>
        public FaceAdministrationClient(Uri endpoint, TokenCredential credential, AzureAIVisionFaceClientOptions options)
        {
            Argument.AssertNotNull(endpoint, nameof(endpoint));
            Argument.AssertNotNull(credential, nameof(credential));
            options ??= new AzureAIVisionFaceClientOptions();

            ClientDiagnostics = new ClientDiagnostics(options, true);
            _tokenCredential = credential;
            _pipeline = HttpPipelineBuilder.Build(options, Array.Empty<HttpPipelinePolicy>(), new HttpPipelinePolicy[] { new BearerTokenAuthenticationPolicy(_tokenCredential, AuthorizationScopes) }, new ResponseClassifier());
            _endpoint = endpoint;
            _apiVersion = options.Version;
        }

        /// <summary> Create an empty face list with user-specified faceListId, name, an optional userData and recognitionModel. </summary>
        /// <param name="faceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="resource"> The resource instance. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> or <paramref name="resource"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Up to 64 face lists are allowed in one subscription.
        ///
        /// Face list is a list of faces, up to 1,000 faces, and used by Face - Find Similar.
        ///
        /// After creation, user should use FaceList - Add Face to import the faces. No image will be stored. Only the extracted face feature(s) will be stored on server until FaceList - Delete is called.
        ///
        /// Find Similar is used for scenario like finding celebrity-like faces, similar face filtering, or as a light way face identification. But if the actual use is to identify person, please use PersonGroup / LargePersonGroup and Face - Identify.
        ///
        /// Please consider LargeFaceList when the face number is large. It can support up to 1,000,000 faces.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreateFaceListAsync(string,FaceList,CancellationToken)']/*" />
        public virtual async Task<Response> CreateFaceListAsync(string faceListId, FaceList resource, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(faceListId, nameof(faceListId));
            Argument.AssertNotNull(resource, nameof(resource));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = resource.ToRequestContent();
            Response response = await CreateFaceListAsync(faceListId, content, context).ConfigureAwait(false);
            return response;
        }

        /// <summary> Create an empty face list with user-specified faceListId, name, an optional userData and recognitionModel. </summary>
        /// <param name="faceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="resource"> The resource instance. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> or <paramref name="resource"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Up to 64 face lists are allowed in one subscription.
        ///
        /// Face list is a list of faces, up to 1,000 faces, and used by Face - Find Similar.
        ///
        /// After creation, user should use FaceList - Add Face to import the faces. No image will be stored. Only the extracted face feature(s) will be stored on server until FaceList - Delete is called.
        ///
        /// Find Similar is used for scenario like finding celebrity-like faces, similar face filtering, or as a light way face identification. But if the actual use is to identify person, please use PersonGroup / LargePersonGroup and Face - Identify.
        ///
        /// Please consider LargeFaceList when the face number is large. It can support up to 1,000,000 faces.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreateFaceList(string,FaceList,CancellationToken)']/*" />
        public virtual Response CreateFaceList(string faceListId, FaceList resource, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(faceListId, nameof(faceListId));
            Argument.AssertNotNull(resource, nameof(resource));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = resource.ToRequestContent();
            Response response = CreateFaceList(faceListId, content, context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] Create an empty face list with user-specified faceListId, name, an optional userData and recognitionModel.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateFaceListAsync(string,FaceList,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="faceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreateFaceListAsync(string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> CreateFaceListAsync(string faceListId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(faceListId, nameof(faceListId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.CreateFaceList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateFaceListRequest(faceListId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Create an empty face list with user-specified faceListId, name, an optional userData and recognitionModel.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateFaceList(string,FaceList,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="faceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreateFaceList(string,RequestContent,RequestContext)']/*" />
        public virtual Response CreateFaceList(string faceListId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(faceListId, nameof(faceListId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.CreateFaceList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateFaceListRequest(faceListId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete a specified face list.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="faceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeleteFaceListAsync(string,RequestContext)']/*" />
        public virtual async Task<Response> DeleteFaceListAsync(string faceListId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(faceListId, nameof(faceListId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeleteFaceList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteFaceListRequest(faceListId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete a specified face list.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="faceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeleteFaceList(string,RequestContext)']/*" />
        public virtual Response DeleteFaceList(string faceListId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(faceListId, nameof(faceListId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeleteFaceList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteFaceListRequest(faceListId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieve a face list's faceListId, name, userData, recognitionModel and faces in the face list. </summary>
        /// <param name="faceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetFaceListAsync(string,bool?,CancellationToken)']/*" />
        public virtual async Task<Response<FaceList>> GetFaceListAsync(string faceListId, bool? returnRecognitionModel = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(faceListId, nameof(faceListId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetFaceListAsync(faceListId, returnRecognitionModel, context).ConfigureAwait(false);
            return Response.FromValue(FaceList.FromResponse(response), response);
        }

        /// <summary> Retrieve a face list's faceListId, name, userData, recognitionModel and faces in the face list. </summary>
        /// <param name="faceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetFaceList(string,bool?,CancellationToken)']/*" />
        public virtual Response<FaceList> GetFaceList(string faceListId, bool? returnRecognitionModel = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(faceListId, nameof(faceListId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetFaceList(faceListId, returnRecognitionModel, context);
            return Response.FromValue(FaceList.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Retrieve a face list's faceListId, name, userData, recognitionModel and faces in the face list.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetFaceListAsync(string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="faceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetFaceListAsync(string,bool?,RequestContext)']/*" />
        public virtual async Task<Response> GetFaceListAsync(string faceListId, bool? returnRecognitionModel, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(faceListId, nameof(faceListId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetFaceList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetFaceListRequest(faceListId, returnRecognitionModel, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Retrieve a face list's faceListId, name, userData, recognitionModel and faces in the face list.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetFaceList(string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="faceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetFaceList(string,bool?,RequestContext)']/*" />
        public virtual Response GetFaceList(string faceListId, bool? returnRecognitionModel, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(faceListId, nameof(faceListId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetFaceList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetFaceListRequest(faceListId, returnRecognitionModel, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update information of a face list, including name and userData.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="faceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdateFaceListAsync(string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> UpdateFaceListAsync(string faceListId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(faceListId, nameof(faceListId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdateFaceList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateFaceListRequest(faceListId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update information of a face list, including name and userData.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="faceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdateFaceList(string,RequestContent,RequestContext)']/*" />
        public virtual Response UpdateFaceList(string faceListId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(faceListId, nameof(faceListId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdateFaceList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateFaceListRequest(faceListId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// List face lists' faceListId, name, userData and recognitionModel.
        ///
        /// To get face information inside faceList use Get Face List.
        /// </summary>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetFaceListsAsync(bool?,CancellationToken)']/*" />
        public virtual async Task<Response<IReadOnlyList<FaceListItem>>> GetFaceListsAsync(bool? returnRecognitionModel = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetFaceListsAsync(returnRecognitionModel, context).ConfigureAwait(false);
            IReadOnlyList<FaceListItem> value = default;
            using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
            List<FaceListItem> array = new List<FaceListItem>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(FaceListItem.DeserializeFaceListItem(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// List face lists' faceListId, name, userData and recognitionModel.
        ///
        /// To get face information inside faceList use Get Face List.
        /// </summary>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetFaceLists(bool?,CancellationToken)']/*" />
        public virtual Response<IReadOnlyList<FaceListItem>> GetFaceLists(bool? returnRecognitionModel = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetFaceLists(returnRecognitionModel, context);
            IReadOnlyList<FaceListItem> value = default;
            using var document = JsonDocument.Parse(response.ContentStream);
            List<FaceListItem> array = new List<FaceListItem>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(FaceListItem.DeserializeFaceListItem(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// [Protocol Method] List face lists' faceListId, name, userData and recognitionModel.
        ///
        /// To get face information inside faceList use Get Face List.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetFaceListsAsync(bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetFaceListsAsync(bool?,RequestContext)']/*" />
        public virtual async Task<Response> GetFaceListsAsync(bool? returnRecognitionModel, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetFaceLists");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetFaceListsRequest(returnRecognitionModel, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] List face lists' faceListId, name, userData and recognitionModel.
        ///
        /// To get face information inside faceList use Get Face List.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetFaceLists(bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetFaceLists(bool?,RequestContext)']/*" />
        public virtual Response GetFaceLists(bool? returnRecognitionModel, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetFaceLists");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetFaceListsRequest(returnRecognitionModel, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Add a face to a specified face list, up to 1,000 faces. </summary>
        /// <param name="faceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="url"> URL of input image. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> or <paramref name="url"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// To deal with an image containing multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature(s) will be stored on server until FaceList - Delete Face or FaceList - Delete is called.
        ///
        /// Note persistedFaceId is different from faceId generated by Face - Detect.
        ///
        /// * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        /// * Each person entry can hold up to 248 faces.
        /// * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
        /// * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from Face - Detect, there's no guarantee to detect and add the face successfully.
        /// * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
        /// * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
        /// * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to https://learn.microsoft.com/en-us/azure/ai-services/computer-vision/how-to/specify-detection-model
        ///   * 'detection_01': The default detection model for PersonDirectory Person - Add Face. Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected.
        ///   * 'detection_02': Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces.
        ///   * 'detection_03': Detection model released in 2021 February with improved accuracy especially on small faces.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddFaceListFaceFromUrlAsync(string,Uri,string,FaceDetectionModel?,string,CancellationToken)']/*" />
        public virtual async Task<Response<AddFaceResult>> AddFaceListFaceFromUrlAsync(string faceListId, Uri url, string targetFace = null, FaceDetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(faceListId, nameof(faceListId));
            Argument.AssertNotNull(url, nameof(url));

            RequestContext context = FromCancellationToken(cancellationToken);
            AddFaceListFaceFromUrlRequest addFaceListFaceFromUrlRequest = new AddFaceListFaceFromUrlRequest(url);
            Response response = await AddFaceListFaceFromUrlAsync(faceListId, addFaceListFaceFromUrlRequest.ToRequestContent(), targetFace, detectionModel?.ToString(), userData, context).ConfigureAwait(false);
            return Response.FromValue(AddFaceResult.FromResponse(response), response);
        }

        /// <summary> Add a face to a specified face list, up to 1,000 faces. </summary>
        /// <param name="faceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="url"> URL of input image. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> or <paramref name="url"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// To deal with an image containing multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature(s) will be stored on server until FaceList - Delete Face or FaceList - Delete is called.
        ///
        /// Note persistedFaceId is different from faceId generated by Face - Detect.
        ///
        /// * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        /// * Each person entry can hold up to 248 faces.
        /// * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
        /// * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from Face - Detect, there's no guarantee to detect and add the face successfully.
        /// * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
        /// * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
        /// * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to https://learn.microsoft.com/en-us/azure/ai-services/computer-vision/how-to/specify-detection-model
        ///   * 'detection_01': The default detection model for PersonDirectory Person - Add Face. Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected.
        ///   * 'detection_02': Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces.
        ///   * 'detection_03': Detection model released in 2021 February with improved accuracy especially on small faces.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddFaceListFaceFromUrl(string,Uri,string,FaceDetectionModel?,string,CancellationToken)']/*" />
        public virtual Response<AddFaceResult> AddFaceListFaceFromUrl(string faceListId, Uri url, string targetFace = null, FaceDetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(faceListId, nameof(faceListId));
            Argument.AssertNotNull(url, nameof(url));

            RequestContext context = FromCancellationToken(cancellationToken);
            AddFaceListFaceFromUrlRequest addFaceListFaceFromUrlRequest = new AddFaceListFaceFromUrlRequest(url);
            Response response = AddFaceListFaceFromUrl(faceListId, addFaceListFaceFromUrlRequest.ToRequestContent(), targetFace, detectionModel?.ToString(), userData, context);
            return Response.FromValue(AddFaceResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Add a face to a specified face list, up to 1,000 faces.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddFaceListFaceFromUrlAsync(string,Uri,string,FaceDetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="faceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddFaceListFaceFromUrlAsync(string,RequestContent,string,string,string,RequestContext)']/*" />
        public virtual async Task<Response> AddFaceListFaceFromUrlAsync(string faceListId, RequestContent content, string targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(faceListId, nameof(faceListId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.AddFaceListFaceFromUrl");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddFaceListFaceFromUrlRequest(faceListId, content, targetFace, detectionModel, userData, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Add a face to a specified face list, up to 1,000 faces.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddFaceListFaceFromUrl(string,Uri,string,FaceDetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="faceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddFaceListFaceFromUrl(string,RequestContent,string,string,string,RequestContext)']/*" />
        public virtual Response AddFaceListFaceFromUrl(string faceListId, RequestContent content, string targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(faceListId, nameof(faceListId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.AddFaceListFaceFromUrl");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddFaceListFaceFromUrlRequest(faceListId, content, targetFace, detectionModel, userData, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Add a face to a specified face list, up to 1,000 faces. </summary>
        /// <param name="faceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="imageContent"> The image to be analyzed. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> or <paramref name="imageContent"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// To deal with an image containing multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature(s) will be stored on server until FaceList - Delete Face or FaceList - Delete is called.
        ///
        /// Note persistedFaceId is different from faceId generated by Face - Detect.
        ///
        /// * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        /// * Each person entry can hold up to 248 faces.
        /// * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
        /// * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from Face - Detect, there's no guarantee to detect and add the face successfully.
        /// * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
        /// * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
        /// * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to https://learn.microsoft.com/en-us/azure/ai-services/computer-vision/how-to/specify-detection-model
        ///   * 'detection_01': The default detection model for PersonDirectory Person - Add Face. Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected.
        ///   * 'detection_02': Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces.
        ///   * 'detection_03': Detection model released in 2021 February with improved accuracy especially on small faces.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddFaceListFaceAsync(string,BinaryData,string,FaceDetectionModel?,string,CancellationToken)']/*" />
        public virtual async Task<Response<AddFaceResult>> AddFaceListFaceAsync(string faceListId, BinaryData imageContent, string targetFace = null, FaceDetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(faceListId, nameof(faceListId));
            Argument.AssertNotNull(imageContent, nameof(imageContent));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = imageContent;
            Response response = await AddFaceListFaceAsync(faceListId, content, targetFace, detectionModel?.ToString(), userData, context).ConfigureAwait(false);
            return Response.FromValue(AddFaceResult.FromResponse(response), response);
        }

        /// <summary> Add a face to a specified face list, up to 1,000 faces. </summary>
        /// <param name="faceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="imageContent"> The image to be analyzed. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> or <paramref name="imageContent"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// To deal with an image containing multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature(s) will be stored on server until FaceList - Delete Face or FaceList - Delete is called.
        ///
        /// Note persistedFaceId is different from faceId generated by Face - Detect.
        ///
        /// * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        /// * Each person entry can hold up to 248 faces.
        /// * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
        /// * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from Face - Detect, there's no guarantee to detect and add the face successfully.
        /// * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
        /// * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
        /// * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to https://learn.microsoft.com/en-us/azure/ai-services/computer-vision/how-to/specify-detection-model
        ///   * 'detection_01': The default detection model for PersonDirectory Person - Add Face. Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected.
        ///   * 'detection_02': Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces.
        ///   * 'detection_03': Detection model released in 2021 February with improved accuracy especially on small faces.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddFaceListFace(string,BinaryData,string,FaceDetectionModel?,string,CancellationToken)']/*" />
        public virtual Response<AddFaceResult> AddFaceListFace(string faceListId, BinaryData imageContent, string targetFace = null, FaceDetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(faceListId, nameof(faceListId));
            Argument.AssertNotNull(imageContent, nameof(imageContent));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = imageContent;
            Response response = AddFaceListFace(faceListId, content, targetFace, detectionModel?.ToString(), userData, context);
            return Response.FromValue(AddFaceResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Add a face to a specified face list, up to 1,000 faces.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddFaceListFaceAsync(string,BinaryData,string,FaceDetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="faceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddFaceListFaceAsync(string,RequestContent,string,string,string,RequestContext)']/*" />
        public virtual async Task<Response> AddFaceListFaceAsync(string faceListId, RequestContent content, string targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(faceListId, nameof(faceListId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.AddFaceListFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddFaceListFaceRequest(faceListId, content, targetFace, detectionModel, userData, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Add a face to a specified face list, up to 1,000 faces.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddFaceListFace(string,BinaryData,string,FaceDetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="faceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddFaceListFace(string,RequestContent,string,string,string,RequestContext)']/*" />
        public virtual Response AddFaceListFace(string faceListId, RequestContent content, string targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(faceListId, nameof(faceListId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.AddFaceListFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddFaceListFaceRequest(faceListId, content, targetFace, detectionModel, userData, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete a face from a face list by specified faceListId and persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="faceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> or <paramref name="persistedFaceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeleteFaceListFaceAsync(string,string,RequestContext)']/*" />
        public virtual async Task<Response> DeleteFaceListFaceAsync(string faceListId, string persistedFaceId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(faceListId, nameof(faceListId));
            Argument.AssertNotNullOrEmpty(persistedFaceId, nameof(persistedFaceId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeleteFaceListFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteFaceListFaceRequest(faceListId, persistedFaceId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete a face from a face list by specified faceListId and persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="faceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> or <paramref name="persistedFaceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeleteFaceListFace(string,string,RequestContext)']/*" />
        public virtual Response DeleteFaceListFace(string faceListId, string persistedFaceId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(faceListId, nameof(faceListId));
            Argument.AssertNotNullOrEmpty(persistedFaceId, nameof(persistedFaceId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeleteFaceListFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteFaceListFaceRequest(faceListId, persistedFaceId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create an empty large face list with user-specified largeFaceListId, name, an optional userData and recognitionModel. </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="resource"> The resource instance. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="resource"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Large face list is a list of faces, up to 1,000,000 faces, and used by Find Similar.
        ///
        /// After creation, user should use Add Large Face List Face to import the faces and Train Large Face List to make it ready for Find Similar. No image will be stored. Only the extracted face feature(s) will be stored on server until Delete Large Face List is called.
        ///
        /// Find Similar is used for scenario like finding celebrity-like faces, similar face filtering, or as a light way face identification. But if the actual use is to identify person, please use Person Group / Large Person Group and Identify.
        ///
        /// &gt; [!NOTE]
        /// &gt; * Free-tier subscription quota: 64 large face lists.
        /// &gt; * S0-tier subscription quota: 1,000,000 large face lists.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreateLargeFaceListAsync(string,LargeFaceList,CancellationToken)']/*" />
        public virtual async Task<Response> CreateLargeFaceListAsync(string largeFaceListId, LargeFaceList resource, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));
            Argument.AssertNotNull(resource, nameof(resource));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = resource.ToRequestContent();
            Response response = await CreateLargeFaceListAsync(largeFaceListId, content, context).ConfigureAwait(false);
            return response;
        }

        /// <summary> Create an empty large face list with user-specified largeFaceListId, name, an optional userData and recognitionModel. </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="resource"> The resource instance. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="resource"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Large face list is a list of faces, up to 1,000,000 faces, and used by Find Similar.
        ///
        /// After creation, user should use Add Large Face List Face to import the faces and Train Large Face List to make it ready for Find Similar. No image will be stored. Only the extracted face feature(s) will be stored on server until Delete Large Face List is called.
        ///
        /// Find Similar is used for scenario like finding celebrity-like faces, similar face filtering, or as a light way face identification. But if the actual use is to identify person, please use Person Group / Large Person Group and Identify.
        ///
        /// &gt; [!NOTE]
        /// &gt; * Free-tier subscription quota: 64 large face lists.
        /// &gt; * S0-tier subscription quota: 1,000,000 large face lists.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreateLargeFaceList(string,LargeFaceList,CancellationToken)']/*" />
        public virtual Response CreateLargeFaceList(string largeFaceListId, LargeFaceList resource, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));
            Argument.AssertNotNull(resource, nameof(resource));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = resource.ToRequestContent();
            Response response = CreateLargeFaceList(largeFaceListId, content, context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] Create an empty large face list with user-specified largeFaceListId, name, an optional userData and recognitionModel.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateLargeFaceListAsync(string,LargeFaceList,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreateLargeFaceListAsync(string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> CreateLargeFaceListAsync(string largeFaceListId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.CreateLargeFaceList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateLargeFaceListRequest(largeFaceListId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Create an empty large face list with user-specified largeFaceListId, name, an optional userData and recognitionModel.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateLargeFaceList(string,LargeFaceList,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreateLargeFaceList(string,RequestContent,RequestContext)']/*" />
        public virtual Response CreateLargeFaceList(string largeFaceListId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.CreateLargeFaceList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateLargeFaceListRequest(largeFaceListId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete a face from a large face list by specified largeFaceListId and persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeleteLargeFaceListAsync(string,RequestContext)']/*" />
        public virtual async Task<Response> DeleteLargeFaceListAsync(string largeFaceListId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeleteLargeFaceList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteLargeFaceListRequest(largeFaceListId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete a face from a large face list by specified largeFaceListId and persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeleteLargeFaceList(string,RequestContext)']/*" />
        public virtual Response DeleteLargeFaceList(string largeFaceListId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeleteLargeFaceList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteLargeFaceListRequest(largeFaceListId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieve a large face list's largeFaceListId, name, userData and recognitionModel. </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargeFaceListAsync(string,bool?,CancellationToken)']/*" />
        public virtual async Task<Response<LargeFaceList>> GetLargeFaceListAsync(string largeFaceListId, bool? returnRecognitionModel = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetLargeFaceListAsync(largeFaceListId, returnRecognitionModel, context).ConfigureAwait(false);
            return Response.FromValue(LargeFaceList.FromResponse(response), response);
        }

        /// <summary> Retrieve a large face list's largeFaceListId, name, userData and recognitionModel. </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargeFaceList(string,bool?,CancellationToken)']/*" />
        public virtual Response<LargeFaceList> GetLargeFaceList(string largeFaceListId, bool? returnRecognitionModel = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetLargeFaceList(largeFaceListId, returnRecognitionModel, context);
            return Response.FromValue(LargeFaceList.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Retrieve a large face list's largeFaceListId, name, userData and recognitionModel.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLargeFaceListAsync(string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargeFaceListAsync(string,bool?,RequestContext)']/*" />
        public virtual async Task<Response> GetLargeFaceListAsync(string largeFaceListId, bool? returnRecognitionModel, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetLargeFaceList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLargeFaceListRequest(largeFaceListId, returnRecognitionModel, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Retrieve a large face list's largeFaceListId, name, userData and recognitionModel.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLargeFaceList(string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargeFaceList(string,bool?,RequestContext)']/*" />
        public virtual Response GetLargeFaceList(string largeFaceListId, bool? returnRecognitionModel, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetLargeFaceList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLargeFaceListRequest(largeFaceListId, returnRecognitionModel, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update information of a large face list, including name and userData.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdateLargeFaceListAsync(string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> UpdateLargeFaceListAsync(string largeFaceListId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdateLargeFaceList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateLargeFaceListRequest(largeFaceListId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update information of a large face list, including name and userData.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdateLargeFaceList(string,RequestContent,RequestContext)']/*" />
        public virtual Response UpdateLargeFaceList(string largeFaceListId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdateLargeFaceList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateLargeFaceListRequest(largeFaceListId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> List large face lists' information of largeFaceListId, name, userData and recognitionModel. </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks>
        /// To get face information inside largeFaceList use LargeFaceList Face - Get.
        ///
        /// Large face lists are stored in alphabetical order of largeFaceListId.
        ///
        /// * "start" parameter (string, optional) is a id value that returned entries have larger ids by string comparison. "start" set to empty to indicate return from the first item.
        /// * "top" parameter (int, optional) specifies the number of entries to return. A maximal of 1000 entries can be returned in one call. To fetch more, you can specify "start" with the last returned entry's personId of the current call.
        ///
        /// &gt; [!TIP]
        /// &gt; For example, total 5 items with their id: "itemId1", ..., "itemId5".
        /// &gt; * "start=&amp;top=" will return all 5 items.
        /// &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargeFaceListsAsync(string,int?,bool?,CancellationToken)']/*" />
        public virtual async Task<Response<IReadOnlyList<LargeFaceList>>> GetLargeFaceListsAsync(string start = null, int? top = null, bool? returnRecognitionModel = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetLargeFaceListsAsync(start, top, returnRecognitionModel, context).ConfigureAwait(false);
            IReadOnlyList<LargeFaceList> value = default;
            using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
            List<LargeFaceList> array = new List<LargeFaceList>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(LargeFaceList.DeserializeLargeFaceList(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary> List large face lists' information of largeFaceListId, name, userData and recognitionModel. </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks>
        /// To get face information inside largeFaceList use LargeFaceList Face - Get.
        ///
        /// Large face lists are stored in alphabetical order of largeFaceListId.
        ///
        /// * "start" parameter (string, optional) is a id value that returned entries have larger ids by string comparison. "start" set to empty to indicate return from the first item.
        /// * "top" parameter (int, optional) specifies the number of entries to return. A maximal of 1000 entries can be returned in one call. To fetch more, you can specify "start" with the last returned entry's personId of the current call.
        ///
        /// &gt; [!TIP]
        /// &gt; For example, total 5 items with their id: "itemId1", ..., "itemId5".
        /// &gt; * "start=&amp;top=" will return all 5 items.
        /// &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargeFaceLists(string,int?,bool?,CancellationToken)']/*" />
        public virtual Response<IReadOnlyList<LargeFaceList>> GetLargeFaceLists(string start = null, int? top = null, bool? returnRecognitionModel = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetLargeFaceLists(start, top, returnRecognitionModel, context);
            IReadOnlyList<LargeFaceList> value = default;
            using var document = JsonDocument.Parse(response.ContentStream);
            List<LargeFaceList> array = new List<LargeFaceList>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(LargeFaceList.DeserializeLargeFaceList(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// [Protocol Method] List large face lists' information of largeFaceListId, name, userData and recognitionModel.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLargeFaceListsAsync(string,int?,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargeFaceListsAsync(string,int?,bool?,RequestContext)']/*" />
        public virtual async Task<Response> GetLargeFaceListsAsync(string start, int? top, bool? returnRecognitionModel, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetLargeFaceLists");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLargeFaceListsRequest(start, top, returnRecognitionModel, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] List large face lists' information of largeFaceListId, name, userData and recognitionModel.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLargeFaceLists(string,int?,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargeFaceLists(string,int?,bool?,RequestContext)']/*" />
        public virtual Response GetLargeFaceLists(string start, int? top, bool? returnRecognitionModel, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetLargeFaceLists");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLargeFaceListsRequest(start, top, returnRecognitionModel, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// To check the large face list training status completed or still ongoing. LargeFaceList Training is an asynchronous operation triggered by Train Large Face List.
        ///
        /// Training time depends on the number of face entries in a large face list. It could be in seconds, or up to half an hour for 1,000,000 faces.
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargeFaceListTrainingStatusAsync(string,CancellationToken)']/*" />
        public virtual async Task<Response<FaceCollectionTrainingStatus>> GetLargeFaceListTrainingStatusAsync(string largeFaceListId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetLargeFaceListTrainingStatusAsync(largeFaceListId, context).ConfigureAwait(false);
            return Response.FromValue(FaceCollectionTrainingStatus.FromResponse(response), response);
        }

        /// <summary>
        /// To check the large face list training status completed or still ongoing. LargeFaceList Training is an asynchronous operation triggered by Train Large Face List.
        ///
        /// Training time depends on the number of face entries in a large face list. It could be in seconds, or up to half an hour for 1,000,000 faces.
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargeFaceListTrainingStatus(string,CancellationToken)']/*" />
        public virtual Response<FaceCollectionTrainingStatus> GetLargeFaceListTrainingStatus(string largeFaceListId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetLargeFaceListTrainingStatus(largeFaceListId, context);
            return Response.FromValue(FaceCollectionTrainingStatus.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] To check the large face list training status completed or still ongoing. LargeFaceList Training is an asynchronous operation triggered by Train Large Face List.
        ///
        /// Training time depends on the number of face entries in a large face list. It could be in seconds, or up to half an hour for 1,000,000 faces.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLargeFaceListTrainingStatusAsync(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargeFaceListTrainingStatusAsync(string,RequestContext)']/*" />
        public virtual async Task<Response> GetLargeFaceListTrainingStatusAsync(string largeFaceListId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetLargeFaceListTrainingStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLargeFaceListTrainingStatusRequest(largeFaceListId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] To check the large face list training status completed or still ongoing. LargeFaceList Training is an asynchronous operation triggered by Train Large Face List.
        ///
        /// Training time depends on the number of face entries in a large face list. It could be in seconds, or up to half an hour for 1,000,000 faces.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLargeFaceListTrainingStatus(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargeFaceListTrainingStatus(string,RequestContext)']/*" />
        public virtual Response GetLargeFaceListTrainingStatus(string largeFaceListId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetLargeFaceListTrainingStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLargeFaceListTrainingStatusRequest(largeFaceListId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Add a face to a specified large face list, up to 1,000,000 faces. </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="url"> URL of input image. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="url"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// To deal with an image containing multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature(s) will be stored on server until LargeFaceList - Delete Face or LargeFaceList - Delete is called.
        ///
        /// Note persistedFaceId is different from faceId generated by Face - Detect.
        ///
        /// * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        /// * Each person entry can hold up to 248 faces.
        /// * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
        /// * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from Face - Detect, there's no guarantee to detect and add the face successfully.
        /// * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
        /// * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
        /// * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to https://learn.microsoft.com/en-us/azure/ai-services/computer-vision/how-to/specify-detection-model
        ///   * 'detection_01': The default detection model for PersonDirectory Person - Add Face. Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected.
        ///   * 'detection_02': Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces.
        ///   * 'detection_03': Detection model released in 2021 February with improved accuracy especially on small faces.
        ///
        /// &gt; [!NOTE]
        /// &gt; * Free-tier subscription quota: 1,000 faces per large face list.
        /// &gt; * S0-tier subscription quota: 1,000,000 faces per large face list.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddLargeFaceListFaceFromUrlAsync(string,Uri,string,FaceDetectionModel?,string,CancellationToken)']/*" />
        public virtual async Task<Response<AddFaceResult>> AddLargeFaceListFaceFromUrlAsync(string largeFaceListId, Uri url, string targetFace = null, FaceDetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));
            Argument.AssertNotNull(url, nameof(url));

            RequestContext context = FromCancellationToken(cancellationToken);
            AddLargeFaceListFaceFromUrlRequest addLargeFaceListFaceFromUrlRequest = new AddLargeFaceListFaceFromUrlRequest(url);
            Response response = await AddLargeFaceListFaceFromUrlAsync(largeFaceListId, addLargeFaceListFaceFromUrlRequest.ToRequestContent(), targetFace, detectionModel?.ToString(), userData, context).ConfigureAwait(false);
            return Response.FromValue(AddFaceResult.FromResponse(response), response);
        }

        /// <summary> Add a face to a specified large face list, up to 1,000,000 faces. </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="url"> URL of input image. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="url"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// To deal with an image containing multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature(s) will be stored on server until LargeFaceList - Delete Face or LargeFaceList - Delete is called.
        ///
        /// Note persistedFaceId is different from faceId generated by Face - Detect.
        ///
        /// * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        /// * Each person entry can hold up to 248 faces.
        /// * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
        /// * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from Face - Detect, there's no guarantee to detect and add the face successfully.
        /// * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
        /// * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
        /// * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to https://learn.microsoft.com/en-us/azure/ai-services/computer-vision/how-to/specify-detection-model
        ///   * 'detection_01': The default detection model for PersonDirectory Person - Add Face. Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected.
        ///   * 'detection_02': Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces.
        ///   * 'detection_03': Detection model released in 2021 February with improved accuracy especially on small faces.
        ///
        /// &gt; [!NOTE]
        /// &gt; * Free-tier subscription quota: 1,000 faces per large face list.
        /// &gt; * S0-tier subscription quota: 1,000,000 faces per large face list.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddLargeFaceListFaceFromUrl(string,Uri,string,FaceDetectionModel?,string,CancellationToken)']/*" />
        public virtual Response<AddFaceResult> AddLargeFaceListFaceFromUrl(string largeFaceListId, Uri url, string targetFace = null, FaceDetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));
            Argument.AssertNotNull(url, nameof(url));

            RequestContext context = FromCancellationToken(cancellationToken);
            AddLargeFaceListFaceFromUrlRequest addLargeFaceListFaceFromUrlRequest = new AddLargeFaceListFaceFromUrlRequest(url);
            Response response = AddLargeFaceListFaceFromUrl(largeFaceListId, addLargeFaceListFaceFromUrlRequest.ToRequestContent(), targetFace, detectionModel?.ToString(), userData, context);
            return Response.FromValue(AddFaceResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Add a face to a specified large face list, up to 1,000,000 faces.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddLargeFaceListFaceFromUrlAsync(string,Uri,string,FaceDetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddLargeFaceListFaceFromUrlAsync(string,RequestContent,string,string,string,RequestContext)']/*" />
        public virtual async Task<Response> AddLargeFaceListFaceFromUrlAsync(string largeFaceListId, RequestContent content, string targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.AddLargeFaceListFaceFromUrl");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddLargeFaceListFaceFromUrlRequest(largeFaceListId, content, targetFace, detectionModel, userData, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Add a face to a specified large face list, up to 1,000,000 faces.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddLargeFaceListFaceFromUrl(string,Uri,string,FaceDetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddLargeFaceListFaceFromUrl(string,RequestContent,string,string,string,RequestContext)']/*" />
        public virtual Response AddLargeFaceListFaceFromUrl(string largeFaceListId, RequestContent content, string targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.AddLargeFaceListFaceFromUrl");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddLargeFaceListFaceFromUrlRequest(largeFaceListId, content, targetFace, detectionModel, userData, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Add a face to a specified large face list, up to 1,000,000 faces. </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="imageContent"> The image to be analyzed. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="imageContent"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// To deal with an image containing multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature(s) will be stored on server until LargeFaceList - Delete Face or LargeFaceList - Delete is called.
        ///
        /// Note persistedFaceId is different from faceId generated by Face - Detect.
        ///
        /// * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        /// * Each person entry can hold up to 248 faces.
        /// * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
        /// * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from Face - Detect, there's no guarantee to detect and add the face successfully.
        /// * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
        /// * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
        /// * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to https://learn.microsoft.com/en-us/azure/ai-services/computer-vision/how-to/specify-detection-model
        ///   * 'detection_01': The default detection model for PersonDirectory Person - Add Face. Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected.
        ///   * 'detection_02': Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces.
        ///   * 'detection_03': Detection model released in 2021 February with improved accuracy especially on small faces.
        ///
        /// &gt; [!NOTE]
        /// &gt; * Free-tier subscription quota: 1,000 faces per large face list.
        /// &gt; * S0-tier subscription quota: 1,000,000 faces per large face list.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddLargeFaceListFaceAsync(string,BinaryData,string,FaceDetectionModel?,string,CancellationToken)']/*" />
        public virtual async Task<Response<AddFaceResult>> AddLargeFaceListFaceAsync(string largeFaceListId, BinaryData imageContent, string targetFace = null, FaceDetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));
            Argument.AssertNotNull(imageContent, nameof(imageContent));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = imageContent;
            Response response = await AddLargeFaceListFaceAsync(largeFaceListId, content, targetFace, detectionModel?.ToString(), userData, context).ConfigureAwait(false);
            return Response.FromValue(AddFaceResult.FromResponse(response), response);
        }

        /// <summary> Add a face to a specified large face list, up to 1,000,000 faces. </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="imageContent"> The image to be analyzed. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="imageContent"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// To deal with an image containing multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature(s) will be stored on server until LargeFaceList - Delete Face or LargeFaceList - Delete is called.
        ///
        /// Note persistedFaceId is different from faceId generated by Face - Detect.
        ///
        /// * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        /// * Each person entry can hold up to 248 faces.
        /// * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
        /// * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from Face - Detect, there's no guarantee to detect and add the face successfully.
        /// * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
        /// * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
        /// * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to https://learn.microsoft.com/en-us/azure/ai-services/computer-vision/how-to/specify-detection-model
        ///   * 'detection_01': The default detection model for PersonDirectory Person - Add Face. Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected.
        ///   * 'detection_02': Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces.
        ///   * 'detection_03': Detection model released in 2021 February with improved accuracy especially on small faces.
        ///
        /// &gt; [!NOTE]
        /// &gt; * Free-tier subscription quota: 1,000 faces per large face list.
        /// &gt; * S0-tier subscription quota: 1,000,000 faces per large face list.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddLargeFaceListFace(string,BinaryData,string,FaceDetectionModel?,string,CancellationToken)']/*" />
        public virtual Response<AddFaceResult> AddLargeFaceListFace(string largeFaceListId, BinaryData imageContent, string targetFace = null, FaceDetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));
            Argument.AssertNotNull(imageContent, nameof(imageContent));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = imageContent;
            Response response = AddLargeFaceListFace(largeFaceListId, content, targetFace, detectionModel?.ToString(), userData, context);
            return Response.FromValue(AddFaceResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Add a face to a specified large face list, up to 1,000,000 faces.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddLargeFaceListFaceAsync(string,BinaryData,string,FaceDetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddLargeFaceListFaceAsync(string,RequestContent,string,string,string,RequestContext)']/*" />
        public virtual async Task<Response> AddLargeFaceListFaceAsync(string largeFaceListId, RequestContent content, string targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.AddLargeFaceListFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddLargeFaceListFaceRequest(largeFaceListId, content, targetFace, detectionModel, userData, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Add a face to a specified large face list, up to 1,000,000 faces.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddLargeFaceListFace(string,BinaryData,string,FaceDetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddLargeFaceListFace(string,RequestContent,string,string,string,RequestContext)']/*" />
        public virtual Response AddLargeFaceListFace(string largeFaceListId, RequestContent content, string targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.AddLargeFaceListFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddLargeFaceListFaceRequest(largeFaceListId, content, targetFace, detectionModel, userData, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete a face from a large face list by specified largeFaceListId and persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="persistedFaceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeleteLargeFaceListFaceAsync(string,string,RequestContext)']/*" />
        public virtual async Task<Response> DeleteLargeFaceListFaceAsync(string largeFaceListId, string persistedFaceId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));
            Argument.AssertNotNullOrEmpty(persistedFaceId, nameof(persistedFaceId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeleteLargeFaceListFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteLargeFaceListFaceRequest(largeFaceListId, persistedFaceId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete a face from a large face list by specified largeFaceListId and persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="persistedFaceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeleteLargeFaceListFace(string,string,RequestContext)']/*" />
        public virtual Response DeleteLargeFaceListFace(string largeFaceListId, string persistedFaceId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));
            Argument.AssertNotNullOrEmpty(persistedFaceId, nameof(persistedFaceId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeleteLargeFaceListFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteLargeFaceListFaceRequest(largeFaceListId, persistedFaceId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieve persisted face in large face list by largeFaceListId and persistedFaceId. </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="persistedFaceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargeFaceListFaceAsync(string,string,CancellationToken)']/*" />
        public virtual async Task<Response<LargeFaceListFace>> GetLargeFaceListFaceAsync(string largeFaceListId, string persistedFaceId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));
            Argument.AssertNotNullOrEmpty(persistedFaceId, nameof(persistedFaceId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetLargeFaceListFaceAsync(largeFaceListId, persistedFaceId, context).ConfigureAwait(false);
            return Response.FromValue(LargeFaceListFace.FromResponse(response), response);
        }

        /// <summary> Retrieve persisted face in large face list by largeFaceListId and persistedFaceId. </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="persistedFaceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargeFaceListFace(string,string,CancellationToken)']/*" />
        public virtual Response<LargeFaceListFace> GetLargeFaceListFace(string largeFaceListId, string persistedFaceId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));
            Argument.AssertNotNullOrEmpty(persistedFaceId, nameof(persistedFaceId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetLargeFaceListFace(largeFaceListId, persistedFaceId, context);
            return Response.FromValue(LargeFaceListFace.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Retrieve persisted face in large face list by largeFaceListId and persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLargeFaceListFaceAsync(string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="persistedFaceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargeFaceListFaceAsync(string,string,RequestContext)']/*" />
        public virtual async Task<Response> GetLargeFaceListFaceAsync(string largeFaceListId, string persistedFaceId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));
            Argument.AssertNotNullOrEmpty(persistedFaceId, nameof(persistedFaceId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetLargeFaceListFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLargeFaceListFaceRequest(largeFaceListId, persistedFaceId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Retrieve persisted face in large face list by largeFaceListId and persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLargeFaceListFace(string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="persistedFaceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargeFaceListFace(string,string,RequestContext)']/*" />
        public virtual Response GetLargeFaceListFace(string largeFaceListId, string persistedFaceId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));
            Argument.AssertNotNullOrEmpty(persistedFaceId, nameof(persistedFaceId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetLargeFaceListFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLargeFaceListFaceRequest(largeFaceListId, persistedFaceId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update a specified face's userData field in a large face list by its persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/>, <paramref name="persistedFaceId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdateLargeFaceListFaceAsync(string,string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> UpdateLargeFaceListFaceAsync(string largeFaceListId, string persistedFaceId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));
            Argument.AssertNotNullOrEmpty(persistedFaceId, nameof(persistedFaceId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdateLargeFaceListFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateLargeFaceListFaceRequest(largeFaceListId, persistedFaceId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update a specified face's userData field in a large face list by its persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/>, <paramref name="persistedFaceId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdateLargeFaceListFace(string,string,RequestContent,RequestContext)']/*" />
        public virtual Response UpdateLargeFaceListFace(string largeFaceListId, string persistedFaceId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));
            Argument.AssertNotNullOrEmpty(persistedFaceId, nameof(persistedFaceId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdateLargeFaceListFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateLargeFaceListFaceRequest(largeFaceListId, persistedFaceId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> List faces' persistedFaceId and userData in a specified large face list. </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Faces are stored in alphabetical order of persistedFaceId created in LargeFaceList Face - Add.
        ///
        /// * "start" parameter (string, optional) is a id value that returned entries have larger ids by string comparison. "start" set to empty to indicate return from the first item.
        /// * "top" parameter (int, optional) specifies the number of entries to return. A maximal of 1000 entries can be returned in one call. To fetch more, you can specify "start" with the last returned entry's personId of the current call.
        ///
        /// &gt; [!TIP]
        /// &gt; For example, total 5 items with their id: "itemId1", ..., "itemId5".
        /// &gt; * "start=&amp;top=" will return all 5 items.
        /// &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargeFaceListFacesAsync(string,string,int?,CancellationToken)']/*" />
        public virtual async Task<Response<IReadOnlyList<LargeFaceListFace>>> GetLargeFaceListFacesAsync(string largeFaceListId, string start = null, int? top = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetLargeFaceListFacesAsync(largeFaceListId, start, top, context).ConfigureAwait(false);
            IReadOnlyList<LargeFaceListFace> value = default;
            using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
            List<LargeFaceListFace> array = new List<LargeFaceListFace>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(LargeFaceListFace.DeserializeLargeFaceListFace(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary> List faces' persistedFaceId and userData in a specified large face list. </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Faces are stored in alphabetical order of persistedFaceId created in LargeFaceList Face - Add.
        ///
        /// * "start" parameter (string, optional) is a id value that returned entries have larger ids by string comparison. "start" set to empty to indicate return from the first item.
        /// * "top" parameter (int, optional) specifies the number of entries to return. A maximal of 1000 entries can be returned in one call. To fetch more, you can specify "start" with the last returned entry's personId of the current call.
        ///
        /// &gt; [!TIP]
        /// &gt; For example, total 5 items with their id: "itemId1", ..., "itemId5".
        /// &gt; * "start=&amp;top=" will return all 5 items.
        /// &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargeFaceListFaces(string,string,int?,CancellationToken)']/*" />
        public virtual Response<IReadOnlyList<LargeFaceListFace>> GetLargeFaceListFaces(string largeFaceListId, string start = null, int? top = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetLargeFaceListFaces(largeFaceListId, start, top, context);
            IReadOnlyList<LargeFaceListFace> value = default;
            using var document = JsonDocument.Parse(response.ContentStream);
            List<LargeFaceListFace> array = new List<LargeFaceListFace>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(LargeFaceListFace.DeserializeLargeFaceListFace(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// [Protocol Method] List faces' persistedFaceId and userData in a specified large face list.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLargeFaceListFacesAsync(string,string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargeFaceListFacesAsync(string,string,int?,RequestContext)']/*" />
        public virtual async Task<Response> GetLargeFaceListFacesAsync(string largeFaceListId, string start, int? top, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetLargeFaceListFaces");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLargeFaceListFacesRequest(largeFaceListId, start, top, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] List faces' persistedFaceId and userData in a specified large face list.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLargeFaceListFaces(string,string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargeFaceListFaces(string,string,int?,RequestContext)']/*" />
        public virtual Response GetLargeFaceListFaces(string largeFaceListId, string start, int? top, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetLargeFaceListFaces");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLargeFaceListFacesRequest(largeFaceListId, start, top, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create a new person group with specified personGroupId, name, user-provided userData and recognitionModel. </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="resource"> The resource instance. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> or <paramref name="resource"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// A person group is a container holding the uploaded person data, including face recognition features.
        ///
        /// After creation, use PersonGroup Person - Create to add persons into the group, and then call PersonGroup - Train to get this group ready for Face - Identify.
        ///
        /// No image will be stored. Only the person's extracted face feature(s) and userData will be stored on server until PersonGroup Person - Delete or PersonGroup - Delete is called.
        ///
        /// 'recognitionModel' should be specified to associate with this person group. The default value for 'recognitionModel' is 'recognition_01', if the latest model needed, please explicitly specify the model you need in this parameter. New faces that are added to an existing person group will use the recognition model that's already associated with the collection. Existing face feature(s) in a person group can't be updated to features extracted by another version of recognition model.
        ///
        /// &gt; [!NOTE]
        /// &gt; * Free-tier subscription quota: 1,000 person groups. Each holds up to 1,000 persons.
        /// &gt; * S0-tier subscription quota: 1,000,000 person groups. Each holds up to 10,000 persons.
        /// &gt; * to handle larger scale face identification problem, please consider using LargePersonGroup.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreatePersonGroupAsync(string,PersonGroup,CancellationToken)']/*" />
        public virtual async Task<Response> CreatePersonGroupAsync(string personGroupId, PersonGroup resource, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNull(resource, nameof(resource));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = resource.ToRequestContent();
            Response response = await CreatePersonGroupAsync(personGroupId, content, context).ConfigureAwait(false);
            return response;
        }

        /// <summary> Create a new person group with specified personGroupId, name, user-provided userData and recognitionModel. </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="resource"> The resource instance. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> or <paramref name="resource"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// A person group is a container holding the uploaded person data, including face recognition features.
        ///
        /// After creation, use PersonGroup Person - Create to add persons into the group, and then call PersonGroup - Train to get this group ready for Face - Identify.
        ///
        /// No image will be stored. Only the person's extracted face feature(s) and userData will be stored on server until PersonGroup Person - Delete or PersonGroup - Delete is called.
        ///
        /// 'recognitionModel' should be specified to associate with this person group. The default value for 'recognitionModel' is 'recognition_01', if the latest model needed, please explicitly specify the model you need in this parameter. New faces that are added to an existing person group will use the recognition model that's already associated with the collection. Existing face feature(s) in a person group can't be updated to features extracted by another version of recognition model.
        ///
        /// &gt; [!NOTE]
        /// &gt; * Free-tier subscription quota: 1,000 person groups. Each holds up to 1,000 persons.
        /// &gt; * S0-tier subscription quota: 1,000,000 person groups. Each holds up to 10,000 persons.
        /// &gt; * to handle larger scale face identification problem, please consider using LargePersonGroup.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreatePersonGroup(string,PersonGroup,CancellationToken)']/*" />
        public virtual Response CreatePersonGroup(string personGroupId, PersonGroup resource, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNull(resource, nameof(resource));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = resource.ToRequestContent();
            Response response = CreatePersonGroup(personGroupId, content, context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] Create a new person group with specified personGroupId, name, user-provided userData and recognitionModel.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreatePersonGroupAsync(string,PersonGroup,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreatePersonGroupAsync(string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> CreatePersonGroupAsync(string personGroupId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.CreatePersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreatePersonGroupRequest(personGroupId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Create a new person group with specified personGroupId, name, user-provided userData and recognitionModel.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreatePersonGroup(string,PersonGroup,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreatePersonGroup(string,RequestContent,RequestContext)']/*" />
        public virtual Response CreatePersonGroup(string personGroupId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.CreatePersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreatePersonGroupRequest(personGroupId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete an existing person group with specified personGroupId. Persisted data in this person group will be deleted.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeletePersonGroupAsync(string,RequestContext)']/*" />
        public virtual async Task<Response> DeletePersonGroupAsync(string personGroupId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeletePersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeletePersonGroupRequest(personGroupId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete an existing person group with specified personGroupId. Persisted data in this person group will be deleted.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeletePersonGroup(string,RequestContext)']/*" />
        public virtual Response DeletePersonGroup(string personGroupId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeletePersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeletePersonGroupRequest(personGroupId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieve person group name, userData and recognitionModel. To get person information under this personGroup, use PersonGroup Person - List. </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroupAsync(string,bool?,CancellationToken)']/*" />
        public virtual async Task<Response<PersonGroup>> GetPersonGroupAsync(string personGroupId, bool? returnRecognitionModel = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetPersonGroupAsync(personGroupId, returnRecognitionModel, context).ConfigureAwait(false);
            return Response.FromValue(PersonGroup.FromResponse(response), response);
        }

        /// <summary> Retrieve person group name, userData and recognitionModel. To get person information under this personGroup, use PersonGroup Person - List. </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroup(string,bool?,CancellationToken)']/*" />
        public virtual Response<PersonGroup> GetPersonGroup(string personGroupId, bool? returnRecognitionModel = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetPersonGroup(personGroupId, returnRecognitionModel, context);
            return Response.FromValue(PersonGroup.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Retrieve person group name, userData and recognitionModel. To get person information under this personGroup, use PersonGroup Person - List.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPersonGroupAsync(string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroupAsync(string,bool?,RequestContext)']/*" />
        public virtual async Task<Response> GetPersonGroupAsync(string personGroupId, bool? returnRecognitionModel, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetPersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPersonGroupRequest(personGroupId, returnRecognitionModel, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Retrieve person group name, userData and recognitionModel. To get person information under this personGroup, use PersonGroup Person - List.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPersonGroup(string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroup(string,bool?,RequestContext)']/*" />
        public virtual Response GetPersonGroup(string personGroupId, bool? returnRecognitionModel, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetPersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPersonGroupRequest(personGroupId, returnRecognitionModel, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update an existing person group's name and userData. The properties keep unchanged if they are not in request body.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdatePersonGroupAsync(string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> UpdatePersonGroupAsync(string personGroupId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdatePersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdatePersonGroupRequest(personGroupId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update an existing person group's name and userData. The properties keep unchanged if they are not in request body.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdatePersonGroup(string,RequestContent,RequestContext)']/*" />
        public virtual Response UpdatePersonGroup(string personGroupId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdatePersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdatePersonGroupRequest(personGroupId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> List person groups' personGroupId, name, userData and recognitionModel. </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks>
        /// *
        ///   * Person groups are stored in alphabetical order of personGroupId.
        /// * "start" parameter (string, optional) is a id value that returned entries have larger ids by string comparison. "start" set to empty to indicate return from the first item.
        /// * "top" parameter (int, optional) specifies the number of entries to return. A maximal of 1000 entries can be returned in one call. To fetch more, you can specify "start" with the last returned entry's personId of the current call.
        ///
        /// &gt; [!TIP]
        /// &gt; For example, total 5 items with their id: "itemId1", ..., "itemId5".
        /// &gt; * "start=&amp;top=" will return all 5 items.
        /// &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroupsAsync(string,int?,bool?,CancellationToken)']/*" />
        public virtual async Task<Response<IReadOnlyList<PersonGroup>>> GetPersonGroupsAsync(string start = null, int? top = null, bool? returnRecognitionModel = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetPersonGroupsAsync(start, top, returnRecognitionModel, context).ConfigureAwait(false);
            IReadOnlyList<PersonGroup> value = default;
            using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
            List<PersonGroup> array = new List<PersonGroup>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(PersonGroup.DeserializePersonGroup(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary> List person groups' personGroupId, name, userData and recognitionModel. </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks>
        /// *
        ///   * Person groups are stored in alphabetical order of personGroupId.
        /// * "start" parameter (string, optional) is a id value that returned entries have larger ids by string comparison. "start" set to empty to indicate return from the first item.
        /// * "top" parameter (int, optional) specifies the number of entries to return. A maximal of 1000 entries can be returned in one call. To fetch more, you can specify "start" with the last returned entry's personId of the current call.
        ///
        /// &gt; [!TIP]
        /// &gt; For example, total 5 items with their id: "itemId1", ..., "itemId5".
        /// &gt; * "start=&amp;top=" will return all 5 items.
        /// &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroups(string,int?,bool?,CancellationToken)']/*" />
        public virtual Response<IReadOnlyList<PersonGroup>> GetPersonGroups(string start = null, int? top = null, bool? returnRecognitionModel = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetPersonGroups(start, top, returnRecognitionModel, context);
            IReadOnlyList<PersonGroup> value = default;
            using var document = JsonDocument.Parse(response.ContentStream);
            List<PersonGroup> array = new List<PersonGroup>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(PersonGroup.DeserializePersonGroup(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// [Protocol Method] List person groups' personGroupId, name, userData and recognitionModel.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPersonGroupsAsync(string,int?,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroupsAsync(string,int?,bool?,RequestContext)']/*" />
        public virtual async Task<Response> GetPersonGroupsAsync(string start, int? top, bool? returnRecognitionModel, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetPersonGroups");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPersonGroupsRequest(start, top, returnRecognitionModel, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] List person groups' personGroupId, name, userData and recognitionModel.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPersonGroups(string,int?,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroups(string,int?,bool?,RequestContext)']/*" />
        public virtual Response GetPersonGroups(string start, int? top, bool? returnRecognitionModel, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetPersonGroups");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPersonGroupsRequest(start, top, returnRecognitionModel, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> To check person group training status completed or still ongoing. PersonGroup Training is an asynchronous operation triggered by PersonGroup - Train API. </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroupTrainingStatusAsync(string,CancellationToken)']/*" />
        public virtual async Task<Response<FaceCollectionTrainingStatus>> GetPersonGroupTrainingStatusAsync(string personGroupId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetPersonGroupTrainingStatusAsync(personGroupId, context).ConfigureAwait(false);
            return Response.FromValue(FaceCollectionTrainingStatus.FromResponse(response), response);
        }

        /// <summary> To check person group training status completed or still ongoing. PersonGroup Training is an asynchronous operation triggered by PersonGroup - Train API. </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroupTrainingStatus(string,CancellationToken)']/*" />
        public virtual Response<FaceCollectionTrainingStatus> GetPersonGroupTrainingStatus(string personGroupId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetPersonGroupTrainingStatus(personGroupId, context);
            return Response.FromValue(FaceCollectionTrainingStatus.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] To check person group training status completed or still ongoing. PersonGroup Training is an asynchronous operation triggered by PersonGroup - Train API.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPersonGroupTrainingStatusAsync(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroupTrainingStatusAsync(string,RequestContext)']/*" />
        public virtual async Task<Response> GetPersonGroupTrainingStatusAsync(string personGroupId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetPersonGroupTrainingStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPersonGroupTrainingStatusRequest(personGroupId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] To check person group training status completed or still ongoing. PersonGroup Training is an asynchronous operation triggered by PersonGroup - Train API.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPersonGroupTrainingStatus(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroupTrainingStatus(string,RequestContext)']/*" />
        public virtual Response GetPersonGroupTrainingStatus(string personGroupId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetPersonGroupTrainingStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPersonGroupTrainingStatusRequest(personGroupId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create a new person in a specified person group. To add face to this person, please call PersonGroup PersonFace - Add. </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="userDefinedFields"> Model for object name and user data. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> or <paramref name="userDefinedFields"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// &gt; [!NOTE]
        /// &gt; * Free-tier subscription quota:
        /// &gt;   * 1,000 persons in all person groups.
        /// &gt; * S0-tier subscription quota:
        /// &gt;   * 10,000 persons per person group.
        /// &gt;   * 1,000,000 person groups.
        /// &gt;   * 100,000,000 persons in all person groups.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreatePersonGroupPersonAsync(string,UserDefinedFields,CancellationToken)']/*" />
        public virtual async Task<Response<CreatePersonResult>> CreatePersonGroupPersonAsync(string personGroupId, UserDefinedFields userDefinedFields, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNull(userDefinedFields, nameof(userDefinedFields));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = userDefinedFields.ToRequestContent();
            Response response = await CreatePersonGroupPersonAsync(personGroupId, content, context).ConfigureAwait(false);
            return Response.FromValue(CreatePersonResult.FromResponse(response), response);
        }

        /// <summary> Create a new person in a specified person group. To add face to this person, please call PersonGroup PersonFace - Add. </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="userDefinedFields"> Model for object name and user data. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> or <paramref name="userDefinedFields"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// &gt; [!NOTE]
        /// &gt; * Free-tier subscription quota:
        /// &gt;   * 1,000 persons in all person groups.
        /// &gt; * S0-tier subscription quota:
        /// &gt;   * 10,000 persons per person group.
        /// &gt;   * 1,000,000 person groups.
        /// &gt;   * 100,000,000 persons in all person groups.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreatePersonGroupPerson(string,UserDefinedFields,CancellationToken)']/*" />
        public virtual Response<CreatePersonResult> CreatePersonGroupPerson(string personGroupId, UserDefinedFields userDefinedFields, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNull(userDefinedFields, nameof(userDefinedFields));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = userDefinedFields.ToRequestContent();
            Response response = CreatePersonGroupPerson(personGroupId, content, context);
            return Response.FromValue(CreatePersonResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Create a new person in a specified person group. To add face to this person, please call PersonGroup PersonFace - Add.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreatePersonGroupPersonAsync(string,UserDefinedFields,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreatePersonGroupPersonAsync(string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> CreatePersonGroupPersonAsync(string personGroupId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.CreatePersonGroupPerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreatePersonGroupPersonRequest(personGroupId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Create a new person in a specified person group. To add face to this person, please call PersonGroup PersonFace - Add.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreatePersonGroupPerson(string,UserDefinedFields,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreatePersonGroupPerson(string,RequestContent,RequestContext)']/*" />
        public virtual Response CreatePersonGroupPerson(string personGroupId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.CreatePersonGroupPerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreatePersonGroupPersonRequest(personGroupId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete an existing person from a person group. The persistedFaceId, userData, person name and face feature(s) in the person entry will all be deleted.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> or <paramref name="personId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> or <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeletePersonGroupPersonAsync(string,string,RequestContext)']/*" />
        public virtual async Task<Response> DeletePersonGroupPersonAsync(string personGroupId, string personId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeletePersonGroupPerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeletePersonGroupPersonRequest(personGroupId, personId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete an existing person from a person group. The persistedFaceId, userData, person name and face feature(s) in the person entry will all be deleted.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> or <paramref name="personId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> or <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeletePersonGroupPerson(string,string,RequestContext)']/*" />
        public virtual Response DeletePersonGroupPerson(string personGroupId, string personId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeletePersonGroupPerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeletePersonGroupPersonRequest(personGroupId, personId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieve a person's name and userData, and the persisted faceIds representing the registered person face feature(s). </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> or <paramref name="personId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> or <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroupPersonAsync(string,string,CancellationToken)']/*" />
        public virtual async Task<Response<PersonGroupPerson>> GetPersonGroupPersonAsync(string personGroupId, string personId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetPersonGroupPersonAsync(personGroupId, personId, context).ConfigureAwait(false);
            return Response.FromValue(PersonGroupPerson.FromResponse(response), response);
        }

        /// <summary> Retrieve a person's name and userData, and the persisted faceIds representing the registered person face feature(s). </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> or <paramref name="personId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> or <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroupPerson(string,string,CancellationToken)']/*" />
        public virtual Response<PersonGroupPerson> GetPersonGroupPerson(string personGroupId, string personId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetPersonGroupPerson(personGroupId, personId, context);
            return Response.FromValue(PersonGroupPerson.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Retrieve a person's name and userData, and the persisted faceIds representing the registered person face feature(s).
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPersonGroupPersonAsync(string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> or <paramref name="personId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> or <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroupPersonAsync(string,string,RequestContext)']/*" />
        public virtual async Task<Response> GetPersonGroupPersonAsync(string personGroupId, string personId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetPersonGroupPerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPersonGroupPersonRequest(personGroupId, personId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Retrieve a person's name and userData, and the persisted faceIds representing the registered person face feature(s).
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPersonGroupPerson(string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> or <paramref name="personId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> or <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroupPerson(string,string,RequestContext)']/*" />
        public virtual Response GetPersonGroupPerson(string personGroupId, string personId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetPersonGroupPerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPersonGroupPersonRequest(personGroupId, personId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update name or userData of a person.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/>, <paramref name="personId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> or <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdatePersonGroupPersonAsync(string,string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> UpdatePersonGroupPersonAsync(string personGroupId, string personId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdatePersonGroupPerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdatePersonGroupPersonRequest(personGroupId, personId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update name or userData of a person.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/>, <paramref name="personId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> or <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdatePersonGroupPerson(string,string,RequestContent,RequestContext)']/*" />
        public virtual Response UpdatePersonGroupPerson(string personGroupId, string personId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdatePersonGroupPerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdatePersonGroupPersonRequest(personGroupId, personId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> List all persons' information in the specified person group, including personId, name, userData and persistedFaceIds of registered person faces. </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Persons are stored in alphabetical order of personId created in PersonGroup Person - Create.
        ///
        /// * "start" parameter (string, optional) is a id value that returned entries have larger ids by string comparison. "start" set to empty to indicate return from the first item.
        /// * "top" parameter (int, optional) specifies the number of entries to return. A maximal of 1000 entries can be returned in one call. To fetch more, you can specify "start" with the last returned entry's personId of the current call.
        ///
        /// &gt; [!TIP]
        /// &gt; For example, total 5 items with their id: "itemId1", ..., "itemId5".
        /// &gt; * "start=&amp;top=" will return all 5 items.
        /// &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroupPersonsAsync(string,string,int?,CancellationToken)']/*" />
        public virtual async Task<Response<IReadOnlyList<PersonGroupPerson>>> GetPersonGroupPersonsAsync(string personGroupId, string start = null, int? top = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetPersonGroupPersonsAsync(personGroupId, start, top, context).ConfigureAwait(false);
            IReadOnlyList<PersonGroupPerson> value = default;
            using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
            List<PersonGroupPerson> array = new List<PersonGroupPerson>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(PersonGroupPerson.DeserializePersonGroupPerson(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary> List all persons' information in the specified person group, including personId, name, userData and persistedFaceIds of registered person faces. </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Persons are stored in alphabetical order of personId created in PersonGroup Person - Create.
        ///
        /// * "start" parameter (string, optional) is a id value that returned entries have larger ids by string comparison. "start" set to empty to indicate return from the first item.
        /// * "top" parameter (int, optional) specifies the number of entries to return. A maximal of 1000 entries can be returned in one call. To fetch more, you can specify "start" with the last returned entry's personId of the current call.
        ///
        /// &gt; [!TIP]
        /// &gt; For example, total 5 items with their id: "itemId1", ..., "itemId5".
        /// &gt; * "start=&amp;top=" will return all 5 items.
        /// &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroupPersons(string,string,int?,CancellationToken)']/*" />
        public virtual Response<IReadOnlyList<PersonGroupPerson>> GetPersonGroupPersons(string personGroupId, string start = null, int? top = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetPersonGroupPersons(personGroupId, start, top, context);
            IReadOnlyList<PersonGroupPerson> value = default;
            using var document = JsonDocument.Parse(response.ContentStream);
            List<PersonGroupPerson> array = new List<PersonGroupPerson>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(PersonGroupPerson.DeserializePersonGroupPerson(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// [Protocol Method] List all persons' information in the specified person group, including personId, name, userData and persistedFaceIds of registered person faces.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPersonGroupPersonsAsync(string,string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroupPersonsAsync(string,string,int?,RequestContext)']/*" />
        public virtual async Task<Response> GetPersonGroupPersonsAsync(string personGroupId, string start, int? top, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetPersonGroupPersons");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPersonGroupPersonsRequest(personGroupId, start, top, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] List all persons' information in the specified person group, including personId, name, userData and persistedFaceIds of registered person faces.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPersonGroupPersons(string,string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroupPersons(string,string,int?,RequestContext)']/*" />
        public virtual Response GetPersonGroupPersons(string personGroupId, string start, int? top, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetPersonGroupPersons");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPersonGroupPersonsRequest(personGroupId, start, top, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Add a face to a person into a person group for face identification or verification. </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="url"> URL of input image. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/>, <paramref name="personId"/> or <paramref name="url"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> or <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// To deal with an image containing multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature(s) will be stored on server until PersonGroup PersonFace - Delete, PersonGroup Person - Delete or PersonGroup - Delete is called.
        ///
        /// Note persistedFaceId is different from faceId generated by Face - Detect.
        ///
        /// * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        /// * Each person entry can hold up to 248 faces.
        /// * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
        /// * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from Face - Detect, there's no guarantee to detect and add the face successfully.
        /// * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
        /// * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
        /// * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to https://learn.microsoft.com/en-us/azure/ai-services/computer-vision/how-to/specify-detection-model
        ///   * 'detection_01': The default detection model for PersonDirectory Person - Add Face. Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected.
        ///   * 'detection_02': Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces.
        ///   * 'detection_03': Detection model released in 2021 February with improved accuracy especially on small faces.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddPersonGroupPersonFaceFromUrlAsync(string,string,Uri,string,FaceDetectionModel?,string,CancellationToken)']/*" />
        public virtual async Task<Response<AddFaceResult>> AddPersonGroupPersonFaceFromUrlAsync(string personGroupId, string personId, Uri url, string targetFace = null, FaceDetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNull(url, nameof(url));

            RequestContext context = FromCancellationToken(cancellationToken);
            AddPersonGroupPersonFaceFromUrlRequest addPersonGroupPersonFaceFromUrlRequest = new AddPersonGroupPersonFaceFromUrlRequest(url);
            Response response = await AddPersonGroupPersonFaceFromUrlAsync(personGroupId, personId, addPersonGroupPersonFaceFromUrlRequest.ToRequestContent(), targetFace, detectionModel?.ToString(), userData, context).ConfigureAwait(false);
            return Response.FromValue(AddFaceResult.FromResponse(response), response);
        }

        /// <summary> Add a face to a person into a person group for face identification or verification. </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="url"> URL of input image. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/>, <paramref name="personId"/> or <paramref name="url"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> or <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// To deal with an image containing multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature(s) will be stored on server until PersonGroup PersonFace - Delete, PersonGroup Person - Delete or PersonGroup - Delete is called.
        ///
        /// Note persistedFaceId is different from faceId generated by Face - Detect.
        ///
        /// * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        /// * Each person entry can hold up to 248 faces.
        /// * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
        /// * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from Face - Detect, there's no guarantee to detect and add the face successfully.
        /// * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
        /// * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
        /// * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to https://learn.microsoft.com/en-us/azure/ai-services/computer-vision/how-to/specify-detection-model
        ///   * 'detection_01': The default detection model for PersonDirectory Person - Add Face. Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected.
        ///   * 'detection_02': Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces.
        ///   * 'detection_03': Detection model released in 2021 February with improved accuracy especially on small faces.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddPersonGroupPersonFaceFromUrl(string,string,Uri,string,FaceDetectionModel?,string,CancellationToken)']/*" />
        public virtual Response<AddFaceResult> AddPersonGroupPersonFaceFromUrl(string personGroupId, string personId, Uri url, string targetFace = null, FaceDetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNull(url, nameof(url));

            RequestContext context = FromCancellationToken(cancellationToken);
            AddPersonGroupPersonFaceFromUrlRequest addPersonGroupPersonFaceFromUrlRequest = new AddPersonGroupPersonFaceFromUrlRequest(url);
            Response response = AddPersonGroupPersonFaceFromUrl(personGroupId, personId, addPersonGroupPersonFaceFromUrlRequest.ToRequestContent(), targetFace, detectionModel?.ToString(), userData, context);
            return Response.FromValue(AddFaceResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Add a face to a person into a person group for face identification or verification.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddPersonGroupPersonFaceFromUrlAsync(string,string,Uri,string,FaceDetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/>, <paramref name="personId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> or <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddPersonGroupPersonFaceFromUrlAsync(string,string,RequestContent,string,string,string,RequestContext)']/*" />
        public virtual async Task<Response> AddPersonGroupPersonFaceFromUrlAsync(string personGroupId, string personId, RequestContent content, string targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.AddPersonGroupPersonFaceFromUrl");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddPersonGroupPersonFaceFromUrlRequest(personGroupId, personId, content, targetFace, detectionModel, userData, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Add a face to a person into a person group for face identification or verification.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddPersonGroupPersonFaceFromUrl(string,string,Uri,string,FaceDetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/>, <paramref name="personId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> or <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddPersonGroupPersonFaceFromUrl(string,string,RequestContent,string,string,string,RequestContext)']/*" />
        public virtual Response AddPersonGroupPersonFaceFromUrl(string personGroupId, string personId, RequestContent content, string targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.AddPersonGroupPersonFaceFromUrl");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddPersonGroupPersonFaceFromUrlRequest(personGroupId, personId, content, targetFace, detectionModel, userData, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Add a face to a person into a person group for face identification or verification. </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="imageContent"> The image to be analyzed. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/>, <paramref name="personId"/> or <paramref name="imageContent"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> or <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// To deal with an image containing multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature(s) will be stored on server until PersonGroup PersonFace - Delete, PersonGroup Person - Delete or PersonGroup - Delete is called.
        ///
        /// Note persistedFaceId is different from faceId generated by Face - Detect.
        ///
        /// * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        /// * Each person entry can hold up to 248 faces.
        /// * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
        /// * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from Face - Detect, there's no guarantee to detect and add the face successfully.
        /// * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
        /// * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
        /// * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to https://learn.microsoft.com/en-us/azure/ai-services/computer-vision/how-to/specify-detection-model
        ///   * 'detection_01': The default detection model for PersonDirectory Person - Add Face. Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected.
        ///   * 'detection_02': Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces.
        ///   * 'detection_03': Detection model released in 2021 February with improved accuracy especially on small faces.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddPersonGroupPersonFaceAsync(string,string,BinaryData,string,FaceDetectionModel?,string,CancellationToken)']/*" />
        public virtual async Task<Response<AddFaceResult>> AddPersonGroupPersonFaceAsync(string personGroupId, string personId, BinaryData imageContent, string targetFace = null, FaceDetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNull(imageContent, nameof(imageContent));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = imageContent;
            Response response = await AddPersonGroupPersonFaceAsync(personGroupId, personId, content, targetFace, detectionModel?.ToString(), userData, context).ConfigureAwait(false);
            return Response.FromValue(AddFaceResult.FromResponse(response), response);
        }

        /// <summary> Add a face to a person into a person group for face identification or verification. </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="imageContent"> The image to be analyzed. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/>, <paramref name="personId"/> or <paramref name="imageContent"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> or <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// To deal with an image containing multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature(s) will be stored on server until PersonGroup PersonFace - Delete, PersonGroup Person - Delete or PersonGroup - Delete is called.
        ///
        /// Note persistedFaceId is different from faceId generated by Face - Detect.
        ///
        /// * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        /// * Each person entry can hold up to 248 faces.
        /// * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
        /// * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from Face - Detect, there's no guarantee to detect and add the face successfully.
        /// * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
        /// * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
        /// * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to https://learn.microsoft.com/en-us/azure/ai-services/computer-vision/how-to/specify-detection-model
        ///   * 'detection_01': The default detection model for PersonDirectory Person - Add Face. Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected.
        ///   * 'detection_02': Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces.
        ///   * 'detection_03': Detection model released in 2021 February with improved accuracy especially on small faces.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddPersonGroupPersonFace(string,string,BinaryData,string,FaceDetectionModel?,string,CancellationToken)']/*" />
        public virtual Response<AddFaceResult> AddPersonGroupPersonFace(string personGroupId, string personId, BinaryData imageContent, string targetFace = null, FaceDetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNull(imageContent, nameof(imageContent));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = imageContent;
            Response response = AddPersonGroupPersonFace(personGroupId, personId, content, targetFace, detectionModel?.ToString(), userData, context);
            return Response.FromValue(AddFaceResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Add a face to a person into a person group for face identification or verification.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddPersonGroupPersonFaceAsync(string,string,BinaryData,string,FaceDetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/>, <paramref name="personId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> or <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddPersonGroupPersonFaceAsync(string,string,RequestContent,string,string,string,RequestContext)']/*" />
        public virtual async Task<Response> AddPersonGroupPersonFaceAsync(string personGroupId, string personId, RequestContent content, string targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.AddPersonGroupPersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddPersonGroupPersonFaceRequest(personGroupId, personId, content, targetFace, detectionModel, userData, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Add a face to a person into a person group for face identification or verification.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddPersonGroupPersonFace(string,string,BinaryData,string,FaceDetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/>, <paramref name="personId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> or <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddPersonGroupPersonFace(string,string,RequestContent,string,string,string,RequestContext)']/*" />
        public virtual Response AddPersonGroupPersonFace(string personGroupId, string personId, RequestContent content, string targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.AddPersonGroupPersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddPersonGroupPersonFaceRequest(personGroupId, personId, content, targetFace, detectionModel, userData, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete a face from a person in a person group by specified personGroupId, personId and persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/>, <paramref name="personId"/> or <paramref name="persistedFaceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/>, <paramref name="personId"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeletePersonGroupPersonFaceAsync(string,string,string,RequestContext)']/*" />
        public virtual async Task<Response> DeletePersonGroupPersonFaceAsync(string personGroupId, string personId, string persistedFaceId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNullOrEmpty(persistedFaceId, nameof(persistedFaceId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeletePersonGroupPersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeletePersonGroupPersonFaceRequest(personGroupId, personId, persistedFaceId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete a face from a person in a person group by specified personGroupId, personId and persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/>, <paramref name="personId"/> or <paramref name="persistedFaceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/>, <paramref name="personId"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeletePersonGroupPersonFace(string,string,string,RequestContext)']/*" />
        public virtual Response DeletePersonGroupPersonFace(string personGroupId, string personId, string persistedFaceId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNullOrEmpty(persistedFaceId, nameof(persistedFaceId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeletePersonGroupPersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeletePersonGroupPersonFaceRequest(personGroupId, personId, persistedFaceId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieve person face information. The persisted person face is specified by its personGroupId, personId and persistedFaceId. </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/>, <paramref name="personId"/> or <paramref name="persistedFaceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/>, <paramref name="personId"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroupPersonFaceAsync(string,string,string,CancellationToken)']/*" />
        public virtual async Task<Response<PersonGroupPersonFace>> GetPersonGroupPersonFaceAsync(string personGroupId, string personId, string persistedFaceId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNullOrEmpty(persistedFaceId, nameof(persistedFaceId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetPersonGroupPersonFaceAsync(personGroupId, personId, persistedFaceId, context).ConfigureAwait(false);
            return Response.FromValue(PersonGroupPersonFace.FromResponse(response), response);
        }

        /// <summary> Retrieve person face information. The persisted person face is specified by its personGroupId, personId and persistedFaceId. </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/>, <paramref name="personId"/> or <paramref name="persistedFaceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/>, <paramref name="personId"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroupPersonFace(string,string,string,CancellationToken)']/*" />
        public virtual Response<PersonGroupPersonFace> GetPersonGroupPersonFace(string personGroupId, string personId, string persistedFaceId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNullOrEmpty(persistedFaceId, nameof(persistedFaceId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetPersonGroupPersonFace(personGroupId, personId, persistedFaceId, context);
            return Response.FromValue(PersonGroupPersonFace.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Retrieve person face information. The persisted person face is specified by its personGroupId, personId and persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPersonGroupPersonFaceAsync(string,string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/>, <paramref name="personId"/> or <paramref name="persistedFaceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/>, <paramref name="personId"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroupPersonFaceAsync(string,string,string,RequestContext)']/*" />
        public virtual async Task<Response> GetPersonGroupPersonFaceAsync(string personGroupId, string personId, string persistedFaceId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNullOrEmpty(persistedFaceId, nameof(persistedFaceId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetPersonGroupPersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPersonGroupPersonFaceRequest(personGroupId, personId, persistedFaceId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Retrieve person face information. The persisted person face is specified by its personGroupId, personId and persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPersonGroupPersonFace(string,string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/>, <paramref name="personId"/> or <paramref name="persistedFaceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/>, <paramref name="personId"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroupPersonFace(string,string,string,RequestContext)']/*" />
        public virtual Response GetPersonGroupPersonFace(string personGroupId, string personId, string persistedFaceId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNullOrEmpty(persistedFaceId, nameof(persistedFaceId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetPersonGroupPersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPersonGroupPersonFaceRequest(personGroupId, personId, persistedFaceId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update a person persisted face's userData field.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/>, <paramref name="personId"/>, <paramref name="persistedFaceId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/>, <paramref name="personId"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdatePersonGroupPersonFaceAsync(string,string,string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> UpdatePersonGroupPersonFaceAsync(string personGroupId, string personId, string persistedFaceId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNullOrEmpty(persistedFaceId, nameof(persistedFaceId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdatePersonGroupPersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdatePersonGroupPersonFaceRequest(personGroupId, personId, persistedFaceId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update a person persisted face's userData field.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/>, <paramref name="personId"/>, <paramref name="persistedFaceId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/>, <paramref name="personId"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdatePersonGroupPersonFace(string,string,string,RequestContent,RequestContext)']/*" />
        public virtual Response UpdatePersonGroupPersonFace(string personGroupId, string personId, string persistedFaceId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNullOrEmpty(persistedFaceId, nameof(persistedFaceId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdatePersonGroupPersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdatePersonGroupPersonFaceRequest(personGroupId, personId, persistedFaceId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create a new large person group with user-specified largePersonGroupId, name, an optional userData and recognitionModel. </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="resource"> The resource instance. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> or <paramref name="resource"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// A large person group is a container holding the uploaded person data, including the face recognition features. It can hold up to 1,000,000 entities.
        ///
        /// After creation, use LargePersonGroup Person - Create to add person into the group, and call LargePersonGroup - Train to get this group ready for Face - Identify.
        ///
        /// No image will be stored. Only the person's extracted face feature(s) and userData will be stored on server until LargePersonGroup Person - Delete or LargePersonGroup - Delete is called.
        ///
        /// 'recognitionModel' should be specified to associate with this large person group. The default value for 'recognitionModel' is 'recognition_01', if the latest model needed, please explicitly specify the model you need in this parameter. New faces that are added to an existing large person group will use the recognition model that's already associated with the collection. Existing face feature(s) in a large person group can't be updated to features extracted by another version of recognition model.
        ///
        /// &gt; [!NOTE]
        /// &gt; * Free-tier subscription quota: 1,000 large person groups.
        /// &gt; * S0-tier subscription quota: 1,000,000 large person groups.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreateLargePersonGroupAsync(string,LargePersonGroup,CancellationToken)']/*" />
        public virtual async Task<Response> CreateLargePersonGroupAsync(string largePersonGroupId, LargePersonGroup resource, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNull(resource, nameof(resource));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = resource.ToRequestContent();
            Response response = await CreateLargePersonGroupAsync(largePersonGroupId, content, context).ConfigureAwait(false);
            return response;
        }

        /// <summary> Create a new large person group with user-specified largePersonGroupId, name, an optional userData and recognitionModel. </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="resource"> The resource instance. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> or <paramref name="resource"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// A large person group is a container holding the uploaded person data, including the face recognition features. It can hold up to 1,000,000 entities.
        ///
        /// After creation, use LargePersonGroup Person - Create to add person into the group, and call LargePersonGroup - Train to get this group ready for Face - Identify.
        ///
        /// No image will be stored. Only the person's extracted face feature(s) and userData will be stored on server until LargePersonGroup Person - Delete or LargePersonGroup - Delete is called.
        ///
        /// 'recognitionModel' should be specified to associate with this large person group. The default value for 'recognitionModel' is 'recognition_01', if the latest model needed, please explicitly specify the model you need in this parameter. New faces that are added to an existing large person group will use the recognition model that's already associated with the collection. Existing face feature(s) in a large person group can't be updated to features extracted by another version of recognition model.
        ///
        /// &gt; [!NOTE]
        /// &gt; * Free-tier subscription quota: 1,000 large person groups.
        /// &gt; * S0-tier subscription quota: 1,000,000 large person groups.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreateLargePersonGroup(string,LargePersonGroup,CancellationToken)']/*" />
        public virtual Response CreateLargePersonGroup(string largePersonGroupId, LargePersonGroup resource, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNull(resource, nameof(resource));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = resource.ToRequestContent();
            Response response = CreateLargePersonGroup(largePersonGroupId, content, context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] Create a new large person group with user-specified largePersonGroupId, name, an optional userData and recognitionModel.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateLargePersonGroupAsync(string,LargePersonGroup,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreateLargePersonGroupAsync(string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> CreateLargePersonGroupAsync(string largePersonGroupId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.CreateLargePersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateLargePersonGroupRequest(largePersonGroupId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Create a new large person group with user-specified largePersonGroupId, name, an optional userData and recognitionModel.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateLargePersonGroup(string,LargePersonGroup,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreateLargePersonGroup(string,RequestContent,RequestContext)']/*" />
        public virtual Response CreateLargePersonGroup(string largePersonGroupId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.CreateLargePersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateLargePersonGroupRequest(largePersonGroupId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete an existing large person group with specified personGroupId. Persisted data in this large person group will be deleted.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeleteLargePersonGroupAsync(string,RequestContext)']/*" />
        public virtual async Task<Response> DeleteLargePersonGroupAsync(string largePersonGroupId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeleteLargePersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteLargePersonGroupRequest(largePersonGroupId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete an existing large person group with specified personGroupId. Persisted data in this large person group will be deleted.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeleteLargePersonGroup(string,RequestContext)']/*" />
        public virtual Response DeleteLargePersonGroup(string largePersonGroupId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeleteLargePersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteLargePersonGroupRequest(largePersonGroupId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieve the information of a large person group, including its name, userData and recognitionModel. This API returns large person group information only, use LargePersonGroup Person - List instead to retrieve person information under the large person group. </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroupAsync(string,bool?,CancellationToken)']/*" />
        public virtual async Task<Response<LargePersonGroup>> GetLargePersonGroupAsync(string largePersonGroupId, bool? returnRecognitionModel = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetLargePersonGroupAsync(largePersonGroupId, returnRecognitionModel, context).ConfigureAwait(false);
            return Response.FromValue(LargePersonGroup.FromResponse(response), response);
        }

        /// <summary> Retrieve the information of a large person group, including its name, userData and recognitionModel. This API returns large person group information only, use LargePersonGroup Person - List instead to retrieve person information under the large person group. </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroup(string,bool?,CancellationToken)']/*" />
        public virtual Response<LargePersonGroup> GetLargePersonGroup(string largePersonGroupId, bool? returnRecognitionModel = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetLargePersonGroup(largePersonGroupId, returnRecognitionModel, context);
            return Response.FromValue(LargePersonGroup.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Retrieve the information of a large person group, including its name, userData and recognitionModel. This API returns large person group information only, use LargePersonGroup Person - List instead to retrieve person information under the large person group.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLargePersonGroupAsync(string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroupAsync(string,bool?,RequestContext)']/*" />
        public virtual async Task<Response> GetLargePersonGroupAsync(string largePersonGroupId, bool? returnRecognitionModel, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetLargePersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLargePersonGroupRequest(largePersonGroupId, returnRecognitionModel, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Retrieve the information of a large person group, including its name, userData and recognitionModel. This API returns large person group information only, use LargePersonGroup Person - List instead to retrieve person information under the large person group.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLargePersonGroup(string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroup(string,bool?,RequestContext)']/*" />
        public virtual Response GetLargePersonGroup(string largePersonGroupId, bool? returnRecognitionModel, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetLargePersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLargePersonGroupRequest(largePersonGroupId, returnRecognitionModel, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update an existing large person group's name and userData. The properties keep unchanged if they are not in request body.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdateLargePersonGroupAsync(string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> UpdateLargePersonGroupAsync(string largePersonGroupId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdateLargePersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateLargePersonGroupRequest(largePersonGroupId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update an existing large person group's name and userData. The properties keep unchanged if they are not in request body.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdateLargePersonGroup(string,RequestContent,RequestContext)']/*" />
        public virtual Response UpdateLargePersonGroup(string largePersonGroupId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdateLargePersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateLargePersonGroupRequest(largePersonGroupId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> List all existing large person groups' largePersonGroupId, name, userData and recognitionModel. </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks>
        /// * Large person groups are stored in alphabetical order of largePersonGroupId.
        /// * "start" parameter (string, optional) is a id value that returned entries have larger ids by string comparison. "start" set to empty to indicate return from the first item.
        /// * "top" parameter (int, optional) specifies the number of entries to return. A maximal of 1000 entries can be returned in one call. To fetch more, you can specify "start" with the last returned entry's personId of the current call.
        ///
        /// &gt; [!TIP]
        /// &gt; For example, total 5 items with their id: "itemId1", ..., "itemId5".
        /// &gt; * "start=&amp;top=" will return all 5 items.
        /// &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroupsAsync(string,int?,bool?,CancellationToken)']/*" />
        public virtual async Task<Response<IReadOnlyList<LargePersonGroup>>> GetLargePersonGroupsAsync(string start = null, int? top = null, bool? returnRecognitionModel = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetLargePersonGroupsAsync(start, top, returnRecognitionModel, context).ConfigureAwait(false);
            IReadOnlyList<LargePersonGroup> value = default;
            using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
            List<LargePersonGroup> array = new List<LargePersonGroup>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(LargePersonGroup.DeserializeLargePersonGroup(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary> List all existing large person groups' largePersonGroupId, name, userData and recognitionModel. </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks>
        /// * Large person groups are stored in alphabetical order of largePersonGroupId.
        /// * "start" parameter (string, optional) is a id value that returned entries have larger ids by string comparison. "start" set to empty to indicate return from the first item.
        /// * "top" parameter (int, optional) specifies the number of entries to return. A maximal of 1000 entries can be returned in one call. To fetch more, you can specify "start" with the last returned entry's personId of the current call.
        ///
        /// &gt; [!TIP]
        /// &gt; For example, total 5 items with their id: "itemId1", ..., "itemId5".
        /// &gt; * "start=&amp;top=" will return all 5 items.
        /// &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroups(string,int?,bool?,CancellationToken)']/*" />
        public virtual Response<IReadOnlyList<LargePersonGroup>> GetLargePersonGroups(string start = null, int? top = null, bool? returnRecognitionModel = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetLargePersonGroups(start, top, returnRecognitionModel, context);
            IReadOnlyList<LargePersonGroup> value = default;
            using var document = JsonDocument.Parse(response.ContentStream);
            List<LargePersonGroup> array = new List<LargePersonGroup>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(LargePersonGroup.DeserializeLargePersonGroup(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// [Protocol Method] List all existing large person groups' largePersonGroupId, name, userData and recognitionModel.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLargePersonGroupsAsync(string,int?,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroupsAsync(string,int?,bool?,RequestContext)']/*" />
        public virtual async Task<Response> GetLargePersonGroupsAsync(string start, int? top, bool? returnRecognitionModel, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetLargePersonGroups");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLargePersonGroupsRequest(start, top, returnRecognitionModel, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] List all existing large person groups' largePersonGroupId, name, userData and recognitionModel.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLargePersonGroups(string,int?,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroups(string,int?,bool?,RequestContext)']/*" />
        public virtual Response GetLargePersonGroups(string start, int? top, bool? returnRecognitionModel, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetLargePersonGroups");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLargePersonGroupsRequest(start, top, returnRecognitionModel, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> To check large person group training status completed or still ongoing. LargePersonGroup Training is an asynchronous operation triggered by LargePersonGroup - Train API. </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Training time depends on the number of person entries, and their faces in a large person group. It could be in seconds, or up to half an hour for 1,000,000 persons. </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroupTrainingStatusAsync(string,CancellationToken)']/*" />
        public virtual async Task<Response<FaceCollectionTrainingStatus>> GetLargePersonGroupTrainingStatusAsync(string largePersonGroupId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetLargePersonGroupTrainingStatusAsync(largePersonGroupId, context).ConfigureAwait(false);
            return Response.FromValue(FaceCollectionTrainingStatus.FromResponse(response), response);
        }

        /// <summary> To check large person group training status completed or still ongoing. LargePersonGroup Training is an asynchronous operation triggered by LargePersonGroup - Train API. </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Training time depends on the number of person entries, and their faces in a large person group. It could be in seconds, or up to half an hour for 1,000,000 persons. </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroupTrainingStatus(string,CancellationToken)']/*" />
        public virtual Response<FaceCollectionTrainingStatus> GetLargePersonGroupTrainingStatus(string largePersonGroupId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetLargePersonGroupTrainingStatus(largePersonGroupId, context);
            return Response.FromValue(FaceCollectionTrainingStatus.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] To check large person group training status completed or still ongoing. LargePersonGroup Training is an asynchronous operation triggered by LargePersonGroup - Train API.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLargePersonGroupTrainingStatusAsync(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroupTrainingStatusAsync(string,RequestContext)']/*" />
        public virtual async Task<Response> GetLargePersonGroupTrainingStatusAsync(string largePersonGroupId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetLargePersonGroupTrainingStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLargePersonGroupTrainingStatusRequest(largePersonGroupId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] To check large person group training status completed or still ongoing. LargePersonGroup Training is an asynchronous operation triggered by LargePersonGroup - Train API.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLargePersonGroupTrainingStatus(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroupTrainingStatus(string,RequestContext)']/*" />
        public virtual Response GetLargePersonGroupTrainingStatus(string largePersonGroupId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetLargePersonGroupTrainingStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLargePersonGroupTrainingStatusRequest(largePersonGroupId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create a new person in a specified large person group. To add face to this person, please call LargePersonGroup PersonFace - Add. </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="userDefinedFields"> Model for object name and user data. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> or <paramref name="userDefinedFields"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// &gt; [!NOTE]
        /// &gt; * Free-tier subscription quota:
        /// &gt;   * 1,000 persons in all large person groups.
        /// &gt; * S0-tier subscription quota:
        /// &gt;   * 1,000,000 persons per large person group.
        /// &gt;   * 1,000,000 large person groups.
        /// &gt;   * 1,000,000,000 persons in all large person groups.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreateLargePersonGroupPersonAsync(string,UserDefinedFields,CancellationToken)']/*" />
        public virtual async Task<Response<CreatePersonResult>> CreateLargePersonGroupPersonAsync(string largePersonGroupId, UserDefinedFields userDefinedFields, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNull(userDefinedFields, nameof(userDefinedFields));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = userDefinedFields.ToRequestContent();
            Response response = await CreateLargePersonGroupPersonAsync(largePersonGroupId, content, context).ConfigureAwait(false);
            return Response.FromValue(CreatePersonResult.FromResponse(response), response);
        }

        /// <summary> Create a new person in a specified large person group. To add face to this person, please call LargePersonGroup PersonFace - Add. </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="userDefinedFields"> Model for object name and user data. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> or <paramref name="userDefinedFields"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// &gt; [!NOTE]
        /// &gt; * Free-tier subscription quota:
        /// &gt;   * 1,000 persons in all large person groups.
        /// &gt; * S0-tier subscription quota:
        /// &gt;   * 1,000,000 persons per large person group.
        /// &gt;   * 1,000,000 large person groups.
        /// &gt;   * 1,000,000,000 persons in all large person groups.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreateLargePersonGroupPerson(string,UserDefinedFields,CancellationToken)']/*" />
        public virtual Response<CreatePersonResult> CreateLargePersonGroupPerson(string largePersonGroupId, UserDefinedFields userDefinedFields, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNull(userDefinedFields, nameof(userDefinedFields));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = userDefinedFields.ToRequestContent();
            Response response = CreateLargePersonGroupPerson(largePersonGroupId, content, context);
            return Response.FromValue(CreatePersonResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Create a new person in a specified large person group. To add face to this person, please call LargePersonGroup PersonFace - Add.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateLargePersonGroupPersonAsync(string,UserDefinedFields,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreateLargePersonGroupPersonAsync(string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> CreateLargePersonGroupPersonAsync(string largePersonGroupId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.CreateLargePersonGroupPerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateLargePersonGroupPersonRequest(largePersonGroupId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Create a new person in a specified large person group. To add face to this person, please call LargePersonGroup PersonFace - Add.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateLargePersonGroupPerson(string,UserDefinedFields,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreateLargePersonGroupPerson(string,RequestContent,RequestContext)']/*" />
        public virtual Response CreateLargePersonGroupPerson(string largePersonGroupId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.CreateLargePersonGroupPerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateLargePersonGroupPersonRequest(largePersonGroupId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete an existing person from a large person group. The persistedFaceId, userData, person name and face feature(s) in the person entry will all be deleted.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> or <paramref name="personId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> or <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeleteLargePersonGroupPersonAsync(string,string,RequestContext)']/*" />
        public virtual async Task<Response> DeleteLargePersonGroupPersonAsync(string largePersonGroupId, string personId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeleteLargePersonGroupPerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteLargePersonGroupPersonRequest(largePersonGroupId, personId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete an existing person from a large person group. The persistedFaceId, userData, person name and face feature(s) in the person entry will all be deleted.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> or <paramref name="personId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> or <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeleteLargePersonGroupPerson(string,string,RequestContext)']/*" />
        public virtual Response DeleteLargePersonGroupPerson(string largePersonGroupId, string personId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeleteLargePersonGroupPerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteLargePersonGroupPersonRequest(largePersonGroupId, personId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieve a person's name and userData, and the persisted faceIds representing the registered person face feature(s). </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> or <paramref name="personId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> or <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroupPersonAsync(string,string,CancellationToken)']/*" />
        public virtual async Task<Response<LargePersonGroupPerson>> GetLargePersonGroupPersonAsync(string largePersonGroupId, string personId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetLargePersonGroupPersonAsync(largePersonGroupId, personId, context).ConfigureAwait(false);
            return Response.FromValue(LargePersonGroupPerson.FromResponse(response), response);
        }

        /// <summary> Retrieve a person's name and userData, and the persisted faceIds representing the registered person face feature(s). </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> or <paramref name="personId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> or <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroupPerson(string,string,CancellationToken)']/*" />
        public virtual Response<LargePersonGroupPerson> GetLargePersonGroupPerson(string largePersonGroupId, string personId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetLargePersonGroupPerson(largePersonGroupId, personId, context);
            return Response.FromValue(LargePersonGroupPerson.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Retrieve a person's name and userData, and the persisted faceIds representing the registered person face feature(s).
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLargePersonGroupPersonAsync(string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> or <paramref name="personId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> or <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroupPersonAsync(string,string,RequestContext)']/*" />
        public virtual async Task<Response> GetLargePersonGroupPersonAsync(string largePersonGroupId, string personId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetLargePersonGroupPerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLargePersonGroupPersonRequest(largePersonGroupId, personId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Retrieve a person's name and userData, and the persisted faceIds representing the registered person face feature(s).
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLargePersonGroupPerson(string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> or <paramref name="personId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> or <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroupPerson(string,string,RequestContext)']/*" />
        public virtual Response GetLargePersonGroupPerson(string largePersonGroupId, string personId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetLargePersonGroupPerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLargePersonGroupPersonRequest(largePersonGroupId, personId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update name or userData of a person.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/>, <paramref name="personId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> or <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdateLargePersonGroupPersonAsync(string,string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> UpdateLargePersonGroupPersonAsync(string largePersonGroupId, string personId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdateLargePersonGroupPerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateLargePersonGroupPersonRequest(largePersonGroupId, personId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update name or userData of a person.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/>, <paramref name="personId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> or <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdateLargePersonGroupPerson(string,string,RequestContent,RequestContext)']/*" />
        public virtual Response UpdateLargePersonGroupPerson(string largePersonGroupId, string personId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdateLargePersonGroupPerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateLargePersonGroupPersonRequest(largePersonGroupId, personId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> List all persons' information in the specified large person group, including personId, name, userData and persistedFaceIds of registered person faces. </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// * Persons are stored in alphabetical order of personId created in LargePersonGroup Person - Create.
        /// * "start" parameter (string, optional) is a id value that returned entries have larger ids by string comparison. "start" set to empty to indicate return from the first item.
        /// * "top" parameter (int, optional) specifies the number of entries to return. A maximal of 1000 entries can be returned in one call. To fetch more, you can specify "start" with the last returned entry's personId of the current call.
        ///
        /// &gt; [!TIP]
        /// &gt; For example, total 5 items with their id: "itemId1", ..., "itemId5".
        /// &gt; * "start=&amp;top=" will return all 5 items.
        /// &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroupPersonsAsync(string,string,int?,CancellationToken)']/*" />
        public virtual async Task<Response<IReadOnlyList<LargePersonGroupPerson>>> GetLargePersonGroupPersonsAsync(string largePersonGroupId, string start = null, int? top = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetLargePersonGroupPersonsAsync(largePersonGroupId, start, top, context).ConfigureAwait(false);
            IReadOnlyList<LargePersonGroupPerson> value = default;
            using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
            List<LargePersonGroupPerson> array = new List<LargePersonGroupPerson>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(LargePersonGroupPerson.DeserializeLargePersonGroupPerson(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary> List all persons' information in the specified large person group, including personId, name, userData and persistedFaceIds of registered person faces. </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// * Persons are stored in alphabetical order of personId created in LargePersonGroup Person - Create.
        /// * "start" parameter (string, optional) is a id value that returned entries have larger ids by string comparison. "start" set to empty to indicate return from the first item.
        /// * "top" parameter (int, optional) specifies the number of entries to return. A maximal of 1000 entries can be returned in one call. To fetch more, you can specify "start" with the last returned entry's personId of the current call.
        ///
        /// &gt; [!TIP]
        /// &gt; For example, total 5 items with their id: "itemId1", ..., "itemId5".
        /// &gt; * "start=&amp;top=" will return all 5 items.
        /// &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroupPersons(string,string,int?,CancellationToken)']/*" />
        public virtual Response<IReadOnlyList<LargePersonGroupPerson>> GetLargePersonGroupPersons(string largePersonGroupId, string start = null, int? top = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetLargePersonGroupPersons(largePersonGroupId, start, top, context);
            IReadOnlyList<LargePersonGroupPerson> value = default;
            using var document = JsonDocument.Parse(response.ContentStream);
            List<LargePersonGroupPerson> array = new List<LargePersonGroupPerson>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(LargePersonGroupPerson.DeserializeLargePersonGroupPerson(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// [Protocol Method] List all persons' information in the specified large person group, including personId, name, userData and persistedFaceIds of registered person faces.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLargePersonGroupPersonsAsync(string,string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroupPersonsAsync(string,string,int?,RequestContext)']/*" />
        public virtual async Task<Response> GetLargePersonGroupPersonsAsync(string largePersonGroupId, string start, int? top, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetLargePersonGroupPersons");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLargePersonGroupPersonsRequest(largePersonGroupId, start, top, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] List all persons' information in the specified large person group, including personId, name, userData and persistedFaceIds of registered person faces.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLargePersonGroupPersons(string,string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroupPersons(string,string,int?,RequestContext)']/*" />
        public virtual Response GetLargePersonGroupPersons(string largePersonGroupId, string start, int? top, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetLargePersonGroupPersons");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLargePersonGroupPersonsRequest(largePersonGroupId, start, top, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Add a face to a person into a large person group for face identification or verification. </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="url"> URL of input image. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/>, <paramref name="personId"/> or <paramref name="url"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> or <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// To deal with an image containing multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature(s) will be stored on server until LargePersonGroup PersonFace - Delete, LargePersonGroup Person - Delete or LargePersonGroup - Delete is called.
        ///
        /// Note persistedFaceId is different from faceId generated by Face - Detect.
        ///
        /// * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        /// * Each person entry can hold up to 248 faces.
        /// * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
        /// * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from Face - Detect, there's no guarantee to detect and add the face successfully.
        /// * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
        /// * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
        /// * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to https://learn.microsoft.com/en-us/azure/ai-services/computer-vision/how-to/specify-detection-model
        ///   * 'detection_01': The default detection model for PersonDirectory Person - Add Face. Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected.
        ///   * 'detection_02': Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces.
        ///   * 'detection_03': Detection model released in 2021 February with improved accuracy especially on small faces.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddLargePersonGroupPersonFaceFromUrlAsync(string,string,Uri,string,FaceDetectionModel?,string,CancellationToken)']/*" />
        public virtual async Task<Response<AddFaceResult>> AddLargePersonGroupPersonFaceFromUrlAsync(string largePersonGroupId, string personId, Uri url, string targetFace = null, FaceDetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNull(url, nameof(url));

            RequestContext context = FromCancellationToken(cancellationToken);
            AddLargePersonGroupPersonFaceFromUrlRequest addLargePersonGroupPersonFaceFromUrlRequest = new AddLargePersonGroupPersonFaceFromUrlRequest(url);
            Response response = await AddLargePersonGroupPersonFaceFromUrlAsync(largePersonGroupId, personId, addLargePersonGroupPersonFaceFromUrlRequest.ToRequestContent(), targetFace, detectionModel?.ToString(), userData, context).ConfigureAwait(false);
            return Response.FromValue(AddFaceResult.FromResponse(response), response);
        }

        /// <summary> Add a face to a person into a large person group for face identification or verification. </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="url"> URL of input image. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/>, <paramref name="personId"/> or <paramref name="url"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> or <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// To deal with an image containing multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature(s) will be stored on server until LargePersonGroup PersonFace - Delete, LargePersonGroup Person - Delete or LargePersonGroup - Delete is called.
        ///
        /// Note persistedFaceId is different from faceId generated by Face - Detect.
        ///
        /// * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        /// * Each person entry can hold up to 248 faces.
        /// * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
        /// * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from Face - Detect, there's no guarantee to detect and add the face successfully.
        /// * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
        /// * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
        /// * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to https://learn.microsoft.com/en-us/azure/ai-services/computer-vision/how-to/specify-detection-model
        ///   * 'detection_01': The default detection model for PersonDirectory Person - Add Face. Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected.
        ///   * 'detection_02': Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces.
        ///   * 'detection_03': Detection model released in 2021 February with improved accuracy especially on small faces.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddLargePersonGroupPersonFaceFromUrl(string,string,Uri,string,FaceDetectionModel?,string,CancellationToken)']/*" />
        public virtual Response<AddFaceResult> AddLargePersonGroupPersonFaceFromUrl(string largePersonGroupId, string personId, Uri url, string targetFace = null, FaceDetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNull(url, nameof(url));

            RequestContext context = FromCancellationToken(cancellationToken);
            AddLargePersonGroupPersonFaceFromUrlRequest addLargePersonGroupPersonFaceFromUrlRequest = new AddLargePersonGroupPersonFaceFromUrlRequest(url);
            Response response = AddLargePersonGroupPersonFaceFromUrl(largePersonGroupId, personId, addLargePersonGroupPersonFaceFromUrlRequest.ToRequestContent(), targetFace, detectionModel?.ToString(), userData, context);
            return Response.FromValue(AddFaceResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Add a face to a person into a large person group for face identification or verification.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddLargePersonGroupPersonFaceFromUrlAsync(string,string,Uri,string,FaceDetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/>, <paramref name="personId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> or <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddLargePersonGroupPersonFaceFromUrlAsync(string,string,RequestContent,string,string,string,RequestContext)']/*" />
        public virtual async Task<Response> AddLargePersonGroupPersonFaceFromUrlAsync(string largePersonGroupId, string personId, RequestContent content, string targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.AddLargePersonGroupPersonFaceFromUrl");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddLargePersonGroupPersonFaceFromUrlRequest(largePersonGroupId, personId, content, targetFace, detectionModel, userData, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Add a face to a person into a large person group for face identification or verification.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddLargePersonGroupPersonFaceFromUrl(string,string,Uri,string,FaceDetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/>, <paramref name="personId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> or <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddLargePersonGroupPersonFaceFromUrl(string,string,RequestContent,string,string,string,RequestContext)']/*" />
        public virtual Response AddLargePersonGroupPersonFaceFromUrl(string largePersonGroupId, string personId, RequestContent content, string targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.AddLargePersonGroupPersonFaceFromUrl");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddLargePersonGroupPersonFaceFromUrlRequest(largePersonGroupId, personId, content, targetFace, detectionModel, userData, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Add a face to a person into a large person group for face identification or verification. </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="imageContent"> The image to be analyzed. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/>, <paramref name="personId"/> or <paramref name="imageContent"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> or <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// To deal with an image containing multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature(s) will be stored on server until LargePersonGroup PersonFace - Delete, LargePersonGroup Person - Delete or LargePersonGroup - Delete is called.
        ///
        /// Note persistedFaceId is different from faceId generated by Face - Detect.
        ///
        /// * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        /// * Each person entry can hold up to 248 faces.
        /// * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
        /// * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from Face - Detect, there's no guarantee to detect and add the face successfully.
        /// * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
        /// * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
        /// * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to https://learn.microsoft.com/en-us/azure/ai-services/computer-vision/how-to/specify-detection-model
        ///   * 'detection_01': The default detection model for PersonDirectory Person - Add Face. Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected.
        ///   * 'detection_02': Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces.
        ///   * 'detection_03': Detection model released in 2021 February with improved accuracy especially on small faces.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddLargePersonGroupPersonFaceAsync(string,string,BinaryData,string,FaceDetectionModel?,string,CancellationToken)']/*" />
        public virtual async Task<Response<AddFaceResult>> AddLargePersonGroupPersonFaceAsync(string largePersonGroupId, string personId, BinaryData imageContent, string targetFace = null, FaceDetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNull(imageContent, nameof(imageContent));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = imageContent;
            Response response = await AddLargePersonGroupPersonFaceAsync(largePersonGroupId, personId, content, targetFace, detectionModel?.ToString(), userData, context).ConfigureAwait(false);
            return Response.FromValue(AddFaceResult.FromResponse(response), response);
        }

        /// <summary> Add a face to a person into a large person group for face identification or verification. </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="imageContent"> The image to be analyzed. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/>, <paramref name="personId"/> or <paramref name="imageContent"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> or <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// To deal with an image containing multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature(s) will be stored on server until LargePersonGroup PersonFace - Delete, LargePersonGroup Person - Delete or LargePersonGroup - Delete is called.
        ///
        /// Note persistedFaceId is different from faceId generated by Face - Detect.
        ///
        /// * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        /// * Each person entry can hold up to 248 faces.
        /// * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
        /// * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from Face - Detect, there's no guarantee to detect and add the face successfully.
        /// * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
        /// * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
        /// * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to https://learn.microsoft.com/en-us/azure/ai-services/computer-vision/how-to/specify-detection-model
        ///   * 'detection_01': The default detection model for PersonDirectory Person - Add Face. Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected.
        ///   * 'detection_02': Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces.
        ///   * 'detection_03': Detection model released in 2021 February with improved accuracy especially on small faces.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddLargePersonGroupPersonFace(string,string,BinaryData,string,FaceDetectionModel?,string,CancellationToken)']/*" />
        public virtual Response<AddFaceResult> AddLargePersonGroupPersonFace(string largePersonGroupId, string personId, BinaryData imageContent, string targetFace = null, FaceDetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNull(imageContent, nameof(imageContent));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = imageContent;
            Response response = AddLargePersonGroupPersonFace(largePersonGroupId, personId, content, targetFace, detectionModel?.ToString(), userData, context);
            return Response.FromValue(AddFaceResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Add a face to a person into a large person group for face identification or verification.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddLargePersonGroupPersonFaceAsync(string,string,BinaryData,string,FaceDetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/>, <paramref name="personId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> or <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddLargePersonGroupPersonFaceAsync(string,string,RequestContent,string,string,string,RequestContext)']/*" />
        public virtual async Task<Response> AddLargePersonGroupPersonFaceAsync(string largePersonGroupId, string personId, RequestContent content, string targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.AddLargePersonGroupPersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddLargePersonGroupPersonFaceRequest(largePersonGroupId, personId, content, targetFace, detectionModel, userData, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Add a face to a person into a large person group for face identification or verification.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddLargePersonGroupPersonFace(string,string,BinaryData,string,FaceDetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/>, <paramref name="personId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> or <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddLargePersonGroupPersonFace(string,string,RequestContent,string,string,string,RequestContext)']/*" />
        public virtual Response AddLargePersonGroupPersonFace(string largePersonGroupId, string personId, RequestContent content, string targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.AddLargePersonGroupPersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddLargePersonGroupPersonFaceRequest(largePersonGroupId, personId, content, targetFace, detectionModel, userData, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete a face from a person in a large person group by specified largePersonGroupId, personId and persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/>, <paramref name="personId"/> or <paramref name="persistedFaceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/>, <paramref name="personId"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeleteLargePersonGroupPersonFaceAsync(string,string,string,RequestContext)']/*" />
        public virtual async Task<Response> DeleteLargePersonGroupPersonFaceAsync(string largePersonGroupId, string personId, string persistedFaceId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNullOrEmpty(persistedFaceId, nameof(persistedFaceId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeleteLargePersonGroupPersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteLargePersonGroupPersonFaceRequest(largePersonGroupId, personId, persistedFaceId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete a face from a person in a large person group by specified largePersonGroupId, personId and persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/>, <paramref name="personId"/> or <paramref name="persistedFaceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/>, <paramref name="personId"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeleteLargePersonGroupPersonFace(string,string,string,RequestContext)']/*" />
        public virtual Response DeleteLargePersonGroupPersonFace(string largePersonGroupId, string personId, string persistedFaceId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNullOrEmpty(persistedFaceId, nameof(persistedFaceId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeleteLargePersonGroupPersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteLargePersonGroupPersonFaceRequest(largePersonGroupId, personId, persistedFaceId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieve person face information. The persisted person face is specified by its largePersonGroupId, personId and persistedFaceId. </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/>, <paramref name="personId"/> or <paramref name="persistedFaceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/>, <paramref name="personId"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroupPersonFaceAsync(string,string,string,CancellationToken)']/*" />
        public virtual async Task<Response<LargePersonGroupPersonFace>> GetLargePersonGroupPersonFaceAsync(string largePersonGroupId, string personId, string persistedFaceId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNullOrEmpty(persistedFaceId, nameof(persistedFaceId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetLargePersonGroupPersonFaceAsync(largePersonGroupId, personId, persistedFaceId, context).ConfigureAwait(false);
            return Response.FromValue(LargePersonGroupPersonFace.FromResponse(response), response);
        }

        /// <summary> Retrieve person face information. The persisted person face is specified by its largePersonGroupId, personId and persistedFaceId. </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/>, <paramref name="personId"/> or <paramref name="persistedFaceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/>, <paramref name="personId"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroupPersonFace(string,string,string,CancellationToken)']/*" />
        public virtual Response<LargePersonGroupPersonFace> GetLargePersonGroupPersonFace(string largePersonGroupId, string personId, string persistedFaceId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNullOrEmpty(persistedFaceId, nameof(persistedFaceId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetLargePersonGroupPersonFace(largePersonGroupId, personId, persistedFaceId, context);
            return Response.FromValue(LargePersonGroupPersonFace.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Retrieve person face information. The persisted person face is specified by its largePersonGroupId, personId and persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLargePersonGroupPersonFaceAsync(string,string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/>, <paramref name="personId"/> or <paramref name="persistedFaceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/>, <paramref name="personId"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroupPersonFaceAsync(string,string,string,RequestContext)']/*" />
        public virtual async Task<Response> GetLargePersonGroupPersonFaceAsync(string largePersonGroupId, string personId, string persistedFaceId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNullOrEmpty(persistedFaceId, nameof(persistedFaceId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetLargePersonGroupPersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLargePersonGroupPersonFaceRequest(largePersonGroupId, personId, persistedFaceId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Retrieve person face information. The persisted person face is specified by its largePersonGroupId, personId and persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLargePersonGroupPersonFace(string,string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/>, <paramref name="personId"/> or <paramref name="persistedFaceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/>, <paramref name="personId"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroupPersonFace(string,string,string,RequestContext)']/*" />
        public virtual Response GetLargePersonGroupPersonFace(string largePersonGroupId, string personId, string persistedFaceId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNullOrEmpty(persistedFaceId, nameof(persistedFaceId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetLargePersonGroupPersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLargePersonGroupPersonFaceRequest(largePersonGroupId, personId, persistedFaceId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update a person persisted face's userData field.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/>, <paramref name="personId"/>, <paramref name="persistedFaceId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/>, <paramref name="personId"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdateLargePersonGroupPersonFaceAsync(string,string,string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> UpdateLargePersonGroupPersonFaceAsync(string largePersonGroupId, string personId, string persistedFaceId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNullOrEmpty(persistedFaceId, nameof(persistedFaceId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdateLargePersonGroupPersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateLargePersonGroupPersonFaceRequest(largePersonGroupId, personId, persistedFaceId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update a person persisted face's userData field.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/>, <paramref name="personId"/>, <paramref name="persistedFaceId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/>, <paramref name="personId"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdateLargePersonGroupPersonFace(string,string,string,RequestContent,RequestContext)']/*" />
        public virtual Response UpdateLargePersonGroupPersonFace(string largePersonGroupId, string personId, string persistedFaceId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNullOrEmpty(persistedFaceId, nameof(persistedFaceId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdateLargePersonGroupPersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateLargePersonGroupPersonFaceRequest(largePersonGroupId, personId, persistedFaceId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Creates a new person in a person directory. To add face to this person, please call PersonDirectory Person - Add Face. </summary>
        /// <param name="resource"> The resource instance. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resource"/> is null. </exception>
        internal virtual async Task<Response<CreatePersonResult>> CreatePersonAsync(PersonDirectoryPerson resource, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(resource, nameof(resource));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = resource.ToRequestContent();
            Response response = await CreatePersonAsync(content, context).ConfigureAwait(false);
            return Response.FromValue(CreatePersonResult.FromResponse(response), response);
        }

        /// <summary> Creates a new person in a person directory. To add face to this person, please call PersonDirectory Person - Add Face. </summary>
        /// <param name="resource"> The resource instance. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resource"/> is null. </exception>
        internal virtual Response<CreatePersonResult> CreatePerson(PersonDirectoryPerson resource, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(resource, nameof(resource));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = resource.ToRequestContent();
            Response response = CreatePerson(content, context);
            return Response.FromValue(CreatePersonResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Creates a new person in a person directory. To add face to this person, please call PersonDirectory Person - Add Face.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreatePersonAsync(PersonDirectoryPerson,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        internal virtual async Task<Response> CreatePersonAsync(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.CreatePerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreatePersonRequest(content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Creates a new person in a person directory. To add face to this person, please call PersonDirectory Person - Add Face.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreatePerson(PersonDirectoryPerson,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        internal virtual Response CreatePerson(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.CreatePerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreatePersonRequest(content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieve a person's name and userData from person directory. </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonAsync(string,CancellationToken)']/*" />
        public virtual async Task<Response<PersonDirectoryPerson>> GetPersonAsync(string personId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetPersonAsync(personId, context).ConfigureAwait(false);
            return Response.FromValue(PersonDirectoryPerson.FromResponse(response), response);
        }

        /// <summary> Retrieve a person's name and userData from person directory. </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPerson(string,CancellationToken)']/*" />
        public virtual Response<PersonDirectoryPerson> GetPerson(string personId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetPerson(personId, context);
            return Response.FromValue(PersonDirectoryPerson.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Retrieve a person's name and userData from person directory.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPersonAsync(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonAsync(string,RequestContext)']/*" />
        public virtual async Task<Response> GetPersonAsync(string personId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetPerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPersonRequest(personId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Retrieve a person's name and userData from person directory.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPerson(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPerson(string,RequestContext)']/*" />
        public virtual Response GetPerson(string personId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetPerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPersonRequest(personId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update name or userData of a person.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdatePersonAsync(string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> UpdatePersonAsync(string personId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdatePerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdatePersonRequest(personId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update name or userData of a person.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdatePerson(string,RequestContent,RequestContext)']/*" />
        public virtual Response UpdatePerson(string personId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdatePerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdatePersonRequest(personId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> List all persons' information in person directory, including personId, name, and userData. </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks>
        /// * Persons are stored in alphabetical order of personId created in PersonDirectory Person - Create.
        /// * "start" parameter (string, optional) is a id value that returned entries have larger ids by string comparison. "start" set to empty to indicate return from the first item.
        /// * "top" parameter (int, optional) specifies the number of entries to return. A maximal of 1000 entries can be returned in one call. To fetch more, you can specify "start" with the last returned entry's personId of the current call.
        ///
        /// &gt; [!TIP]
        /// &gt; For example, total 5 items with their id: "itemId1", ..., "itemId5".
        /// &gt; * "start=&amp;top=" will return all 5 items.
        /// &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonsAsync(string,int?,CancellationToken)']/*" />
        public virtual async Task<Response<IReadOnlyList<PersonDirectoryPerson>>> GetPersonsAsync(string start = null, int? top = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetPersonsAsync(start, top, context).ConfigureAwait(false);
            IReadOnlyList<PersonDirectoryPerson> value = default;
            using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
            List<PersonDirectoryPerson> array = new List<PersonDirectoryPerson>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(PersonDirectoryPerson.DeserializePersonDirectoryPerson(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary> List all persons' information in person directory, including personId, name, and userData. </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks>
        /// * Persons are stored in alphabetical order of personId created in PersonDirectory Person - Create.
        /// * "start" parameter (string, optional) is a id value that returned entries have larger ids by string comparison. "start" set to empty to indicate return from the first item.
        /// * "top" parameter (int, optional) specifies the number of entries to return. A maximal of 1000 entries can be returned in one call. To fetch more, you can specify "start" with the last returned entry's personId of the current call.
        ///
        /// &gt; [!TIP]
        /// &gt; For example, total 5 items with their id: "itemId1", ..., "itemId5".
        /// &gt; * "start=&amp;top=" will return all 5 items.
        /// &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersons(string,int?,CancellationToken)']/*" />
        public virtual Response<IReadOnlyList<PersonDirectoryPerson>> GetPersons(string start = null, int? top = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetPersons(start, top, context);
            IReadOnlyList<PersonDirectoryPerson> value = default;
            using var document = JsonDocument.Parse(response.ContentStream);
            List<PersonDirectoryPerson> array = new List<PersonDirectoryPerson>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(PersonDirectoryPerson.DeserializePersonDirectoryPerson(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// [Protocol Method] List all persons' information in person directory, including personId, name, and userData.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPersonsAsync(string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonsAsync(string,int?,RequestContext)']/*" />
        public virtual async Task<Response> GetPersonsAsync(string start, int? top, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetPersons");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPersonsRequest(start, top, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] List all persons' information in person directory, including personId, name, and userData.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPersons(string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersons(string,int?,RequestContext)']/*" />
        public virtual Response GetPersons(string start, int? top, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetPersons");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPersonsRequest(start, top, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> List all dynamic person groups a person has been referenced by in person directory. </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// * Dynamic person groups are stored in alphabetical order of dynamic person group id created in PersonDirectory DynamicPersonGroup - Create.
        /// * "start" parameter (string, optional) is a id value that returned entries have larger ids by string comparison. "start" set to empty to indicate return from the first item.
        /// * "top" parameter (int, optional) specifies the number of entries to return. A maximal of 1000 entries can be returned in one call. To fetch more, you can specify "start" with the last returned entry's personId of the current call.
        ///
        /// &gt; [!TIP]
        /// &gt; For example, total 5 items with their id: "itemId1", ..., "itemId5".
        /// &gt; * "start=&amp;top=" will return all 5 items.
        /// &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetDynamicPersonGroupReferencesAsync(string,string,int?,CancellationToken)']/*" />
        public virtual async Task<Response<ListGroupReferenceResult>> GetDynamicPersonGroupReferencesAsync(string personId, string start = null, int? top = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetDynamicPersonGroupReferencesAsync(personId, start, top, context).ConfigureAwait(false);
            return Response.FromValue(ListGroupReferenceResult.FromResponse(response), response);
        }

        /// <summary> List all dynamic person groups a person has been referenced by in person directory. </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// * Dynamic person groups are stored in alphabetical order of dynamic person group id created in PersonDirectory DynamicPersonGroup - Create.
        /// * "start" parameter (string, optional) is a id value that returned entries have larger ids by string comparison. "start" set to empty to indicate return from the first item.
        /// * "top" parameter (int, optional) specifies the number of entries to return. A maximal of 1000 entries can be returned in one call. To fetch more, you can specify "start" with the last returned entry's personId of the current call.
        ///
        /// &gt; [!TIP]
        /// &gt; For example, total 5 items with their id: "itemId1", ..., "itemId5".
        /// &gt; * "start=&amp;top=" will return all 5 items.
        /// &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetDynamicPersonGroupReferences(string,string,int?,CancellationToken)']/*" />
        public virtual Response<ListGroupReferenceResult> GetDynamicPersonGroupReferences(string personId, string start = null, int? top = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetDynamicPersonGroupReferences(personId, start, top, context);
            return Response.FromValue(ListGroupReferenceResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] List all dynamic person groups a person has been referenced by in person directory.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDynamicPersonGroupReferencesAsync(string,string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetDynamicPersonGroupReferencesAsync(string,string,int?,RequestContext)']/*" />
        public virtual async Task<Response> GetDynamicPersonGroupReferencesAsync(string personId, string start, int? top, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetDynamicPersonGroupReferences");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDynamicPersonGroupReferencesRequest(personId, start, top, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] List all dynamic person groups a person has been referenced by in person directory.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDynamicPersonGroupReferences(string,string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetDynamicPersonGroupReferences(string,string,int?,RequestContext)']/*" />
        public virtual Response GetDynamicPersonGroupReferences(string personId, string start, int? top, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetDynamicPersonGroupReferences");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDynamicPersonGroupReferencesRequest(personId, start, top, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Add a face to a person (see PersonDirectory Person - Create) for face identification or verification. </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. </param>
        /// <param name="url"> URL of input image. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> or <paramref name="url"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// To deal with an image containing multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature(s) will be stored on server until PersonDirectory Person - Delete Face or PersonDirectory Person - Delete is called.
        ///
        /// Note persistedFaceId is different from faceId generated by Face - Detect.
        ///
        /// * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        /// * Each person entry can hold up to 248 faces.
        /// * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
        /// * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from Face - Detect, there's no guarantee to detect and add the face successfully.
        /// * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
        /// * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
        /// * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to https://learn.microsoft.com/en-us/azure/ai-services/computer-vision/how-to/specify-detection-model
        ///   * 'detection_01': The default detection model for PersonDirectory Person - Add Face. Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected.
        ///   * 'detection_02': Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces.
        ///   * 'detection_03': Detection model released in 2021 February with improved accuracy especially on small faces.
        ///
        /// * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel.
        /// * This is a long running operation. Use Response Header "Operation-Location" to determine when the AddFace operation has successfully propagated for future requests to Face - Identify. For further information about Operation-Locations see Operations - Get Status.
        /// </remarks>
        internal virtual async Task<Response<AddFaceResult>> AddPersonFaceFromUrlAsync(string personId, FaceRecognitionModel recognitionModel, Uri url, string targetFace = null, FaceDetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNull(url, nameof(url));

            RequestContext context = FromCancellationToken(cancellationToken);
            AddPersonFaceFromUrlRequest addPersonFaceFromUrlRequest = new AddPersonFaceFromUrlRequest(url);
            Response response = await AddPersonFaceFromUrlAsync(personId, recognitionModel.ToString(), addPersonFaceFromUrlRequest.ToRequestContent(), targetFace, detectionModel?.ToString(), userData, context).ConfigureAwait(false);
            return Response.FromValue(AddFaceResult.FromResponse(response), response);
        }

        /// <summary> Add a face to a person (see PersonDirectory Person - Create) for face identification or verification. </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. </param>
        /// <param name="url"> URL of input image. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> or <paramref name="url"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// To deal with an image containing multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature(s) will be stored on server until PersonDirectory Person - Delete Face or PersonDirectory Person - Delete is called.
        ///
        /// Note persistedFaceId is different from faceId generated by Face - Detect.
        ///
        /// * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        /// * Each person entry can hold up to 248 faces.
        /// * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
        /// * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from Face - Detect, there's no guarantee to detect and add the face successfully.
        /// * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
        /// * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
        /// * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to https://learn.microsoft.com/en-us/azure/ai-services/computer-vision/how-to/specify-detection-model
        ///   * 'detection_01': The default detection model for PersonDirectory Person - Add Face. Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected.
        ///   * 'detection_02': Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces.
        ///   * 'detection_03': Detection model released in 2021 February with improved accuracy especially on small faces.
        ///
        /// * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel.
        /// * This is a long running operation. Use Response Header "Operation-Location" to determine when the AddFace operation has successfully propagated for future requests to Face - Identify. For further information about Operation-Locations see Operations - Get Status.
        /// </remarks>
        internal virtual Response<AddFaceResult> AddPersonFaceFromUrl(string personId, FaceRecognitionModel recognitionModel, Uri url, string targetFace = null, FaceDetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNull(url, nameof(url));

            RequestContext context = FromCancellationToken(cancellationToken);
            AddPersonFaceFromUrlRequest addPersonFaceFromUrlRequest = new AddPersonFaceFromUrlRequest(url);
            Response response = AddPersonFaceFromUrl(personId, recognitionModel.ToString(), addPersonFaceFromUrlRequest.ToRequestContent(), targetFace, detectionModel?.ToString(), userData, context);
            return Response.FromValue(AddFaceResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Add a face to a person (see PersonDirectory Person - Create) for face identification or verification.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddPersonFaceFromUrlAsync(string,FaceRecognitionModel,Uri,string,FaceDetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/>, <paramref name="recognitionModel"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> or <paramref name="recognitionModel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        internal virtual async Task<Response> AddPersonFaceFromUrlAsync(string personId, string recognitionModel, RequestContent content, string targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNullOrEmpty(recognitionModel, nameof(recognitionModel));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.AddPersonFaceFromUrl");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddPersonFaceFromUrlRequest(personId, recognitionModel, content, targetFace, detectionModel, userData, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Add a face to a person (see PersonDirectory Person - Create) for face identification or verification.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddPersonFaceFromUrl(string,FaceRecognitionModel,Uri,string,FaceDetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/>, <paramref name="recognitionModel"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> or <paramref name="recognitionModel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        internal virtual Response AddPersonFaceFromUrl(string personId, string recognitionModel, RequestContent content, string targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNullOrEmpty(recognitionModel, nameof(recognitionModel));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.AddPersonFaceFromUrl");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddPersonFaceFromUrlRequest(personId, recognitionModel, content, targetFace, detectionModel, userData, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Add a face to a person (see PersonDirectory Person - Create) for face identification or verification. </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. </param>
        /// <param name="imageContent"> The image to be analyzed. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> or <paramref name="imageContent"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// To deal with an image containing multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature(s) will be stored on server until PersonDirectory Person - Delete Face or PersonDirectory Person - Delete is called.
        ///
        /// Note persistedFaceId is different from faceId generated by Face - Detect.
        ///
        /// * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        /// * Each person entry can hold up to 248 faces.
        /// * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
        /// * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from Face - Detect, there's no guarantee to detect and add the face successfully.
        /// * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
        /// * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
        /// * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to https://learn.microsoft.com/en-us/azure/ai-services/computer-vision/how-to/specify-detection-model
        ///   * 'detection_01': The default detection model for PersonDirectory Person - Add Face. Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected.
        ///   * 'detection_02': Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces.
        ///   * 'detection_03': Detection model released in 2021 February with improved accuracy especially on small faces.
        ///
        /// * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel.
        /// * This is a long running operation. Use Response Header "Operation-Location" to determine when the AddFace operation has successfully propagated for future requests to Face - Identify. For further information about Operation-Locations see Operations - Get Status.
        /// </remarks>
        internal virtual async Task<Response<AddFaceResult>> AddPersonFaceAsync(string personId, FaceRecognitionModel recognitionModel, BinaryData imageContent, string targetFace = null, FaceDetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNull(imageContent, nameof(imageContent));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = imageContent;
            Response response = await AddPersonFaceAsync(personId, recognitionModel.ToString(), content, targetFace, detectionModel?.ToString(), userData, context).ConfigureAwait(false);
            return Response.FromValue(AddFaceResult.FromResponse(response), response);
        }

        /// <summary> Add a face to a person (see PersonDirectory Person - Create) for face identification or verification. </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. </param>
        /// <param name="imageContent"> The image to be analyzed. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> or <paramref name="imageContent"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// To deal with an image containing multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature(s) will be stored on server until PersonDirectory Person - Delete Face or PersonDirectory Person - Delete is called.
        ///
        /// Note persistedFaceId is different from faceId generated by Face - Detect.
        ///
        /// * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        /// * Each person entry can hold up to 248 faces.
        /// * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
        /// * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from Face - Detect, there's no guarantee to detect and add the face successfully.
        /// * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
        /// * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
        /// * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to https://learn.microsoft.com/en-us/azure/ai-services/computer-vision/how-to/specify-detection-model
        ///   * 'detection_01': The default detection model for PersonDirectory Person - Add Face. Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected.
        ///   * 'detection_02': Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces.
        ///   * 'detection_03': Detection model released in 2021 February with improved accuracy especially on small faces.
        ///
        /// * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel.
        /// * This is a long running operation. Use Response Header "Operation-Location" to determine when the AddFace operation has successfully propagated for future requests to Face - Identify. For further information about Operation-Locations see Operations - Get Status.
        /// </remarks>
        internal virtual Response<AddFaceResult> AddPersonFace(string personId, FaceRecognitionModel recognitionModel, BinaryData imageContent, string targetFace = null, FaceDetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNull(imageContent, nameof(imageContent));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = imageContent;
            Response response = AddPersonFace(personId, recognitionModel.ToString(), content, targetFace, detectionModel?.ToString(), userData, context);
            return Response.FromValue(AddFaceResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Add a face to a person (see PersonDirectory Person - Create) for face identification or verification.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddPersonFaceAsync(string,FaceRecognitionModel,BinaryData,string,FaceDetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/>, <paramref name="recognitionModel"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> or <paramref name="recognitionModel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        internal virtual async Task<Response> AddPersonFaceAsync(string personId, string recognitionModel, RequestContent content, string targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNullOrEmpty(recognitionModel, nameof(recognitionModel));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.AddPersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddPersonFaceRequest(personId, recognitionModel, content, targetFace, detectionModel, userData, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Add a face to a person (see PersonDirectory Person - Create) for face identification or verification.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddPersonFace(string,FaceRecognitionModel,BinaryData,string,FaceDetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/>, <paramref name="recognitionModel"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> or <paramref name="recognitionModel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        internal virtual Response AddPersonFace(string personId, string recognitionModel, RequestContent content, string targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNullOrEmpty(recognitionModel, nameof(recognitionModel));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.AddPersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddPersonFaceRequest(personId, recognitionModel, content, targetFace, detectionModel, userData, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieve person face information. The persisted person face is specified by its personId. recognitionModel, and persistedFaceId. </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> or <paramref name="persistedFaceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonFaceAsync(string,FaceRecognitionModel,string,CancellationToken)']/*" />
        public virtual async Task<Response<PersonDirectoryFace>> GetPersonFaceAsync(string personId, FaceRecognitionModel recognitionModel, string persistedFaceId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNullOrEmpty(persistedFaceId, nameof(persistedFaceId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetPersonFaceAsync(personId, recognitionModel.ToString(), persistedFaceId, context).ConfigureAwait(false);
            return Response.FromValue(PersonDirectoryFace.FromResponse(response), response);
        }

        /// <summary> Retrieve person face information. The persisted person face is specified by its personId. recognitionModel, and persistedFaceId. </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> or <paramref name="persistedFaceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonFace(string,FaceRecognitionModel,string,CancellationToken)']/*" />
        public virtual Response<PersonDirectoryFace> GetPersonFace(string personId, FaceRecognitionModel recognitionModel, string persistedFaceId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNullOrEmpty(persistedFaceId, nameof(persistedFaceId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetPersonFace(personId, recognitionModel.ToString(), persistedFaceId, context);
            return Response.FromValue(PersonDirectoryFace.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Retrieve person face information. The persisted person face is specified by its personId. recognitionModel, and persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPersonFaceAsync(string,FaceRecognitionModel,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/>, <paramref name="recognitionModel"/> or <paramref name="persistedFaceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/>, <paramref name="recognitionModel"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonFaceAsync(string,string,string,RequestContext)']/*" />
        public virtual async Task<Response> GetPersonFaceAsync(string personId, string recognitionModel, string persistedFaceId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNullOrEmpty(recognitionModel, nameof(recognitionModel));
            Argument.AssertNotNullOrEmpty(persistedFaceId, nameof(persistedFaceId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetPersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPersonFaceRequest(personId, recognitionModel, persistedFaceId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Retrieve person face information. The persisted person face is specified by its personId. recognitionModel, and persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPersonFace(string,FaceRecognitionModel,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/>, <paramref name="recognitionModel"/> or <paramref name="persistedFaceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/>, <paramref name="recognitionModel"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonFace(string,string,string,RequestContext)']/*" />
        public virtual Response GetPersonFace(string personId, string recognitionModel, string persistedFaceId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNullOrEmpty(recognitionModel, nameof(recognitionModel));
            Argument.AssertNotNullOrEmpty(persistedFaceId, nameof(persistedFaceId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetPersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPersonFaceRequest(personId, recognitionModel, persistedFaceId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update a person persisted face's userData field.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/>, <paramref name="recognitionModel"/>, <paramref name="persistedFaceId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/>, <paramref name="recognitionModel"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdatePersonFaceAsync(string,string,string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> UpdatePersonFaceAsync(string personId, string recognitionModel, string persistedFaceId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNullOrEmpty(recognitionModel, nameof(recognitionModel));
            Argument.AssertNotNullOrEmpty(persistedFaceId, nameof(persistedFaceId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdatePersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdatePersonFaceRequest(personId, recognitionModel, persistedFaceId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update a person persisted face's userData field.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/>, <paramref name="recognitionModel"/>, <paramref name="persistedFaceId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/>, <paramref name="recognitionModel"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdatePersonFace(string,string,string,RequestContent,RequestContext)']/*" />
        public virtual Response UpdatePersonFace(string personId, string recognitionModel, string persistedFaceId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNullOrEmpty(recognitionModel, nameof(recognitionModel));
            Argument.AssertNotNullOrEmpty(persistedFaceId, nameof(persistedFaceId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdatePersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdatePersonFaceRequest(personId, recognitionModel, persistedFaceId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieve a person's persistedFaceIds representing the registered person face feature(s). </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonFacesAsync(string,FaceRecognitionModel,CancellationToken)']/*" />
        public virtual async Task<Response<ListFaceResult>> GetPersonFacesAsync(string personId, FaceRecognitionModel recognitionModel, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetPersonFacesAsync(personId, recognitionModel.ToString(), context).ConfigureAwait(false);
            return Response.FromValue(ListFaceResult.FromResponse(response), response);
        }

        /// <summary> Retrieve a person's persistedFaceIds representing the registered person face feature(s). </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonFaces(string,FaceRecognitionModel,CancellationToken)']/*" />
        public virtual Response<ListFaceResult> GetPersonFaces(string personId, FaceRecognitionModel recognitionModel, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetPersonFaces(personId, recognitionModel.ToString(), context);
            return Response.FromValue(ListFaceResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Retrieve a person's persistedFaceIds representing the registered person face feature(s).
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPersonFacesAsync(string,FaceRecognitionModel,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> or <paramref name="recognitionModel"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> or <paramref name="recognitionModel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonFacesAsync(string,string,RequestContext)']/*" />
        public virtual async Task<Response> GetPersonFacesAsync(string personId, string recognitionModel, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNullOrEmpty(recognitionModel, nameof(recognitionModel));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetPersonFaces");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPersonFacesRequest(personId, recognitionModel, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Retrieve a person's persistedFaceIds representing the registered person face feature(s).
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPersonFaces(string,FaceRecognitionModel,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> or <paramref name="recognitionModel"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> or <paramref name="recognitionModel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonFaces(string,string,RequestContext)']/*" />
        public virtual Response GetPersonFaces(string personId, string recognitionModel, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNullOrEmpty(recognitionModel, nameof(recognitionModel));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetPersonFaces");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPersonFacesRequest(personId, recognitionModel, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Creates a new dynamic person group with specified dynamicPersonGroupId, name, and user-provided userData. </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="resource"> The resource instance. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> or <paramref name="resource"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// A dynamic person group is a container that references PersonDirectory Person - Create. After creation, use PersonDirectory DynamicPersonGroup - Update to add or remove persons into the dynamic person group. DynamicPersonGroup and UserData will be stored on server until PersonDirectory DynamicPersonGroup - Delete is called. Use Face - Identify with the dynamicPersonGroupId parameter to identify against persons.
        ///
        /// No image will be stored. Only the person's extracted face feature(s) and userData will be stored on server until PersonDirectory Person - Delete or PersonDirectory Person - Delete Face is called.
        ///
        /// 'recognitionModel' does not need to be specified with dynamic person groups. Dynamic person groups are references to PersonDirectory Person - Create and therefore work with most all 'recognitionModels'. The faceId's provided during Face - Identify determine the 'recognitionModel' used.
        /// </remarks>
        internal virtual async Task<Response> CreateDynamicPersonGroupAsync(string dynamicPersonGroupId, CreateDynamicPersonGroupContent resource, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));
            Argument.AssertNotNull(resource, nameof(resource));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = resource.ToRequestContent();
            Response response = await CreateDynamicPersonGroupAsync(dynamicPersonGroupId, content, context).ConfigureAwait(false);
            return response;
        }

        /// <summary> Creates a new dynamic person group with specified dynamicPersonGroupId, name, and user-provided userData. </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="resource"> The resource instance. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> or <paramref name="resource"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// A dynamic person group is a container that references PersonDirectory Person - Create. After creation, use PersonDirectory DynamicPersonGroup - Update to add or remove persons into the dynamic person group. DynamicPersonGroup and UserData will be stored on server until PersonDirectory DynamicPersonGroup - Delete is called. Use Face - Identify with the dynamicPersonGroupId parameter to identify against persons.
        ///
        /// No image will be stored. Only the person's extracted face feature(s) and userData will be stored on server until PersonDirectory Person - Delete or PersonDirectory Person - Delete Face is called.
        ///
        /// 'recognitionModel' does not need to be specified with dynamic person groups. Dynamic person groups are references to PersonDirectory Person - Create and therefore work with most all 'recognitionModels'. The faceId's provided during Face - Identify determine the 'recognitionModel' used.
        /// </remarks>
        internal virtual Response CreateDynamicPersonGroup(string dynamicPersonGroupId, CreateDynamicPersonGroupContent resource, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));
            Argument.AssertNotNull(resource, nameof(resource));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = resource.ToRequestContent();
            Response response = CreateDynamicPersonGroup(dynamicPersonGroupId, content, context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] Creates a new dynamic person group with specified dynamicPersonGroupId, name, and user-provided userData.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateDynamicPersonGroupAsync(string,CreateDynamicPersonGroupContent,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        internal virtual async Task<Response> CreateDynamicPersonGroupAsync(string dynamicPersonGroupId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.CreateDynamicPersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateDynamicPersonGroupRequest(dynamicPersonGroupId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Creates a new dynamic person group with specified dynamicPersonGroupId, name, and user-provided userData.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateDynamicPersonGroup(string,CreateDynamicPersonGroupContent,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        internal virtual Response CreateDynamicPersonGroup(string dynamicPersonGroupId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.CreateDynamicPersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateDynamicPersonGroupRequest(dynamicPersonGroupId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieve the information of a dynamic person group, including its name and userData. </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> This API returns dynamic person group information only, use PersonDirectory DynamicPersonGroup - List Persons instead to retrieve person information under the dynamic person group. </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetDynamicPersonGroupAsync(string,CancellationToken)']/*" />
        public virtual async Task<Response<DynamicPersonGroup>> GetDynamicPersonGroupAsync(string dynamicPersonGroupId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetDynamicPersonGroupAsync(dynamicPersonGroupId, context).ConfigureAwait(false);
            return Response.FromValue(DynamicPersonGroup.FromResponse(response), response);
        }

        /// <summary> Retrieve the information of a dynamic person group, including its name and userData. </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> This API returns dynamic person group information only, use PersonDirectory DynamicPersonGroup - List Persons instead to retrieve person information under the dynamic person group. </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetDynamicPersonGroup(string,CancellationToken)']/*" />
        public virtual Response<DynamicPersonGroup> GetDynamicPersonGroup(string dynamicPersonGroupId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetDynamicPersonGroup(dynamicPersonGroupId, context);
            return Response.FromValue(DynamicPersonGroup.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Retrieve the information of a dynamic person group, including its name and userData.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDynamicPersonGroupAsync(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetDynamicPersonGroupAsync(string,RequestContext)']/*" />
        public virtual async Task<Response> GetDynamicPersonGroupAsync(string dynamicPersonGroupId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetDynamicPersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDynamicPersonGroupRequest(dynamicPersonGroupId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Retrieve the information of a dynamic person group, including its name and userData.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDynamicPersonGroup(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetDynamicPersonGroup(string,RequestContext)']/*" />
        public virtual Response GetDynamicPersonGroup(string dynamicPersonGroupId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetDynamicPersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDynamicPersonGroupRequest(dynamicPersonGroupId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update an existing dynamic person group name, userData, add, or remove persons.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        internal virtual async Task<Response> UpdateDynamicPersonGroupAsync(string dynamicPersonGroupId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdateDynamicPersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateDynamicPersonGroupRequest(dynamicPersonGroupId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update an existing dynamic person group name, userData, add, or remove persons.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        internal virtual Response UpdateDynamicPersonGroup(string dynamicPersonGroupId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdateDynamicPersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateDynamicPersonGroupRequest(dynamicPersonGroupId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> List all existing dynamic person groups by dynamicPersonGroupId along with name and userData. </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks>
        /// * Dynamic person groups are stored in alphabetical order of dynamicPersonGroupId.
        /// * "start" parameter (string, optional) is a id value that returned entries have larger ids by string comparison. "start" set to empty to indicate return from the first item.
        /// * "top" parameter (int, optional) specifies the number of entries to return. A maximal of 1000 entries can be returned in one call. To fetch more, you can specify "start" with the last returned entry's personId of the current call.
        ///
        /// &gt; [!TIP]
        /// &gt; For example, total 5 items with their id: "itemId1", ..., "itemId5".
        /// &gt; * "start=&amp;top=" will return all 5 items.
        /// &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetDynamicPersonGroupsAsync(string,int?,CancellationToken)']/*" />
        public virtual async Task<Response<IReadOnlyList<DynamicPersonGroup>>> GetDynamicPersonGroupsAsync(string start = null, int? top = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetDynamicPersonGroupsAsync(start, top, context).ConfigureAwait(false);
            IReadOnlyList<DynamicPersonGroup> value = default;
            using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
            List<DynamicPersonGroup> array = new List<DynamicPersonGroup>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(DynamicPersonGroup.DeserializeDynamicPersonGroup(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary> List all existing dynamic person groups by dynamicPersonGroupId along with name and userData. </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks>
        /// * Dynamic person groups are stored in alphabetical order of dynamicPersonGroupId.
        /// * "start" parameter (string, optional) is a id value that returned entries have larger ids by string comparison. "start" set to empty to indicate return from the first item.
        /// * "top" parameter (int, optional) specifies the number of entries to return. A maximal of 1000 entries can be returned in one call. To fetch more, you can specify "start" with the last returned entry's personId of the current call.
        ///
        /// &gt; [!TIP]
        /// &gt; For example, total 5 items with their id: "itemId1", ..., "itemId5".
        /// &gt; * "start=&amp;top=" will return all 5 items.
        /// &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetDynamicPersonGroups(string,int?,CancellationToken)']/*" />
        public virtual Response<IReadOnlyList<DynamicPersonGroup>> GetDynamicPersonGroups(string start = null, int? top = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetDynamicPersonGroups(start, top, context);
            IReadOnlyList<DynamicPersonGroup> value = default;
            using var document = JsonDocument.Parse(response.ContentStream);
            List<DynamicPersonGroup> array = new List<DynamicPersonGroup>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(DynamicPersonGroup.DeserializeDynamicPersonGroup(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// [Protocol Method] List all existing dynamic person groups by dynamicPersonGroupId along with name and userData.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDynamicPersonGroupsAsync(string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetDynamicPersonGroupsAsync(string,int?,RequestContext)']/*" />
        public virtual async Task<Response> GetDynamicPersonGroupsAsync(string start, int? top, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetDynamicPersonGroups");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDynamicPersonGroupsRequest(start, top, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] List all existing dynamic person groups by dynamicPersonGroupId along with name and userData.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDynamicPersonGroups(string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetDynamicPersonGroups(string,int?,RequestContext)']/*" />
        public virtual Response GetDynamicPersonGroups(string start, int? top, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetDynamicPersonGroups");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDynamicPersonGroupsRequest(start, top, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> List all persons in the specified dynamic person group. </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// * Persons are stored in alphabetical order of personId created in PersonDirectory Person - Create.
        /// * "start" parameter (string, optional) is a id value that returned entries have larger ids by string comparison. "start" set to empty to indicate return from the first item.
        /// * "top" parameter (int, optional) specifies the number of entries to return. A maximal of 1000 entries can be returned in one call. To fetch more, you can specify "start" with the last returned entry's personId of the current call.
        ///
        /// &gt; [!TIP]
        /// &gt; For example, total 5 items with their id: "itemId1", ..., "itemId5".
        /// &gt; * "start=&amp;top=" will return all 5 items.
        /// &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetDynamicPersonGroupPersonsAsync(string,string,int?,CancellationToken)']/*" />
        public virtual async Task<Response<ListPersonResult>> GetDynamicPersonGroupPersonsAsync(string dynamicPersonGroupId, string start = null, int? top = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetDynamicPersonGroupPersonsAsync(dynamicPersonGroupId, start, top, context).ConfigureAwait(false);
            return Response.FromValue(ListPersonResult.FromResponse(response), response);
        }

        /// <summary> List all persons in the specified dynamic person group. </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// * Persons are stored in alphabetical order of personId created in PersonDirectory Person - Create.
        /// * "start" parameter (string, optional) is a id value that returned entries have larger ids by string comparison. "start" set to empty to indicate return from the first item.
        /// * "top" parameter (int, optional) specifies the number of entries to return. A maximal of 1000 entries can be returned in one call. To fetch more, you can specify "start" with the last returned entry's personId of the current call.
        ///
        /// &gt; [!TIP]
        /// &gt; For example, total 5 items with their id: "itemId1", ..., "itemId5".
        /// &gt; * "start=&amp;top=" will return all 5 items.
        /// &gt; * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt; * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetDynamicPersonGroupPersons(string,string,int?,CancellationToken)']/*" />
        public virtual Response<ListPersonResult> GetDynamicPersonGroupPersons(string dynamicPersonGroupId, string start = null, int? top = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetDynamicPersonGroupPersons(dynamicPersonGroupId, start, top, context);
            return Response.FromValue(ListPersonResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] List all persons in the specified dynamic person group.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDynamicPersonGroupPersonsAsync(string,string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetDynamicPersonGroupPersonsAsync(string,string,int?,RequestContext)']/*" />
        public virtual async Task<Response> GetDynamicPersonGroupPersonsAsync(string dynamicPersonGroupId, string start, int? top, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetDynamicPersonGroupPersons");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDynamicPersonGroupPersonsRequest(dynamicPersonGroupId, start, top, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] List all persons in the specified dynamic person group.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDynamicPersonGroupPersons(string,string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetDynamicPersonGroupPersons(string,string,int?,RequestContext)']/*" />
        public virtual Response GetDynamicPersonGroupPersons(string dynamicPersonGroupId, string start, int? top, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetDynamicPersonGroupPersons");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDynamicPersonGroupPersonsRequest(dynamicPersonGroupId, start, top, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Submit a large face list training task.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='TrainLargeFaceListAsync(WaitUntil,string,RequestContext)']/*" />
        public virtual async Task<Operation> TrainLargeFaceListAsync(WaitUntil waitUntil, string largeFaceListId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.TrainLargeFaceList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateTrainLargeFaceListRequest(largeFaceListId, context);
                return await ProtocolOperationHelpers.ProcessMessageWithoutResponseValueAsync(_pipeline, message, ClientDiagnostics, "FaceAdministrationClient.TrainLargeFaceList", OperationFinalStateVia.OperationLocation, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Submit a large face list training task.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='TrainLargeFaceList(WaitUntil,string,RequestContext)']/*" />
        public virtual Operation TrainLargeFaceList(WaitUntil waitUntil, string largeFaceListId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.TrainLargeFaceList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateTrainLargeFaceListRequest(largeFaceListId, context);
                return ProtocolOperationHelpers.ProcessMessageWithoutResponseValue(_pipeline, message, ClientDiagnostics, "FaceAdministrationClient.TrainLargeFaceList", OperationFinalStateVia.OperationLocation, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Submit a person group training task. Training is a crucial step that only a trained person group can be used by Face - Identify.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='TrainPersonGroupAsync(WaitUntil,string,RequestContext)']/*" />
        public virtual async Task<Operation> TrainPersonGroupAsync(WaitUntil waitUntil, string personGroupId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.TrainPersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateTrainPersonGroupRequest(personGroupId, context);
                return await ProtocolOperationHelpers.ProcessMessageWithoutResponseValueAsync(_pipeline, message, ClientDiagnostics, "FaceAdministrationClient.TrainPersonGroup", OperationFinalStateVia.OperationLocation, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Submit a person group training task. Training is a crucial step that only a trained person group can be used by Face - Identify.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='TrainPersonGroup(WaitUntil,string,RequestContext)']/*" />
        public virtual Operation TrainPersonGroup(WaitUntil waitUntil, string personGroupId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.TrainPersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateTrainPersonGroupRequest(personGroupId, context);
                return ProtocolOperationHelpers.ProcessMessageWithoutResponseValue(_pipeline, message, ClientDiagnostics, "FaceAdministrationClient.TrainPersonGroup", OperationFinalStateVia.OperationLocation, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Submit a large person group training task. Training is a crucial step that only a trained large person group can be used by Face - Identify.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='TrainLargePersonGroupAsync(WaitUntil,string,RequestContext)']/*" />
        public virtual async Task<Operation> TrainLargePersonGroupAsync(WaitUntil waitUntil, string largePersonGroupId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.TrainLargePersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateTrainLargePersonGroupRequest(largePersonGroupId, context);
                return await ProtocolOperationHelpers.ProcessMessageWithoutResponseValueAsync(_pipeline, message, ClientDiagnostics, "FaceAdministrationClient.TrainLargePersonGroup", OperationFinalStateVia.OperationLocation, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Submit a large person group training task. Training is a crucial step that only a trained large person group can be used by Face - Identify.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='TrainLargePersonGroup(WaitUntil,string,RequestContext)']/*" />
        public virtual Operation TrainLargePersonGroup(WaitUntil waitUntil, string largePersonGroupId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.TrainLargePersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateTrainLargePersonGroupRequest(largePersonGroupId, context);
                return ProtocolOperationHelpers.ProcessMessageWithoutResponseValue(_pipeline, message, ClientDiagnostics, "FaceAdministrationClient.TrainLargePersonGroup", OperationFinalStateVia.OperationLocation, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete an existing person from person directory. The persistedFaceId(s), userData, person name and face feature(s) in the person entry will all be deleted.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeletePersonAsync(WaitUntil,string,RequestContext)']/*" />
        public virtual async Task<Operation> DeletePersonAsync(WaitUntil waitUntil, string personId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeletePerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeletePersonRequest(personId, context);
                return await ProtocolOperationHelpers.ProcessMessageWithoutResponseValueAsync(_pipeline, message, ClientDiagnostics, "FaceAdministrationClient.DeletePerson", OperationFinalStateVia.OperationLocation, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete an existing person from person directory. The persistedFaceId(s), userData, person name and face feature(s) in the person entry will all be deleted.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeletePerson(WaitUntil,string,RequestContext)']/*" />
        public virtual Operation DeletePerson(WaitUntil waitUntil, string personId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeletePerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeletePersonRequest(personId, context);
                return ProtocolOperationHelpers.ProcessMessageWithoutResponseValue(_pipeline, message, ClientDiagnostics, "FaceAdministrationClient.DeletePerson", OperationFinalStateVia.OperationLocation, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete a face from a person in person directory by specified personId and persistedFaceId. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> or <paramref name="persistedFaceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel. </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeletePersonFaceAsync(WaitUntil,string,FaceRecognitionModel,string,CancellationToken)']/*" />
        public virtual async Task<Operation> DeletePersonFaceAsync(WaitUntil waitUntil, string personId, FaceRecognitionModel recognitionModel, string persistedFaceId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNullOrEmpty(persistedFaceId, nameof(persistedFaceId));

            RequestContext context = FromCancellationToken(cancellationToken);
            return await DeletePersonFaceAsync(waitUntil, personId, recognitionModel.ToString(), persistedFaceId, context).ConfigureAwait(false);
        }

        /// <summary> Delete a face from a person in person directory by specified personId and persistedFaceId. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> or <paramref name="persistedFaceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel. </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeletePersonFace(WaitUntil,string,FaceRecognitionModel,string,CancellationToken)']/*" />
        public virtual Operation DeletePersonFace(WaitUntil waitUntil, string personId, FaceRecognitionModel recognitionModel, string persistedFaceId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNullOrEmpty(persistedFaceId, nameof(persistedFaceId));

            RequestContext context = FromCancellationToken(cancellationToken);
            return DeletePersonFace(waitUntil, personId, recognitionModel.ToString(), persistedFaceId, context);
        }

        /// <summary>
        /// [Protocol Method] Delete a face from a person in person directory by specified personId and persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="DeletePersonFaceAsync(WaitUntil,string,FaceRecognitionModel,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/>, <paramref name="recognitionModel"/> or <paramref name="persistedFaceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/>, <paramref name="recognitionModel"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeletePersonFaceAsync(WaitUntil,string,string,string,RequestContext)']/*" />
        public virtual async Task<Operation> DeletePersonFaceAsync(WaitUntil waitUntil, string personId, string recognitionModel, string persistedFaceId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNullOrEmpty(recognitionModel, nameof(recognitionModel));
            Argument.AssertNotNullOrEmpty(persistedFaceId, nameof(persistedFaceId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeletePersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeletePersonFaceRequest(personId, recognitionModel, persistedFaceId, context);
                return await ProtocolOperationHelpers.ProcessMessageWithoutResponseValueAsync(_pipeline, message, ClientDiagnostics, "FaceAdministrationClient.DeletePersonFace", OperationFinalStateVia.OperationLocation, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Delete a face from a person in person directory by specified personId and persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="DeletePersonFace(WaitUntil,string,FaceRecognitionModel,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/>, <paramref name="recognitionModel"/> or <paramref name="persistedFaceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/>, <paramref name="recognitionModel"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeletePersonFace(WaitUntil,string,string,string,RequestContext)']/*" />
        public virtual Operation DeletePersonFace(WaitUntil waitUntil, string personId, string recognitionModel, string persistedFaceId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personId, nameof(personId));
            Argument.AssertNotNullOrEmpty(recognitionModel, nameof(recognitionModel));
            Argument.AssertNotNullOrEmpty(persistedFaceId, nameof(persistedFaceId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeletePersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeletePersonFaceRequest(personId, recognitionModel, persistedFaceId, context);
                return ProtocolOperationHelpers.ProcessMessageWithoutResponseValue(_pipeline, message, ClientDiagnostics, "FaceAdministrationClient.DeletePersonFace", OperationFinalStateVia.OperationLocation, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Deletes an existing dynamic person group with specified dynamicPersonGroupId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeleteDynamicPersonGroupAsync(WaitUntil,string,RequestContext)']/*" />
        public virtual async Task<Operation> DeleteDynamicPersonGroupAsync(WaitUntil waitUntil, string dynamicPersonGroupId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeleteDynamicPersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteDynamicPersonGroupRequest(dynamicPersonGroupId, context);
                return await ProtocolOperationHelpers.ProcessMessageWithoutResponseValueAsync(_pipeline, message, ClientDiagnostics, "FaceAdministrationClient.DeleteDynamicPersonGroup", OperationFinalStateVia.OperationLocation, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Deletes an existing dynamic person group with specified dynamicPersonGroupId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeleteDynamicPersonGroup(WaitUntil,string,RequestContext)']/*" />
        public virtual Operation DeleteDynamicPersonGroup(WaitUntil waitUntil, string dynamicPersonGroupId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeleteDynamicPersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteDynamicPersonGroupRequest(dynamicPersonGroupId, context);
                return ProtocolOperationHelpers.ProcessMessageWithoutResponseValue(_pipeline, message, ClientDiagnostics, "FaceAdministrationClient.DeleteDynamicPersonGroup", OperationFinalStateVia.OperationLocation, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateCreateFaceListRequest(string faceListId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/facelists/", false);
            uri.AppendPath(faceListId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteFaceListRequest(string faceListId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/facelists/", false);
            uri.AppendPath(faceListId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetFaceListRequest(string faceListId, bool? returnRecognitionModel, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/facelists/", false);
            uri.AppendPath(faceListId, true);
            if (returnRecognitionModel != null)
            {
                uri.AppendQuery("returnRecognitionModel", returnRecognitionModel.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateUpdateFaceListRequest(string faceListId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/facelists/", false);
            uri.AppendPath(faceListId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetFaceListsRequest(bool? returnRecognitionModel, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/facelists", false);
            if (returnRecognitionModel != null)
            {
                uri.AppendQuery("returnRecognitionModel", returnRecognitionModel.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateAddFaceListFaceFromUrlRequest(string faceListId, RequestContent content, string targetFace, string detectionModel, string userData, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/facelists/", false);
            uri.AppendPath(faceListId, true);
            uri.AppendPath("/persistedfaces", false);
            if (targetFace != null)
            {
                uri.AppendQuery("targetFace", targetFace, true);
            }
            if (detectionModel != null)
            {
                uri.AppendQuery("detectionModel", detectionModel, true);
            }
            if (userData != null)
            {
                uri.AppendQuery("userData", userData, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateAddFaceListFaceRequest(string faceListId, RequestContent content, string targetFace, string detectionModel, string userData, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/facelists/", false);
            uri.AppendPath(faceListId, true);
            uri.AppendPath("/persistedfaces", false);
            if (targetFace != null)
            {
                uri.AppendQuery("targetFace", targetFace, true);
            }
            if (detectionModel != null)
            {
                uri.AppendQuery("detectionModel", detectionModel, true);
            }
            if (userData != null)
            {
                uri.AppendQuery("userData", userData, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("content-type", "application/octet-stream");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteFaceListFaceRequest(string faceListId, string persistedFaceId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/facelists/", false);
            uri.AppendPath(faceListId, true);
            uri.AppendPath("/persistedfaces/", false);
            uri.AppendPath(persistedFaceId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCreateLargeFaceListRequest(string largeFaceListId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/largefacelists/", false);
            uri.AppendPath(largeFaceListId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteLargeFaceListRequest(string largeFaceListId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/largefacelists/", false);
            uri.AppendPath(largeFaceListId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetLargeFaceListRequest(string largeFaceListId, bool? returnRecognitionModel, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/largefacelists/", false);
            uri.AppendPath(largeFaceListId, true);
            if (returnRecognitionModel != null)
            {
                uri.AppendQuery("returnRecognitionModel", returnRecognitionModel.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateUpdateLargeFaceListRequest(string largeFaceListId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/largefacelists/", false);
            uri.AppendPath(largeFaceListId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetLargeFaceListsRequest(string start, int? top, bool? returnRecognitionModel, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/largefacelists", false);
            if (start != null)
            {
                uri.AppendQuery("start", start, true);
            }
            if (top != null)
            {
                uri.AppendQuery("top", top.Value, true);
            }
            if (returnRecognitionModel != null)
            {
                uri.AppendQuery("returnRecognitionModel", returnRecognitionModel.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetLargeFaceListTrainingStatusRequest(string largeFaceListId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/largefacelists/", false);
            uri.AppendPath(largeFaceListId, true);
            uri.AppendPath("/training", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateTrainLargeFaceListRequest(string largeFaceListId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/largefacelists/", false);
            uri.AppendPath(largeFaceListId, true);
            uri.AppendPath("/train", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateAddLargeFaceListFaceFromUrlRequest(string largeFaceListId, RequestContent content, string targetFace, string detectionModel, string userData, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/largefacelists/", false);
            uri.AppendPath(largeFaceListId, true);
            uri.AppendPath("/persistedfaces", false);
            if (targetFace != null)
            {
                uri.AppendQuery("targetFace", targetFace, true);
            }
            if (detectionModel != null)
            {
                uri.AppendQuery("detectionModel", detectionModel, true);
            }
            if (userData != null)
            {
                uri.AppendQuery("userData", userData, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateAddLargeFaceListFaceRequest(string largeFaceListId, RequestContent content, string targetFace, string detectionModel, string userData, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/largefacelists/", false);
            uri.AppendPath(largeFaceListId, true);
            uri.AppendPath("/persistedfaces", false);
            if (targetFace != null)
            {
                uri.AppendQuery("targetFace", targetFace, true);
            }
            if (detectionModel != null)
            {
                uri.AppendQuery("detectionModel", detectionModel, true);
            }
            if (userData != null)
            {
                uri.AppendQuery("userData", userData, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("content-type", "application/octet-stream");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteLargeFaceListFaceRequest(string largeFaceListId, string persistedFaceId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/largefacelists/", false);
            uri.AppendPath(largeFaceListId, true);
            uri.AppendPath("/persistedfaces/", false);
            uri.AppendPath(persistedFaceId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetLargeFaceListFaceRequest(string largeFaceListId, string persistedFaceId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/largefacelists/", false);
            uri.AppendPath(largeFaceListId, true);
            uri.AppendPath("/persistedfaces/", false);
            uri.AppendPath(persistedFaceId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateUpdateLargeFaceListFaceRequest(string largeFaceListId, string persistedFaceId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/largefacelists/", false);
            uri.AppendPath(largeFaceListId, true);
            uri.AppendPath("/persistedfaces/", false);
            uri.AppendPath(persistedFaceId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetLargeFaceListFacesRequest(string largeFaceListId, string start, int? top, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/largefacelists/", false);
            uri.AppendPath(largeFaceListId, true);
            uri.AppendPath("/persistedfaces", false);
            if (start != null)
            {
                uri.AppendQuery("start", start, true);
            }
            if (top != null)
            {
                uri.AppendQuery("top", top.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCreatePersonGroupRequest(string personGroupId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/persongroups/", false);
            uri.AppendPath(personGroupId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeletePersonGroupRequest(string personGroupId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/persongroups/", false);
            uri.AppendPath(personGroupId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetPersonGroupRequest(string personGroupId, bool? returnRecognitionModel, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/persongroups/", false);
            uri.AppendPath(personGroupId, true);
            if (returnRecognitionModel != null)
            {
                uri.AppendQuery("returnRecognitionModel", returnRecognitionModel.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateUpdatePersonGroupRequest(string personGroupId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/persongroups/", false);
            uri.AppendPath(personGroupId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetPersonGroupsRequest(string start, int? top, bool? returnRecognitionModel, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/persongroups", false);
            if (start != null)
            {
                uri.AppendQuery("start", start, true);
            }
            if (top != null)
            {
                uri.AppendQuery("top", top.Value, true);
            }
            if (returnRecognitionModel != null)
            {
                uri.AppendQuery("returnRecognitionModel", returnRecognitionModel.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetPersonGroupTrainingStatusRequest(string personGroupId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/persongroups/", false);
            uri.AppendPath(personGroupId, true);
            uri.AppendPath("/training", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateTrainPersonGroupRequest(string personGroupId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/persongroups/", false);
            uri.AppendPath(personGroupId, true);
            uri.AppendPath("/train", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCreatePersonGroupPersonRequest(string personGroupId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/persongroups/", false);
            uri.AppendPath(personGroupId, true);
            uri.AppendPath("/persons", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeletePersonGroupPersonRequest(string personGroupId, string personId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/persongroups/", false);
            uri.AppendPath(personGroupId, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetPersonGroupPersonRequest(string personGroupId, string personId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/persongroups/", false);
            uri.AppendPath(personGroupId, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateUpdatePersonGroupPersonRequest(string personGroupId, string personId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/persongroups/", false);
            uri.AppendPath(personGroupId, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetPersonGroupPersonsRequest(string personGroupId, string start, int? top, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/persongroups/", false);
            uri.AppendPath(personGroupId, true);
            uri.AppendPath("/persons", false);
            if (start != null)
            {
                uri.AppendQuery("start", start, true);
            }
            if (top != null)
            {
                uri.AppendQuery("top", top.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateAddPersonGroupPersonFaceFromUrlRequest(string personGroupId, string personId, RequestContent content, string targetFace, string detectionModel, string userData, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/persongroups/", false);
            uri.AppendPath(personGroupId, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/persistedfaces", false);
            if (targetFace != null)
            {
                uri.AppendQuery("targetFace", targetFace, true);
            }
            if (detectionModel != null)
            {
                uri.AppendQuery("detectionModel", detectionModel, true);
            }
            if (userData != null)
            {
                uri.AppendQuery("userData", userData, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateAddPersonGroupPersonFaceRequest(string personGroupId, string personId, RequestContent content, string targetFace, string detectionModel, string userData, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/persongroups/", false);
            uri.AppendPath(personGroupId, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/persistedfaces", false);
            if (targetFace != null)
            {
                uri.AppendQuery("targetFace", targetFace, true);
            }
            if (detectionModel != null)
            {
                uri.AppendQuery("detectionModel", detectionModel, true);
            }
            if (userData != null)
            {
                uri.AppendQuery("userData", userData, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("content-type", "application/octet-stream");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeletePersonGroupPersonFaceRequest(string personGroupId, string personId, string persistedFaceId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/persongroups/", false);
            uri.AppendPath(personGroupId, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/persistedfaces/", false);
            uri.AppendPath(persistedFaceId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetPersonGroupPersonFaceRequest(string personGroupId, string personId, string persistedFaceId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/persongroups/", false);
            uri.AppendPath(personGroupId, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/persistedfaces/", false);
            uri.AppendPath(persistedFaceId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateUpdatePersonGroupPersonFaceRequest(string personGroupId, string personId, string persistedFaceId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/persongroups/", false);
            uri.AppendPath(personGroupId, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/persistedfaces/", false);
            uri.AppendPath(persistedFaceId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateCreateLargePersonGroupRequest(string largePersonGroupId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/largepersongroups/", false);
            uri.AppendPath(largePersonGroupId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteLargePersonGroupRequest(string largePersonGroupId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/largepersongroups/", false);
            uri.AppendPath(largePersonGroupId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetLargePersonGroupRequest(string largePersonGroupId, bool? returnRecognitionModel, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/largepersongroups/", false);
            uri.AppendPath(largePersonGroupId, true);
            if (returnRecognitionModel != null)
            {
                uri.AppendQuery("returnRecognitionModel", returnRecognitionModel.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateUpdateLargePersonGroupRequest(string largePersonGroupId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/largepersongroups/", false);
            uri.AppendPath(largePersonGroupId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetLargePersonGroupsRequest(string start, int? top, bool? returnRecognitionModel, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/largepersongroups", false);
            if (start != null)
            {
                uri.AppendQuery("start", start, true);
            }
            if (top != null)
            {
                uri.AppendQuery("top", top.Value, true);
            }
            if (returnRecognitionModel != null)
            {
                uri.AppendQuery("returnRecognitionModel", returnRecognitionModel.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetLargePersonGroupTrainingStatusRequest(string largePersonGroupId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/largepersongroups/", false);
            uri.AppendPath(largePersonGroupId, true);
            uri.AppendPath("/training", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateTrainLargePersonGroupRequest(string largePersonGroupId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/largepersongroups/", false);
            uri.AppendPath(largePersonGroupId, true);
            uri.AppendPath("/train", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCreateLargePersonGroupPersonRequest(string largePersonGroupId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/largepersongroups/", false);
            uri.AppendPath(largePersonGroupId, true);
            uri.AppendPath("/persons", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteLargePersonGroupPersonRequest(string largePersonGroupId, string personId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/largepersongroups/", false);
            uri.AppendPath(largePersonGroupId, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetLargePersonGroupPersonRequest(string largePersonGroupId, string personId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/largepersongroups/", false);
            uri.AppendPath(largePersonGroupId, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateUpdateLargePersonGroupPersonRequest(string largePersonGroupId, string personId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/largepersongroups/", false);
            uri.AppendPath(largePersonGroupId, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetLargePersonGroupPersonsRequest(string largePersonGroupId, string start, int? top, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/largepersongroups/", false);
            uri.AppendPath(largePersonGroupId, true);
            uri.AppendPath("/persons", false);
            if (start != null)
            {
                uri.AppendQuery("start", start, true);
            }
            if (top != null)
            {
                uri.AppendQuery("top", top.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateAddLargePersonGroupPersonFaceFromUrlRequest(string largePersonGroupId, string personId, RequestContent content, string targetFace, string detectionModel, string userData, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/largepersongroups/", false);
            uri.AppendPath(largePersonGroupId, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/persistedfaces", false);
            if (targetFace != null)
            {
                uri.AppendQuery("targetFace", targetFace, true);
            }
            if (detectionModel != null)
            {
                uri.AppendQuery("detectionModel", detectionModel, true);
            }
            if (userData != null)
            {
                uri.AppendQuery("userData", userData, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateAddLargePersonGroupPersonFaceRequest(string largePersonGroupId, string personId, RequestContent content, string targetFace, string detectionModel, string userData, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/largepersongroups/", false);
            uri.AppendPath(largePersonGroupId, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/persistedfaces", false);
            if (targetFace != null)
            {
                uri.AppendQuery("targetFace", targetFace, true);
            }
            if (detectionModel != null)
            {
                uri.AppendQuery("detectionModel", detectionModel, true);
            }
            if (userData != null)
            {
                uri.AppendQuery("userData", userData, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("content-type", "application/octet-stream");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteLargePersonGroupPersonFaceRequest(string largePersonGroupId, string personId, string persistedFaceId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/largepersongroups/", false);
            uri.AppendPath(largePersonGroupId, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/persistedfaces/", false);
            uri.AppendPath(persistedFaceId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetLargePersonGroupPersonFaceRequest(string largePersonGroupId, string personId, string persistedFaceId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/largepersongroups/", false);
            uri.AppendPath(largePersonGroupId, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/persistedfaces/", false);
            uri.AppendPath(persistedFaceId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateUpdateLargePersonGroupPersonFaceRequest(string largePersonGroupId, string personId, string persistedFaceId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/largepersongroups/", false);
            uri.AppendPath(largePersonGroupId, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/persistedfaces/", false);
            uri.AppendPath(persistedFaceId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateCreatePersonRequest(RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/persons", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeletePersonRequest(string personId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetPersonRequest(string personId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateUpdatePersonRequest(string personId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetPersonsRequest(string start, int? top, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/persons", false);
            if (start != null)
            {
                uri.AppendQuery("start", start, true);
            }
            if (top != null)
            {
                uri.AppendQuery("top", top.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDynamicPersonGroupReferencesRequest(string personId, string start, int? top, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/dynamicPersonGroupReferences", false);
            if (start != null)
            {
                uri.AppendQuery("start", start, true);
            }
            if (top != null)
            {
                uri.AppendQuery("top", top.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateAddPersonFaceFromUrlRequest(string personId, string recognitionModel, RequestContent content, string targetFace, string detectionModel, string userData, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/recognitionModels/", false);
            uri.AppendPath(recognitionModel, true);
            uri.AppendPath("/persistedfaces", false);
            if (targetFace != null)
            {
                uri.AppendQuery("targetFace", targetFace, true);
            }
            if (detectionModel != null)
            {
                uri.AppendQuery("detectionModel", detectionModel, true);
            }
            if (userData != null)
            {
                uri.AppendQuery("userData", userData, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateAddPersonFaceRequest(string personId, string recognitionModel, RequestContent content, string targetFace, string detectionModel, string userData, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/recognitionModels/", false);
            uri.AppendPath(recognitionModel, true);
            uri.AppendPath("/persistedfaces", false);
            if (targetFace != null)
            {
                uri.AppendQuery("targetFace", targetFace, true);
            }
            if (detectionModel != null)
            {
                uri.AppendQuery("detectionModel", detectionModel, true);
            }
            if (userData != null)
            {
                uri.AppendQuery("userData", userData, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("content-type", "application/octet-stream");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeletePersonFaceRequest(string personId, string recognitionModel, string persistedFaceId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/recognitionModels/", false);
            uri.AppendPath(recognitionModel, true);
            uri.AppendPath("/persistedfaces/", false);
            uri.AppendPath(persistedFaceId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetPersonFaceRequest(string personId, string recognitionModel, string persistedFaceId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/recognitionModels/", false);
            uri.AppendPath(recognitionModel, true);
            uri.AppendPath("/persistedfaces/", false);
            uri.AppendPath(persistedFaceId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateUpdatePersonFaceRequest(string personId, string recognitionModel, string persistedFaceId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/recognitionModels/", false);
            uri.AppendPath(recognitionModel, true);
            uri.AppendPath("/persistedfaces/", false);
            uri.AppendPath(persistedFaceId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetPersonFacesRequest(string personId, string recognitionModel, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/recognitionModels/", false);
            uri.AppendPath(recognitionModel, true);
            uri.AppendPath("/persistedfaces", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCreateDynamicPersonGroupRequest(string dynamicPersonGroupId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/dynamicpersongroups/", false);
            uri.AppendPath(dynamicPersonGroupId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteDynamicPersonGroupRequest(string dynamicPersonGroupId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/dynamicpersongroups/", false);
            uri.AppendPath(dynamicPersonGroupId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDynamicPersonGroupRequest(string dynamicPersonGroupId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/dynamicpersongroups/", false);
            uri.AppendPath(dynamicPersonGroupId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateUpdateDynamicPersonGroupRequest(string dynamicPersonGroupId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/dynamicpersongroups/", false);
            uri.AppendPath(dynamicPersonGroupId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetDynamicPersonGroupsRequest(string start, int? top, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/dynamicpersongroups", false);
            if (start != null)
            {
                uri.AppendQuery("start", start, true);
            }
            if (top != null)
            {
                uri.AppendQuery("top", top.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDynamicPersonGroupPersonsRequest(string dynamicPersonGroupId, string start, int? top, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/dynamicpersongroups/", false);
            uri.AppendPath(dynamicPersonGroupId, true);
            uri.AppendPath("/persons", false);
            if (start != null)
            {
                uri.AppendQuery("start", start, true);
            }
            if (top != null)
            {
                uri.AppendQuery("top", top.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        private static RequestContext DefaultRequestContext = new RequestContext();
        internal static RequestContext FromCancellationToken(CancellationToken cancellationToken = default)
        {
            if (!cancellationToken.CanBeCanceled)
            {
                return DefaultRequestContext;
            }

            return new RequestContext() { CancellationToken = cancellationToken };
        }

        private static ResponseClassifier _responseClassifier200;
        private static ResponseClassifier ResponseClassifier200 => _responseClassifier200 ??= new StatusCodeClassifier(stackalloc ushort[] { 200 });
        private static ResponseClassifier _responseClassifier202;
        private static ResponseClassifier ResponseClassifier202 => _responseClassifier202 ??= new StatusCodeClassifier(stackalloc ushort[] { 202 });
        private static ResponseClassifier _responseClassifier200202;
        private static ResponseClassifier ResponseClassifier200202 => _responseClassifier200202 ??= new StatusCodeClassifier(stackalloc ushort[] { 200, 202 });
    }
}
