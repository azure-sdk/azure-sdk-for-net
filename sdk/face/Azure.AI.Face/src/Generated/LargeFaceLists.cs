// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.AI.Face
{
    // Data plane generated sub-client.
    /// <summary> The LargeFaceLists sub-client. </summary>
    public partial class LargeFaceLists
    {
        private const string AuthorizationHeader = "Ocp-Apim-Subscription-Key";
        private readonly AzureKeyCredential _keyCredential;
        private static readonly string[] AuthorizationScopes = new string[] { "https://cognitiveservices.azure.com/.default" };
        private readonly TokenCredential _tokenCredential;
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;
        private readonly string _apiVersion;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of LargeFaceLists for mocking. </summary>
        protected LargeFaceLists()
        {
        }

        /// <summary> Initializes a new instance of LargeFaceLists. </summary>
        /// <param name="clientDiagnostics"> The handler for diagnostic messaging in the client. </param>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="keyCredential"> The key credential to copy. </param>
        /// <param name="tokenCredential"> The token credential to copy. </param>
        /// <param name="endpoint">
        /// Supported Cognitive Services endpoints (protocol and hostname, for example:
        /// https://&lt;resource-name&gt;.cognitiveservices.azure.com).
        /// </param>
        /// <param name="apiVersion"> The API version to use for this operation. </param>
        internal LargeFaceLists(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, AzureKeyCredential keyCredential, TokenCredential tokenCredential, Uri endpoint, string apiVersion)
        {
            ClientDiagnostics = clientDiagnostics;
            _pipeline = pipeline;
            _keyCredential = keyCredential;
            _tokenCredential = tokenCredential;
            _endpoint = endpoint;
            _apiVersion = apiVersion;
        }

        /// <summary> The most basic operation that applies to a resource. </summary>
        /// <param name="largeFaceListId"> ID of the container. </param>
        /// <param name="resource"> The resource instance. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="resource"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/LargeFaceLists.xml" path="doc/members/member[@name='CreateListAsync(string,LargeFaceList,CancellationToken)']/*" />
        public virtual async Task<Response> CreateListAsync(string largeFaceListId, LargeFaceList resource, CancellationToken cancellationToken = default)
        {
            if (largeFaceListId == null)
            {
                throw new ArgumentNullException(nameof(largeFaceListId));
            }
            if (largeFaceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(largeFaceListId));
            }
            if (resource == null)
            {
                throw new ArgumentNullException(nameof(resource));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = resource.ToRequestContent();
            Response response = await CreateListAsync(largeFaceListId, content, context).ConfigureAwait(false);
            return response;
        }

        /// <summary> The most basic operation that applies to a resource. </summary>
        /// <param name="largeFaceListId"> ID of the container. </param>
        /// <param name="resource"> The resource instance. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="resource"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/LargeFaceLists.xml" path="doc/members/member[@name='CreateList(string,LargeFaceList,CancellationToken)']/*" />
        public virtual Response CreateList(string largeFaceListId, LargeFaceList resource, CancellationToken cancellationToken = default)
        {
            if (largeFaceListId == null)
            {
                throw new ArgumentNullException(nameof(largeFaceListId));
            }
            if (largeFaceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(largeFaceListId));
            }
            if (resource == null)
            {
                throw new ArgumentNullException(nameof(resource));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = resource.ToRequestContent();
            Response response = CreateList(largeFaceListId, content, context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] The most basic operation that applies to a resource.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateListAsync(string,LargeFaceList,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> ID of the container. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/LargeFaceLists.xml" path="doc/members/member[@name='CreateListAsync(string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> CreateListAsync(string largeFaceListId, RequestContent content, RequestContext context = null)
        {
            if (largeFaceListId == null)
            {
                throw new ArgumentNullException(nameof(largeFaceListId));
            }
            if (largeFaceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(largeFaceListId));
            }
            if (content == null)
            {
                throw new ArgumentNullException(nameof(content));
            }

            using var scope = ClientDiagnostics.CreateScope("LargeFaceLists.CreateList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateListRequest(largeFaceListId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] The most basic operation that applies to a resource.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateList(string,LargeFaceList,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> ID of the container. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/LargeFaceLists.xml" path="doc/members/member[@name='CreateList(string,RequestContent,RequestContext)']/*" />
        public virtual Response CreateList(string largeFaceListId, RequestContent content, RequestContext context = null)
        {
            if (largeFaceListId == null)
            {
                throw new ArgumentNullException(nameof(largeFaceListId));
            }
            if (largeFaceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(largeFaceListId));
            }
            if (content == null)
            {
                throw new ArgumentNullException(nameof(content));
            }

            using var scope = ClientDiagnostics.CreateScope("LargeFaceLists.CreateList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateListRequest(largeFaceListId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] The most basic operation that applies to a resource.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> ID of the container. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/LargeFaceLists.xml" path="doc/members/member[@name='DeleteListAsync(string,RequestContext)']/*" />
        public virtual async Task<Response> DeleteListAsync(string largeFaceListId, RequestContext context = null)
        {
            if (largeFaceListId == null)
            {
                throw new ArgumentNullException(nameof(largeFaceListId));
            }
            if (largeFaceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(largeFaceListId));
            }

            using var scope = ClientDiagnostics.CreateScope("LargeFaceLists.DeleteList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteListRequest(largeFaceListId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] The most basic operation that applies to a resource.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> ID of the container. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/LargeFaceLists.xml" path="doc/members/member[@name='DeleteList(string,RequestContext)']/*" />
        public virtual Response DeleteList(string largeFaceListId, RequestContext context = null)
        {
            if (largeFaceListId == null)
            {
                throw new ArgumentNullException(nameof(largeFaceListId));
            }
            if (largeFaceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(largeFaceListId));
            }

            using var scope = ClientDiagnostics.CreateScope("LargeFaceLists.DeleteList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteListRequest(largeFaceListId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Resource read operation template. </summary>
        /// <param name="largeFaceListId"> ID of the container. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/LargeFaceLists.xml" path="doc/members/member[@name='GetListAsync(string,bool?,CancellationToken)']/*" />
        public virtual async Task<Response<LargeFaceList>> GetListAsync(string largeFaceListId, bool? returnRecognitionModel = null, CancellationToken cancellationToken = default)
        {
            if (largeFaceListId == null)
            {
                throw new ArgumentNullException(nameof(largeFaceListId));
            }
            if (largeFaceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(largeFaceListId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetListAsync(largeFaceListId, returnRecognitionModel, context).ConfigureAwait(false);
            return Response.FromValue(LargeFaceList.FromResponse(response), response);
        }

        /// <summary> Resource read operation template. </summary>
        /// <param name="largeFaceListId"> ID of the container. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/LargeFaceLists.xml" path="doc/members/member[@name='GetList(string,bool?,CancellationToken)']/*" />
        public virtual Response<LargeFaceList> GetList(string largeFaceListId, bool? returnRecognitionModel = null, CancellationToken cancellationToken = default)
        {
            if (largeFaceListId == null)
            {
                throw new ArgumentNullException(nameof(largeFaceListId));
            }
            if (largeFaceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(largeFaceListId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetList(largeFaceListId, returnRecognitionModel, context);
            return Response.FromValue(LargeFaceList.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Resource read operation template.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetListAsync(string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> ID of the container. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/LargeFaceLists.xml" path="doc/members/member[@name='GetListAsync(string,bool?,RequestContext)']/*" />
        public virtual async Task<Response> GetListAsync(string largeFaceListId, bool? returnRecognitionModel, RequestContext context)
        {
            if (largeFaceListId == null)
            {
                throw new ArgumentNullException(nameof(largeFaceListId));
            }
            if (largeFaceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(largeFaceListId));
            }

            using var scope = ClientDiagnostics.CreateScope("LargeFaceLists.GetList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetListRequest(largeFaceListId, returnRecognitionModel, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Resource read operation template.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetList(string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> ID of the container. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/LargeFaceLists.xml" path="doc/members/member[@name='GetList(string,bool?,RequestContext)']/*" />
        public virtual Response GetList(string largeFaceListId, bool? returnRecognitionModel, RequestContext context)
        {
            if (largeFaceListId == null)
            {
                throw new ArgumentNullException(nameof(largeFaceListId));
            }
            if (largeFaceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(largeFaceListId));
            }

            using var scope = ClientDiagnostics.CreateScope("LargeFaceLists.GetList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetListRequest(largeFaceListId, returnRecognitionModel, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] The most basic operation that applies to a resource.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> ID of the container. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/LargeFaceLists.xml" path="doc/members/member[@name='UpdateListAsync(string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> UpdateListAsync(string largeFaceListId, RequestContent content, RequestContext context = null)
        {
            if (largeFaceListId == null)
            {
                throw new ArgumentNullException(nameof(largeFaceListId));
            }
            if (largeFaceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(largeFaceListId));
            }
            if (content == null)
            {
                throw new ArgumentNullException(nameof(content));
            }

            using var scope = ClientDiagnostics.CreateScope("LargeFaceLists.UpdateList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateListRequest(largeFaceListId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] The most basic operation that applies to a resource.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> ID of the container. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/LargeFaceLists.xml" path="doc/members/member[@name='UpdateList(string,RequestContent,RequestContext)']/*" />
        public virtual Response UpdateList(string largeFaceListId, RequestContent content, RequestContext context = null)
        {
            if (largeFaceListId == null)
            {
                throw new ArgumentNullException(nameof(largeFaceListId));
            }
            if (largeFaceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(largeFaceListId));
            }
            if (content == null)
            {
                throw new ArgumentNullException(nameof(content));
            }

            using var scope = ClientDiagnostics.CreateScope("LargeFaceLists.UpdateList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateListRequest(largeFaceListId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Operation that applies to a collection of resources. </summary>
        /// <param name="largeFaceListId"> ID of the container. </param>
        /// <param name="addFaceFromUrlContent"> Model for add face by url. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="addFaceFromUrlContent"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/LargeFaceLists.xml" path="doc/members/member[@name='AddFaceFromUrlAsync(string,AddFaceFromUrlContent,string,DetectionModel?,string,CancellationToken)']/*" />
        public virtual async Task<Response<AddFaceResult>> AddFaceFromUrlAsync(string largeFaceListId, AddFaceFromUrlContent addFaceFromUrlContent, string targetFace = null, DetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            if (largeFaceListId == null)
            {
                throw new ArgumentNullException(nameof(largeFaceListId));
            }
            if (largeFaceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(largeFaceListId));
            }
            if (addFaceFromUrlContent == null)
            {
                throw new ArgumentNullException(nameof(addFaceFromUrlContent));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = addFaceFromUrlContent.ToRequestContent();
            Response response = await AddFaceFromUrlAsync(largeFaceListId, content, targetFace, detectionModel?.ToString(), userData, context).ConfigureAwait(false);
            return Response.FromValue(AddFaceResult.FromResponse(response), response);
        }

        /// <summary> Operation that applies to a collection of resources. </summary>
        /// <param name="largeFaceListId"> ID of the container. </param>
        /// <param name="addFaceFromUrlContent"> Model for add face by url. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="addFaceFromUrlContent"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/LargeFaceLists.xml" path="doc/members/member[@name='AddFaceFromUrl(string,AddFaceFromUrlContent,string,DetectionModel?,string,CancellationToken)']/*" />
        public virtual Response<AddFaceResult> AddFaceFromUrl(string largeFaceListId, AddFaceFromUrlContent addFaceFromUrlContent, string targetFace = null, DetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            if (largeFaceListId == null)
            {
                throw new ArgumentNullException(nameof(largeFaceListId));
            }
            if (largeFaceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(largeFaceListId));
            }
            if (addFaceFromUrlContent == null)
            {
                throw new ArgumentNullException(nameof(addFaceFromUrlContent));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = addFaceFromUrlContent.ToRequestContent();
            Response response = AddFaceFromUrl(largeFaceListId, content, targetFace, detectionModel?.ToString(), userData, context);
            return Response.FromValue(AddFaceResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Operation that applies to a collection of resources.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddFaceFromUrlAsync(string,AddFaceFromUrlContent,string,DetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> ID of the container. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/LargeFaceLists.xml" path="doc/members/member[@name='AddFaceFromUrlAsync(string,RequestContent,string,string,string,RequestContext)']/*" />
        public virtual async Task<Response> AddFaceFromUrlAsync(string largeFaceListId, RequestContent content, string targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            if (largeFaceListId == null)
            {
                throw new ArgumentNullException(nameof(largeFaceListId));
            }
            if (largeFaceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(largeFaceListId));
            }
            if (content == null)
            {
                throw new ArgumentNullException(nameof(content));
            }

            using var scope = ClientDiagnostics.CreateScope("LargeFaceLists.AddFaceFromUrl");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddFaceFromUrlRequest(largeFaceListId, content, targetFace, detectionModel, userData, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Operation that applies to a collection of resources.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddFaceFromUrl(string,AddFaceFromUrlContent,string,DetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> ID of the container. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/LargeFaceLists.xml" path="doc/members/member[@name='AddFaceFromUrl(string,RequestContent,string,string,string,RequestContext)']/*" />
        public virtual Response AddFaceFromUrl(string largeFaceListId, RequestContent content, string targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            if (largeFaceListId == null)
            {
                throw new ArgumentNullException(nameof(largeFaceListId));
            }
            if (largeFaceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(largeFaceListId));
            }
            if (content == null)
            {
                throw new ArgumentNullException(nameof(content));
            }

            using var scope = ClientDiagnostics.CreateScope("LargeFaceLists.AddFaceFromUrl");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddFaceFromUrlRequest(largeFaceListId, content, targetFace, detectionModel, userData, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Operation that applies to a collection of resources. </summary>
        /// <param name="largeFaceListId"> ID of the container. </param>
        /// <param name="imageContent"> The image to be analyzed. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="imageContent"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/LargeFaceLists.xml" path="doc/members/member[@name='AddFaceFromStreamAsync(string,BinaryData,string,DetectionModel?,string,CancellationToken)']/*" />
        public virtual async Task<Response<AddFaceResult>> AddFaceFromStreamAsync(string largeFaceListId, BinaryData imageContent, string targetFace = null, DetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            if (largeFaceListId == null)
            {
                throw new ArgumentNullException(nameof(largeFaceListId));
            }
            if (largeFaceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(largeFaceListId));
            }
            if (imageContent == null)
            {
                throw new ArgumentNullException(nameof(imageContent));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = imageContent;
            Response response = await AddFaceFromStreamAsync(largeFaceListId, content, targetFace, detectionModel?.ToString(), userData, context).ConfigureAwait(false);
            return Response.FromValue(AddFaceResult.FromResponse(response), response);
        }

        /// <summary> Operation that applies to a collection of resources. </summary>
        /// <param name="largeFaceListId"> ID of the container. </param>
        /// <param name="imageContent"> The image to be analyzed. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="imageContent"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/LargeFaceLists.xml" path="doc/members/member[@name='AddFaceFromStream(string,BinaryData,string,DetectionModel?,string,CancellationToken)']/*" />
        public virtual Response<AddFaceResult> AddFaceFromStream(string largeFaceListId, BinaryData imageContent, string targetFace = null, DetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            if (largeFaceListId == null)
            {
                throw new ArgumentNullException(nameof(largeFaceListId));
            }
            if (largeFaceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(largeFaceListId));
            }
            if (imageContent == null)
            {
                throw new ArgumentNullException(nameof(imageContent));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = imageContent;
            Response response = AddFaceFromStream(largeFaceListId, content, targetFace, detectionModel?.ToString(), userData, context);
            return Response.FromValue(AddFaceResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Operation that applies to a collection of resources.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddFaceFromStreamAsync(string,BinaryData,string,DetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> ID of the container. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/LargeFaceLists.xml" path="doc/members/member[@name='AddFaceFromStreamAsync(string,RequestContent,string,string,string,RequestContext)']/*" />
        public virtual async Task<Response> AddFaceFromStreamAsync(string largeFaceListId, RequestContent content, string targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            if (largeFaceListId == null)
            {
                throw new ArgumentNullException(nameof(largeFaceListId));
            }
            if (largeFaceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(largeFaceListId));
            }
            if (content == null)
            {
                throw new ArgumentNullException(nameof(content));
            }

            using var scope = ClientDiagnostics.CreateScope("LargeFaceLists.AddFaceFromStream");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddFaceFromStreamRequest(largeFaceListId, content, targetFace, detectionModel, userData, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Operation that applies to a collection of resources.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddFaceFromStream(string,BinaryData,string,DetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> ID of the container. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/LargeFaceLists.xml" path="doc/members/member[@name='AddFaceFromStream(string,RequestContent,string,string,string,RequestContext)']/*" />
        public virtual Response AddFaceFromStream(string largeFaceListId, RequestContent content, string targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            if (largeFaceListId == null)
            {
                throw new ArgumentNullException(nameof(largeFaceListId));
            }
            if (largeFaceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(largeFaceListId));
            }
            if (content == null)
            {
                throw new ArgumentNullException(nameof(content));
            }

            using var scope = ClientDiagnostics.CreateScope("LargeFaceLists.AddFaceFromStream");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddFaceFromStreamRequest(largeFaceListId, content, targetFace, detectionModel, userData, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] The most basic operation that applies to a resource.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> ID of the container. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="persistedFaceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/LargeFaceLists.xml" path="doc/members/member[@name='DeleteFaceAsync(string,string,RequestContext)']/*" />
        public virtual async Task<Response> DeleteFaceAsync(string largeFaceListId, string persistedFaceId, RequestContext context = null)
        {
            if (largeFaceListId == null)
            {
                throw new ArgumentNullException(nameof(largeFaceListId));
            }
            if (largeFaceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(largeFaceListId));
            }
            if (persistedFaceId == null)
            {
                throw new ArgumentNullException(nameof(persistedFaceId));
            }
            if (persistedFaceId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(persistedFaceId));
            }

            using var scope = ClientDiagnostics.CreateScope("LargeFaceLists.DeleteFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteFaceRequest(largeFaceListId, persistedFaceId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] The most basic operation that applies to a resource.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> ID of the container. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="persistedFaceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/LargeFaceLists.xml" path="doc/members/member[@name='DeleteFace(string,string,RequestContext)']/*" />
        public virtual Response DeleteFace(string largeFaceListId, string persistedFaceId, RequestContext context = null)
        {
            if (largeFaceListId == null)
            {
                throw new ArgumentNullException(nameof(largeFaceListId));
            }
            if (largeFaceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(largeFaceListId));
            }
            if (persistedFaceId == null)
            {
                throw new ArgumentNullException(nameof(persistedFaceId));
            }
            if (persistedFaceId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(persistedFaceId));
            }

            using var scope = ClientDiagnostics.CreateScope("LargeFaceLists.DeleteFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteFaceRequest(largeFaceListId, persistedFaceId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Operation that lists resources in a paginated way. </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/LargeFaceLists.xml" path="doc/members/member[@name='GetListsAsync(string,int?,bool?,CancellationToken)']/*" />
        public virtual async Task<Response<IReadOnlyList<LargeFaceList>>> GetListsAsync(string start = null, int? top = null, bool? returnRecognitionModel = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetListsAsync(start, top, returnRecognitionModel, context).ConfigureAwait(false);
            IReadOnlyList<LargeFaceList> value = default;
            using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
            List<LargeFaceList> array = new List<LargeFaceList>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(LargeFaceList.DeserializeLargeFaceList(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary> Operation that lists resources in a paginated way. </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/LargeFaceLists.xml" path="doc/members/member[@name='GetLists(string,int?,bool?,CancellationToken)']/*" />
        public virtual Response<IReadOnlyList<LargeFaceList>> GetLists(string start = null, int? top = null, bool? returnRecognitionModel = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetLists(start, top, returnRecognitionModel, context);
            IReadOnlyList<LargeFaceList> value = default;
            using var document = JsonDocument.Parse(response.ContentStream);
            List<LargeFaceList> array = new List<LargeFaceList>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(LargeFaceList.DeserializeLargeFaceList(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// [Protocol Method] Operation that lists resources in a paginated way.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetListsAsync(string,int?,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/LargeFaceLists.xml" path="doc/members/member[@name='GetListsAsync(string,int?,bool?,RequestContext)']/*" />
        public virtual async Task<Response> GetListsAsync(string start, int? top, bool? returnRecognitionModel, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("LargeFaceLists.GetLists");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetListsRequest(start, top, returnRecognitionModel, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Operation that lists resources in a paginated way.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLists(string,int?,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/LargeFaceLists.xml" path="doc/members/member[@name='GetLists(string,int?,bool?,RequestContext)']/*" />
        public virtual Response GetLists(string start, int? top, bool? returnRecognitionModel, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("LargeFaceLists.GetLists");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetListsRequest(start, top, returnRecognitionModel, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> The most basic operation that applies to a resource. </summary>
        /// <param name="largeFaceListId"> ID of the container. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/LargeFaceLists.xml" path="doc/members/member[@name='GetTrainingStatusAsync(string,CancellationToken)']/*" />
        public virtual async Task<Response<TrainingStatus>> GetTrainingStatusAsync(string largeFaceListId, CancellationToken cancellationToken = default)
        {
            if (largeFaceListId == null)
            {
                throw new ArgumentNullException(nameof(largeFaceListId));
            }
            if (largeFaceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(largeFaceListId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetTrainingStatusAsync(largeFaceListId, context).ConfigureAwait(false);
            return Response.FromValue(TrainingStatus.FromResponse(response), response);
        }

        /// <summary> The most basic operation that applies to a resource. </summary>
        /// <param name="largeFaceListId"> ID of the container. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/LargeFaceLists.xml" path="doc/members/member[@name='GetTrainingStatus(string,CancellationToken)']/*" />
        public virtual Response<TrainingStatus> GetTrainingStatus(string largeFaceListId, CancellationToken cancellationToken = default)
        {
            if (largeFaceListId == null)
            {
                throw new ArgumentNullException(nameof(largeFaceListId));
            }
            if (largeFaceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(largeFaceListId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetTrainingStatus(largeFaceListId, context);
            return Response.FromValue(TrainingStatus.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] The most basic operation that applies to a resource.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetTrainingStatusAsync(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> ID of the container. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/LargeFaceLists.xml" path="doc/members/member[@name='GetTrainingStatusAsync(string,RequestContext)']/*" />
        public virtual async Task<Response> GetTrainingStatusAsync(string largeFaceListId, RequestContext context)
        {
            if (largeFaceListId == null)
            {
                throw new ArgumentNullException(nameof(largeFaceListId));
            }
            if (largeFaceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(largeFaceListId));
            }

            using var scope = ClientDiagnostics.CreateScope("LargeFaceLists.GetTrainingStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTrainingStatusRequest(largeFaceListId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] The most basic operation that applies to a resource.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetTrainingStatus(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> ID of the container. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/LargeFaceLists.xml" path="doc/members/member[@name='GetTrainingStatus(string,RequestContext)']/*" />
        public virtual Response GetTrainingStatus(string largeFaceListId, RequestContext context)
        {
            if (largeFaceListId == null)
            {
                throw new ArgumentNullException(nameof(largeFaceListId));
            }
            if (largeFaceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(largeFaceListId));
            }

            using var scope = ClientDiagnostics.CreateScope("LargeFaceLists.GetTrainingStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTrainingStatusRequest(largeFaceListId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Resource read operation template. </summary>
        /// <param name="largeFaceListId"> ID of the container. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="persistedFaceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/LargeFaceLists.xml" path="doc/members/member[@name='GetFaceAsync(string,string,CancellationToken)']/*" />
        public virtual async Task<Response<LargeFaceListFace>> GetFaceAsync(string largeFaceListId, string persistedFaceId, CancellationToken cancellationToken = default)
        {
            if (largeFaceListId == null)
            {
                throw new ArgumentNullException(nameof(largeFaceListId));
            }
            if (largeFaceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(largeFaceListId));
            }
            if (persistedFaceId == null)
            {
                throw new ArgumentNullException(nameof(persistedFaceId));
            }
            if (persistedFaceId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(persistedFaceId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetFaceAsync(largeFaceListId, persistedFaceId, context).ConfigureAwait(false);
            return Response.FromValue(LargeFaceListFace.FromResponse(response), response);
        }

        /// <summary> Resource read operation template. </summary>
        /// <param name="largeFaceListId"> ID of the container. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="persistedFaceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/LargeFaceLists.xml" path="doc/members/member[@name='GetFace(string,string,CancellationToken)']/*" />
        public virtual Response<LargeFaceListFace> GetFace(string largeFaceListId, string persistedFaceId, CancellationToken cancellationToken = default)
        {
            if (largeFaceListId == null)
            {
                throw new ArgumentNullException(nameof(largeFaceListId));
            }
            if (largeFaceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(largeFaceListId));
            }
            if (persistedFaceId == null)
            {
                throw new ArgumentNullException(nameof(persistedFaceId));
            }
            if (persistedFaceId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(persistedFaceId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetFace(largeFaceListId, persistedFaceId, context);
            return Response.FromValue(LargeFaceListFace.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Resource read operation template.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetFaceAsync(string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> ID of the container. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="persistedFaceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/LargeFaceLists.xml" path="doc/members/member[@name='GetFaceAsync(string,string,RequestContext)']/*" />
        public virtual async Task<Response> GetFaceAsync(string largeFaceListId, string persistedFaceId, RequestContext context)
        {
            if (largeFaceListId == null)
            {
                throw new ArgumentNullException(nameof(largeFaceListId));
            }
            if (largeFaceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(largeFaceListId));
            }
            if (persistedFaceId == null)
            {
                throw new ArgumentNullException(nameof(persistedFaceId));
            }
            if (persistedFaceId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(persistedFaceId));
            }

            using var scope = ClientDiagnostics.CreateScope("LargeFaceLists.GetFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetFaceRequest(largeFaceListId, persistedFaceId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Resource read operation template.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetFace(string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> ID of the container. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="persistedFaceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/LargeFaceLists.xml" path="doc/members/member[@name='GetFace(string,string,RequestContext)']/*" />
        public virtual Response GetFace(string largeFaceListId, string persistedFaceId, RequestContext context)
        {
            if (largeFaceListId == null)
            {
                throw new ArgumentNullException(nameof(largeFaceListId));
            }
            if (largeFaceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(largeFaceListId));
            }
            if (persistedFaceId == null)
            {
                throw new ArgumentNullException(nameof(persistedFaceId));
            }
            if (persistedFaceId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(persistedFaceId));
            }

            using var scope = ClientDiagnostics.CreateScope("LargeFaceLists.GetFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetFaceRequest(largeFaceListId, persistedFaceId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] The most basic operation that applies to a resource.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> ID of the container. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/>, <paramref name="persistedFaceId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/LargeFaceLists.xml" path="doc/members/member[@name='UpdateFaceAsync(string,string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> UpdateFaceAsync(string largeFaceListId, string persistedFaceId, RequestContent content, RequestContext context = null)
        {
            if (largeFaceListId == null)
            {
                throw new ArgumentNullException(nameof(largeFaceListId));
            }
            if (largeFaceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(largeFaceListId));
            }
            if (persistedFaceId == null)
            {
                throw new ArgumentNullException(nameof(persistedFaceId));
            }
            if (persistedFaceId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(persistedFaceId));
            }
            if (content == null)
            {
                throw new ArgumentNullException(nameof(content));
            }

            using var scope = ClientDiagnostics.CreateScope("LargeFaceLists.UpdateFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateFaceRequest(largeFaceListId, persistedFaceId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] The most basic operation that applies to a resource.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> ID of the container. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/>, <paramref name="persistedFaceId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/LargeFaceLists.xml" path="doc/members/member[@name='UpdateFace(string,string,RequestContent,RequestContext)']/*" />
        public virtual Response UpdateFace(string largeFaceListId, string persistedFaceId, RequestContent content, RequestContext context = null)
        {
            if (largeFaceListId == null)
            {
                throw new ArgumentNullException(nameof(largeFaceListId));
            }
            if (largeFaceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(largeFaceListId));
            }
            if (persistedFaceId == null)
            {
                throw new ArgumentNullException(nameof(persistedFaceId));
            }
            if (persistedFaceId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(persistedFaceId));
            }
            if (content == null)
            {
                throw new ArgumentNullException(nameof(content));
            }

            using var scope = ClientDiagnostics.CreateScope("LargeFaceLists.UpdateFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateFaceRequest(largeFaceListId, persistedFaceId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Operation that lists resources in a paginated way. </summary>
        /// <param name="largeFaceListId"> ID of the container. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/LargeFaceLists.xml" path="doc/members/member[@name='GetFacesAsync(string,string,int?,CancellationToken)']/*" />
        public virtual async Task<Response<IReadOnlyList<LargeFaceListFace>>> GetFacesAsync(string largeFaceListId, string start = null, int? top = null, CancellationToken cancellationToken = default)
        {
            if (largeFaceListId == null)
            {
                throw new ArgumentNullException(nameof(largeFaceListId));
            }
            if (largeFaceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(largeFaceListId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetFacesAsync(largeFaceListId, start, top, context).ConfigureAwait(false);
            IReadOnlyList<LargeFaceListFace> value = default;
            using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
            List<LargeFaceListFace> array = new List<LargeFaceListFace>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(LargeFaceListFace.DeserializeLargeFaceListFace(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary> Operation that lists resources in a paginated way. </summary>
        /// <param name="largeFaceListId"> ID of the container. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/LargeFaceLists.xml" path="doc/members/member[@name='GetFaces(string,string,int?,CancellationToken)']/*" />
        public virtual Response<IReadOnlyList<LargeFaceListFace>> GetFaces(string largeFaceListId, string start = null, int? top = null, CancellationToken cancellationToken = default)
        {
            if (largeFaceListId == null)
            {
                throw new ArgumentNullException(nameof(largeFaceListId));
            }
            if (largeFaceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(largeFaceListId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetFaces(largeFaceListId, start, top, context);
            IReadOnlyList<LargeFaceListFace> value = default;
            using var document = JsonDocument.Parse(response.ContentStream);
            List<LargeFaceListFace> array = new List<LargeFaceListFace>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(LargeFaceListFace.DeserializeLargeFaceListFace(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// [Protocol Method] Operation that lists resources in a paginated way.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetFacesAsync(string,string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> ID of the container. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/LargeFaceLists.xml" path="doc/members/member[@name='GetFacesAsync(string,string,int?,RequestContext)']/*" />
        public virtual async Task<Response> GetFacesAsync(string largeFaceListId, string start, int? top, RequestContext context)
        {
            if (largeFaceListId == null)
            {
                throw new ArgumentNullException(nameof(largeFaceListId));
            }
            if (largeFaceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(largeFaceListId));
            }

            using var scope = ClientDiagnostics.CreateScope("LargeFaceLists.GetFaces");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetFacesRequest(largeFaceListId, start, top, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Operation that lists resources in a paginated way.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetFaces(string,string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> ID of the container. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/LargeFaceLists.xml" path="doc/members/member[@name='GetFaces(string,string,int?,RequestContext)']/*" />
        public virtual Response GetFaces(string largeFaceListId, string start, int? top, RequestContext context)
        {
            if (largeFaceListId == null)
            {
                throw new ArgumentNullException(nameof(largeFaceListId));
            }
            if (largeFaceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(largeFaceListId));
            }

            using var scope = ClientDiagnostics.CreateScope("LargeFaceLists.GetFaces");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetFacesRequest(largeFaceListId, start, top, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Given query face's faceId, to search the similar-looking faces from a faceId array, a face list or a large face list. </summary>
        /// <param name="faceId"> faceId of the face, comes from Face - Detect. </param>
        /// <param name="largeFaceListId"> An existing user-specified unique candidate large face list, created in LargeFaceList - Create. Large face list contains a set of persistedFaceIds which are persisted and will never expire. </param>
        /// <param name="maxNumOfCandidatesReturned"> The number of top similar faces returned. The valid range is [1, 1000].It defaults to 20. </param>
        /// <param name="mode"> Similar face searching mode. It can be 'matchPerson' or 'matchFace'. It defaults to 'matchPerson'. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceId"/> or <paramref name="largeFaceListId"/> is null. </exception>
        /// <include file="Docs/LargeFaceLists.xml" path="doc/members/member[@name='FindSimilarFromLargeFaceListAsync(string,string,int?,FindSimilarMatchMode?,CancellationToken)']/*" />
        public virtual async Task<Response<IReadOnlyList<FindSimilarResult>>> FindSimilarFromLargeFaceListAsync(string faceId, string largeFaceListId, int? maxNumOfCandidatesReturned = null, FindSimilarMatchMode? mode = null, CancellationToken cancellationToken = default)
        {
            if (faceId == null)
            {
                throw new ArgumentNullException(nameof(faceId));
            }
            if (largeFaceListId == null)
            {
                throw new ArgumentNullException(nameof(largeFaceListId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            FindSimilarFromLargeFaceListRequest findSimilarFromLargeFaceListRequest = new FindSimilarFromLargeFaceListRequest(faceId, largeFaceListId)
            {
                MaxNumOfCandidatesReturned = maxNumOfCandidatesReturned,
                Mode = mode
            };
            Response response = await FindSimilarFromLargeFaceListAsync(findSimilarFromLargeFaceListRequest.ToRequestContent(), context).ConfigureAwait(false);
            IReadOnlyList<FindSimilarResult> value = default;
            using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
            List<FindSimilarResult> array = new List<FindSimilarResult>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(FindSimilarResult.DeserializeFindSimilarResult(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary> Given query face's faceId, to search the similar-looking faces from a faceId array, a face list or a large face list. </summary>
        /// <param name="faceId"> faceId of the face, comes from Face - Detect. </param>
        /// <param name="largeFaceListId"> An existing user-specified unique candidate large face list, created in LargeFaceList - Create. Large face list contains a set of persistedFaceIds which are persisted and will never expire. </param>
        /// <param name="maxNumOfCandidatesReturned"> The number of top similar faces returned. The valid range is [1, 1000].It defaults to 20. </param>
        /// <param name="mode"> Similar face searching mode. It can be 'matchPerson' or 'matchFace'. It defaults to 'matchPerson'. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceId"/> or <paramref name="largeFaceListId"/> is null. </exception>
        /// <include file="Docs/LargeFaceLists.xml" path="doc/members/member[@name='FindSimilarFromLargeFaceList(string,string,int?,FindSimilarMatchMode?,CancellationToken)']/*" />
        public virtual Response<IReadOnlyList<FindSimilarResult>> FindSimilarFromLargeFaceList(string faceId, string largeFaceListId, int? maxNumOfCandidatesReturned = null, FindSimilarMatchMode? mode = null, CancellationToken cancellationToken = default)
        {
            if (faceId == null)
            {
                throw new ArgumentNullException(nameof(faceId));
            }
            if (largeFaceListId == null)
            {
                throw new ArgumentNullException(nameof(largeFaceListId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            FindSimilarFromLargeFaceListRequest findSimilarFromLargeFaceListRequest = new FindSimilarFromLargeFaceListRequest(faceId, largeFaceListId)
            {
                MaxNumOfCandidatesReturned = maxNumOfCandidatesReturned,
                Mode = mode
            };
            Response response = FindSimilarFromLargeFaceList(findSimilarFromLargeFaceListRequest.ToRequestContent(), context);
            IReadOnlyList<FindSimilarResult> value = default;
            using var document = JsonDocument.Parse(response.ContentStream);
            List<FindSimilarResult> array = new List<FindSimilarResult>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(FindSimilarResult.DeserializeFindSimilarResult(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// [Protocol Method] Given query face's faceId, to search the similar-looking faces from a faceId array, a face list or a large face list.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="FindSimilarFromLargeFaceListAsync(string,string,int?,FindSimilarMatchMode?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/LargeFaceLists.xml" path="doc/members/member[@name='FindSimilarFromLargeFaceListAsync(RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> FindSimilarFromLargeFaceListAsync(RequestContent content, RequestContext context = null)
        {
            if (content == null)
            {
                throw new ArgumentNullException(nameof(content));
            }

            using var scope = ClientDiagnostics.CreateScope("LargeFaceLists.FindSimilarFromLargeFaceList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateFindSimilarFromLargeFaceListRequest(content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Given query face's faceId, to search the similar-looking faces from a faceId array, a face list or a large face list.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="FindSimilarFromLargeFaceList(string,string,int?,FindSimilarMatchMode?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/LargeFaceLists.xml" path="doc/members/member[@name='FindSimilarFromLargeFaceList(RequestContent,RequestContext)']/*" />
        public virtual Response FindSimilarFromLargeFaceList(RequestContent content, RequestContext context = null)
        {
            if (content == null)
            {
                throw new ArgumentNullException(nameof(content));
            }

            using var scope = ClientDiagnostics.CreateScope("LargeFaceLists.FindSimilarFromLargeFaceList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateFindSimilarFromLargeFaceListRequest(content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Resource action operation template.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="largeFaceListId"> ID of the container. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/LargeFaceLists.xml" path="doc/members/member[@name='TrainListAsync(WaitUntil,string,RequestContext)']/*" />
        public virtual async Task<Operation> TrainListAsync(WaitUntil waitUntil, string largeFaceListId, RequestContext context = null)
        {
            if (largeFaceListId == null)
            {
                throw new ArgumentNullException(nameof(largeFaceListId));
            }
            if (largeFaceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(largeFaceListId));
            }

            using var scope = ClientDiagnostics.CreateScope("LargeFaceLists.TrainList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateTrainListRequest(largeFaceListId, context);
                return await ProtocolOperationHelpers.ProcessMessageWithoutResponseValueAsync(_pipeline, message, ClientDiagnostics, "LargeFaceLists.TrainList", OperationFinalStateVia.OperationLocation, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Resource action operation template.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="largeFaceListId"> ID of the container. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/LargeFaceLists.xml" path="doc/members/member[@name='TrainList(WaitUntil,string,RequestContext)']/*" />
        public virtual Operation TrainList(WaitUntil waitUntil, string largeFaceListId, RequestContext context = null)
        {
            if (largeFaceListId == null)
            {
                throw new ArgumentNullException(nameof(largeFaceListId));
            }
            if (largeFaceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(largeFaceListId));
            }

            using var scope = ClientDiagnostics.CreateScope("LargeFaceLists.TrainList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateTrainListRequest(largeFaceListId, context);
                return ProtocolOperationHelpers.ProcessMessageWithoutResponseValue(_pipeline, message, ClientDiagnostics, "LargeFaceLists.TrainList", OperationFinalStateVia.OperationLocation, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateCreateListRequest(string largeFaceListId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/largefacelists/", false);
            uri.AppendPath(largeFaceListId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteListRequest(string largeFaceListId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/largefacelists/", false);
            uri.AppendPath(largeFaceListId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetListRequest(string largeFaceListId, bool? returnRecognitionModel, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/largefacelists/", false);
            uri.AppendPath(largeFaceListId, true);
            if (returnRecognitionModel != null)
            {
                uri.AppendQuery("returnRecognitionModel", returnRecognitionModel.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateUpdateListRequest(string largeFaceListId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/largefacelists/", false);
            uri.AppendPath(largeFaceListId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateAddFaceFromUrlRequest(string largeFaceListId, RequestContent content, string targetFace, string detectionModel, string userData, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/largefacelists/", false);
            uri.AppendPath(largeFaceListId, true);
            uri.AppendPath("/persistedfaces", false);
            if (targetFace != null)
            {
                uri.AppendQuery("targetFace", targetFace, true);
            }
            if (detectionModel != null)
            {
                uri.AppendQuery("detectionModel", detectionModel, true);
            }
            if (userData != null)
            {
                uri.AppendQuery("userData", userData, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateAddFaceFromStreamRequest(string largeFaceListId, RequestContent content, string targetFace, string detectionModel, string userData, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/largefacelists/", false);
            uri.AppendPath(largeFaceListId, true);
            uri.AppendPath("/persistedfaces", false);
            if (targetFace != null)
            {
                uri.AppendQuery("targetFace", targetFace, true);
            }
            if (detectionModel != null)
            {
                uri.AppendQuery("detectionModel", detectionModel, true);
            }
            if (userData != null)
            {
                uri.AppendQuery("userData", userData, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("content-type", "application/octet-stream");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteFaceRequest(string largeFaceListId, string persistedFaceId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/largefacelists/", false);
            uri.AppendPath(largeFaceListId, true);
            uri.AppendPath("/persistedfaces/", false);
            uri.AppendPath(persistedFaceId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetListsRequest(string start, int? top, bool? returnRecognitionModel, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/largefacelists", false);
            if (start != null)
            {
                uri.AppendQuery("start", start, true);
            }
            if (top != null)
            {
                uri.AppendQuery("top", top.Value, true);
            }
            if (returnRecognitionModel != null)
            {
                uri.AppendQuery("returnRecognitionModel", returnRecognitionModel.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateTrainListRequest(string largeFaceListId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/largefacelists/", false);
            uri.AppendPath(largeFaceListId, true);
            uri.AppendPath("/train", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetTrainingStatusRequest(string largeFaceListId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/largefacelists/", false);
            uri.AppendPath(largeFaceListId, true);
            uri.AppendPath("/training", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetFaceRequest(string largeFaceListId, string persistedFaceId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/largefacelists/", false);
            uri.AppendPath(largeFaceListId, true);
            uri.AppendPath("/persistedfaces/", false);
            uri.AppendPath(persistedFaceId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateUpdateFaceRequest(string largeFaceListId, string persistedFaceId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/largefacelists/", false);
            uri.AppendPath(largeFaceListId, true);
            uri.AppendPath("/persistedfaces/", false);
            uri.AppendPath(persistedFaceId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetFacesRequest(string largeFaceListId, string start, int? top, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/largefacelists/", false);
            uri.AppendPath(largeFaceListId, true);
            uri.AppendPath("/persistedfaces", false);
            if (start != null)
            {
                uri.AppendQuery("start", start, true);
            }
            if (top != null)
            {
                uri.AppendQuery("top", top.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateFindSimilarFromLargeFaceListRequest(RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/findsimilars", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        private static RequestContext DefaultRequestContext = new RequestContext();
        internal static RequestContext FromCancellationToken(CancellationToken cancellationToken = default)
        {
            if (!cancellationToken.CanBeCanceled)
            {
                return DefaultRequestContext;
            }

            return new RequestContext() { CancellationToken = cancellationToken };
        }

        private static ResponseClassifier _responseClassifier200;
        private static ResponseClassifier ResponseClassifier200 => _responseClassifier200 ??= new StatusCodeClassifier(stackalloc ushort[] { 200 });
        private static ResponseClassifier _responseClassifier202;
        private static ResponseClassifier ResponseClassifier202 => _responseClassifier202 ??= new StatusCodeClassifier(stackalloc ushort[] { 202 });
    }
}
