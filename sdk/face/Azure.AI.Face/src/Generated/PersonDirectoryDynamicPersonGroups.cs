// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.AI.Face
{
    // Data plane generated sub-client.
    /// <summary> The PersonDirectoryDynamicPersonGroups sub-client. </summary>
    public partial class PersonDirectoryDynamicPersonGroups
    {
        private const string AuthorizationHeader = "Ocp-Apim-Subscription-Key";
        private readonly AzureKeyCredential _keyCredential;
        private static readonly string[] AuthorizationScopes = new string[] { "https://cognitiveservices.azure.com/.default" };
        private readonly TokenCredential _tokenCredential;
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;
        private readonly string _apiVersion;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of PersonDirectoryDynamicPersonGroups for mocking. </summary>
        protected PersonDirectoryDynamicPersonGroups()
        {
        }

        /// <summary> Initializes a new instance of PersonDirectoryDynamicPersonGroups. </summary>
        /// <param name="clientDiagnostics"> The handler for diagnostic messaging in the client. </param>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="keyCredential"> The key credential to copy. </param>
        /// <param name="tokenCredential"> The token credential to copy. </param>
        /// <param name="endpoint">
        /// Supported Cognitive Services endpoints (protocol and hostname, for example:
        /// https://&lt;resource-name&gt;.cognitiveservices.azure.com).
        /// </param>
        /// <param name="apiVersion"> The API version to use for this operation. </param>
        internal PersonDirectoryDynamicPersonGroups(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, AzureKeyCredential keyCredential, TokenCredential tokenCredential, Uri endpoint, string apiVersion)
        {
            ClientDiagnostics = clientDiagnostics;
            _pipeline = pipeline;
            _keyCredential = keyCredential;
            _tokenCredential = tokenCredential;
            _endpoint = endpoint;
            _apiVersion = apiVersion;
        }

        /// <summary> Resource read operation template. </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/PersonDirectoryDynamicPersonGroups.xml" path="doc/members/member[@name='GetGroupAsync(string,CancellationToken)']/*" />
        public virtual async Task<Response<DynamicPersonGroup>> GetGroupAsync(string dynamicPersonGroupId, CancellationToken cancellationToken = default)
        {
            if (dynamicPersonGroupId == null)
            {
                throw new ArgumentNullException(nameof(dynamicPersonGroupId));
            }
            if (dynamicPersonGroupId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(dynamicPersonGroupId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetGroupAsync(dynamicPersonGroupId, context).ConfigureAwait(false);
            return Response.FromValue(DynamicPersonGroup.FromResponse(response), response);
        }

        /// <summary> Resource read operation template. </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/PersonDirectoryDynamicPersonGroups.xml" path="doc/members/member[@name='GetGroup(string,CancellationToken)']/*" />
        public virtual Response<DynamicPersonGroup> GetGroup(string dynamicPersonGroupId, CancellationToken cancellationToken = default)
        {
            if (dynamicPersonGroupId == null)
            {
                throw new ArgumentNullException(nameof(dynamicPersonGroupId));
            }
            if (dynamicPersonGroupId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(dynamicPersonGroupId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetGroup(dynamicPersonGroupId, context);
            return Response.FromValue(DynamicPersonGroup.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Resource read operation template.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetGroupAsync(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectoryDynamicPersonGroups.xml" path="doc/members/member[@name='GetGroupAsync(string,RequestContext)']/*" />
        public virtual async Task<Response> GetGroupAsync(string dynamicPersonGroupId, RequestContext context)
        {
            if (dynamicPersonGroupId == null)
            {
                throw new ArgumentNullException(nameof(dynamicPersonGroupId));
            }
            if (dynamicPersonGroupId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(dynamicPersonGroupId));
            }

            using var scope = ClientDiagnostics.CreateScope("PersonDirectoryDynamicPersonGroups.GetGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetGroupRequest(dynamicPersonGroupId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Resource read operation template.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetGroup(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectoryDynamicPersonGroups.xml" path="doc/members/member[@name='GetGroup(string,RequestContext)']/*" />
        public virtual Response GetGroup(string dynamicPersonGroupId, RequestContext context)
        {
            if (dynamicPersonGroupId == null)
            {
                throw new ArgumentNullException(nameof(dynamicPersonGroupId));
            }
            if (dynamicPersonGroupId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(dynamicPersonGroupId));
            }

            using var scope = ClientDiagnostics.CreateScope("PersonDirectoryDynamicPersonGroups.GetGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetGroupRequest(dynamicPersonGroupId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Operation that lists resources in a paginated way. </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/PersonDirectoryDynamicPersonGroups.xml" path="doc/members/member[@name='GetGroupsAsync(string,int?,CancellationToken)']/*" />
        public virtual async Task<Response<IReadOnlyList<DynamicPersonGroup>>> GetGroupsAsync(string start = null, int? top = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetGroupsAsync(start, top, context).ConfigureAwait(false);
            IReadOnlyList<DynamicPersonGroup> value = default;
            using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
            List<DynamicPersonGroup> array = new List<DynamicPersonGroup>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(DynamicPersonGroup.DeserializeDynamicPersonGroup(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary> Operation that lists resources in a paginated way. </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/PersonDirectoryDynamicPersonGroups.xml" path="doc/members/member[@name='GetGroups(string,int?,CancellationToken)']/*" />
        public virtual Response<IReadOnlyList<DynamicPersonGroup>> GetGroups(string start = null, int? top = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetGroups(start, top, context);
            IReadOnlyList<DynamicPersonGroup> value = default;
            using var document = JsonDocument.Parse(response.ContentStream);
            List<DynamicPersonGroup> array = new List<DynamicPersonGroup>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(DynamicPersonGroup.DeserializeDynamicPersonGroup(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// [Protocol Method] Operation that lists resources in a paginated way.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetGroupsAsync(string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectoryDynamicPersonGroups.xml" path="doc/members/member[@name='GetGroupsAsync(string,int?,RequestContext)']/*" />
        public virtual async Task<Response> GetGroupsAsync(string start, int? top, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("PersonDirectoryDynamicPersonGroups.GetGroups");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetGroupsRequest(start, top, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Operation that lists resources in a paginated way.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetGroups(string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectoryDynamicPersonGroups.xml" path="doc/members/member[@name='GetGroups(string,int?,RequestContext)']/*" />
        public virtual Response GetGroups(string start, int? top, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("PersonDirectoryDynamicPersonGroups.GetGroups");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetGroupsRequest(start, top, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> The most basic operation that applies to a resource. </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/PersonDirectoryDynamicPersonGroups.xml" path="doc/members/member[@name='GetGroupPeopleAsync(string,string,int?,CancellationToken)']/*" />
        public virtual async Task<Response<ListPersonResult>> GetGroupPeopleAsync(string dynamicPersonGroupId, string start = null, int? top = null, CancellationToken cancellationToken = default)
        {
            if (dynamicPersonGroupId == null)
            {
                throw new ArgumentNullException(nameof(dynamicPersonGroupId));
            }
            if (dynamicPersonGroupId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(dynamicPersonGroupId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetGroupPeopleAsync(dynamicPersonGroupId, start, top, context).ConfigureAwait(false);
            return Response.FromValue(ListPersonResult.FromResponse(response), response);
        }

        /// <summary> The most basic operation that applies to a resource. </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/PersonDirectoryDynamicPersonGroups.xml" path="doc/members/member[@name='GetGroupPeople(string,string,int?,CancellationToken)']/*" />
        public virtual Response<ListPersonResult> GetGroupPeople(string dynamicPersonGroupId, string start = null, int? top = null, CancellationToken cancellationToken = default)
        {
            if (dynamicPersonGroupId == null)
            {
                throw new ArgumentNullException(nameof(dynamicPersonGroupId));
            }
            if (dynamicPersonGroupId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(dynamicPersonGroupId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetGroupPeople(dynamicPersonGroupId, start, top, context);
            return Response.FromValue(ListPersonResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] The most basic operation that applies to a resource.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetGroupPeopleAsync(string,string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectoryDynamicPersonGroups.xml" path="doc/members/member[@name='GetGroupPeopleAsync(string,string,int?,RequestContext)']/*" />
        public virtual async Task<Response> GetGroupPeopleAsync(string dynamicPersonGroupId, string start, int? top, RequestContext context)
        {
            if (dynamicPersonGroupId == null)
            {
                throw new ArgumentNullException(nameof(dynamicPersonGroupId));
            }
            if (dynamicPersonGroupId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(dynamicPersonGroupId));
            }

            using var scope = ClientDiagnostics.CreateScope("PersonDirectoryDynamicPersonGroups.GetGroupPeople");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetGroupPeopleRequest(dynamicPersonGroupId, start, top, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] The most basic operation that applies to a resource.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetGroupPeople(string,string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectoryDynamicPersonGroups.xml" path="doc/members/member[@name='GetGroupPeople(string,string,int?,RequestContext)']/*" />
        public virtual Response GetGroupPeople(string dynamicPersonGroupId, string start, int? top, RequestContext context)
        {
            if (dynamicPersonGroupId == null)
            {
                throw new ArgumentNullException(nameof(dynamicPersonGroupId));
            }
            if (dynamicPersonGroupId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(dynamicPersonGroupId));
            }

            using var scope = ClientDiagnostics.CreateScope("PersonDirectoryDynamicPersonGroups.GetGroupPeople");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetGroupPeopleRequest(dynamicPersonGroupId, start, top, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> A remote procedure call (RPC) operation. </summary>
        /// <param name="faceIds"> Array of query faces faceIds, created by the Face - Detect. Each of the faces are identified independently. The valid number of faceIds is between [1, 10]. </param>
        /// <param name="dynamicPersonGroupId"> Id of the target PersonDirectory DynamicPersonGroup to match against. </param>
        /// <param name="maxNumOfCandidatesReturned"> The range of maxNumOfCandidatesReturned is between 1 and 100 (default is 10). </param>
        /// <param name="confidenceThreshold"> Customized identification confidence threshold, in the range of [0, 1]. Advanced user can tweak this value to override default internal threshold for better precision on their scenario data. Note there is no guarantee of this threshold value working on other data and after algorithm updates. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceIds"/> or <paramref name="dynamicPersonGroupId"/> is null. </exception>
        /// <include file="Docs/PersonDirectoryDynamicPersonGroups.xml" path="doc/members/member[@name='IdentifyFromDynamicPersonGroupAsync(IEnumerable{string},string,int?,float?,CancellationToken)']/*" />
        public virtual async Task<Response<IReadOnlyList<IdentifyResult>>> IdentifyFromDynamicPersonGroupAsync(IEnumerable<string> faceIds, string dynamicPersonGroupId, int? maxNumOfCandidatesReturned = null, float? confidenceThreshold = null, CancellationToken cancellationToken = default)
        {
            if (faceIds == null)
            {
                throw new ArgumentNullException(nameof(faceIds));
            }
            if (dynamicPersonGroupId == null)
            {
                throw new ArgumentNullException(nameof(dynamicPersonGroupId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            IdentifyFromDynamicPersonGroupRequest identifyFromDynamicPersonGroupRequest = new IdentifyFromDynamicPersonGroupRequest(faceIds.ToList(), dynamicPersonGroupId)
            {
                MaxNumOfCandidatesReturned = maxNumOfCandidatesReturned,
                ConfidenceThreshold = confidenceThreshold
            };
            Response response = await IdentifyFromDynamicPersonGroupAsync(identifyFromDynamicPersonGroupRequest.ToRequestContent(), context).ConfigureAwait(false);
            IReadOnlyList<IdentifyResult> value = default;
            using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
            List<IdentifyResult> array = new List<IdentifyResult>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(IdentifyResult.DeserializeIdentifyResult(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary> A remote procedure call (RPC) operation. </summary>
        /// <param name="faceIds"> Array of query faces faceIds, created by the Face - Detect. Each of the faces are identified independently. The valid number of faceIds is between [1, 10]. </param>
        /// <param name="dynamicPersonGroupId"> Id of the target PersonDirectory DynamicPersonGroup to match against. </param>
        /// <param name="maxNumOfCandidatesReturned"> The range of maxNumOfCandidatesReturned is between 1 and 100 (default is 10). </param>
        /// <param name="confidenceThreshold"> Customized identification confidence threshold, in the range of [0, 1]. Advanced user can tweak this value to override default internal threshold for better precision on their scenario data. Note there is no guarantee of this threshold value working on other data and after algorithm updates. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceIds"/> or <paramref name="dynamicPersonGroupId"/> is null. </exception>
        /// <include file="Docs/PersonDirectoryDynamicPersonGroups.xml" path="doc/members/member[@name='IdentifyFromDynamicPersonGroup(IEnumerable{string},string,int?,float?,CancellationToken)']/*" />
        public virtual Response<IReadOnlyList<IdentifyResult>> IdentifyFromDynamicPersonGroup(IEnumerable<string> faceIds, string dynamicPersonGroupId, int? maxNumOfCandidatesReturned = null, float? confidenceThreshold = null, CancellationToken cancellationToken = default)
        {
            if (faceIds == null)
            {
                throw new ArgumentNullException(nameof(faceIds));
            }
            if (dynamicPersonGroupId == null)
            {
                throw new ArgumentNullException(nameof(dynamicPersonGroupId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            IdentifyFromDynamicPersonGroupRequest identifyFromDynamicPersonGroupRequest = new IdentifyFromDynamicPersonGroupRequest(faceIds.ToList(), dynamicPersonGroupId)
            {
                MaxNumOfCandidatesReturned = maxNumOfCandidatesReturned,
                ConfidenceThreshold = confidenceThreshold
            };
            Response response = IdentifyFromDynamicPersonGroup(identifyFromDynamicPersonGroupRequest.ToRequestContent(), context);
            IReadOnlyList<IdentifyResult> value = default;
            using var document = JsonDocument.Parse(response.ContentStream);
            List<IdentifyResult> array = new List<IdentifyResult>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(IdentifyResult.DeserializeIdentifyResult(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// [Protocol Method] A remote procedure call (RPC) operation.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="IdentifyFromDynamicPersonGroupAsync(IEnumerable{string},string,int?,float?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectoryDynamicPersonGroups.xml" path="doc/members/member[@name='IdentifyFromDynamicPersonGroupAsync(RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> IdentifyFromDynamicPersonGroupAsync(RequestContent content, RequestContext context = null)
        {
            if (content == null)
            {
                throw new ArgumentNullException(nameof(content));
            }

            using var scope = ClientDiagnostics.CreateScope("PersonDirectoryDynamicPersonGroups.IdentifyFromDynamicPersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateIdentifyFromDynamicPersonGroupRequest(content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] A remote procedure call (RPC) operation.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="IdentifyFromDynamicPersonGroup(IEnumerable{string},string,int?,float?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectoryDynamicPersonGroups.xml" path="doc/members/member[@name='IdentifyFromDynamicPersonGroup(RequestContent,RequestContext)']/*" />
        public virtual Response IdentifyFromDynamicPersonGroup(RequestContent content, RequestContext context = null)
        {
            if (content == null)
            {
                throw new ArgumentNullException(nameof(content));
            }

            using var scope = ClientDiagnostics.CreateScope("PersonDirectoryDynamicPersonGroups.IdentifyFromDynamicPersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateIdentifyFromDynamicPersonGroupRequest(content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> The most basic operation that applies to a resource. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="resource"> The resource instance. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> or <paramref name="resource"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/PersonDirectoryDynamicPersonGroups.xml" path="doc/members/member[@name='CreateGroupAsync(WaitUntil,string,DynamicPersonGroup,CancellationToken)']/*" />
        public virtual async Task<Operation<DynamicPersonGroup>> CreateGroupAsync(WaitUntil waitUntil, string dynamicPersonGroupId, DynamicPersonGroup resource, CancellationToken cancellationToken = default)
        {
            if (dynamicPersonGroupId == null)
            {
                throw new ArgumentNullException(nameof(dynamicPersonGroupId));
            }
            if (dynamicPersonGroupId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(dynamicPersonGroupId));
            }
            if (resource == null)
            {
                throw new ArgumentNullException(nameof(resource));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = resource.ToRequestContent();
            Operation<BinaryData> response = await CreateGroupAsync(waitUntil, dynamicPersonGroupId, content, context).ConfigureAwait(false);
            return ProtocolOperationHelpers.Convert(response, DynamicPersonGroup.FromResponse, ClientDiagnostics, "PersonDirectoryDynamicPersonGroups.CreateGroup");
        }

        /// <summary> The most basic operation that applies to a resource. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="resource"> The resource instance. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> or <paramref name="resource"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/PersonDirectoryDynamicPersonGroups.xml" path="doc/members/member[@name='CreateGroup(WaitUntil,string,DynamicPersonGroup,CancellationToken)']/*" />
        public virtual Operation<DynamicPersonGroup> CreateGroup(WaitUntil waitUntil, string dynamicPersonGroupId, DynamicPersonGroup resource, CancellationToken cancellationToken = default)
        {
            if (dynamicPersonGroupId == null)
            {
                throw new ArgumentNullException(nameof(dynamicPersonGroupId));
            }
            if (dynamicPersonGroupId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(dynamicPersonGroupId));
            }
            if (resource == null)
            {
                throw new ArgumentNullException(nameof(resource));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = resource.ToRequestContent();
            Operation<BinaryData> response = CreateGroup(waitUntil, dynamicPersonGroupId, content, context);
            return ProtocolOperationHelpers.Convert(response, DynamicPersonGroup.FromResponse, ClientDiagnostics, "PersonDirectoryDynamicPersonGroups.CreateGroup");
        }

        /// <summary>
        /// [Protocol Method] The most basic operation that applies to a resource.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateGroupAsync(WaitUntil,string,DynamicPersonGroup,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/PersonDirectoryDynamicPersonGroups.xml" path="doc/members/member[@name='CreateGroupAsync(WaitUntil,string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Operation<BinaryData>> CreateGroupAsync(WaitUntil waitUntil, string dynamicPersonGroupId, RequestContent content, RequestContext context = null)
        {
            if (dynamicPersonGroupId == null)
            {
                throw new ArgumentNullException(nameof(dynamicPersonGroupId));
            }
            if (dynamicPersonGroupId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(dynamicPersonGroupId));
            }
            if (content == null)
            {
                throw new ArgumentNullException(nameof(content));
            }

            using var scope = ClientDiagnostics.CreateScope("PersonDirectoryDynamicPersonGroups.CreateGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateGroupRequest(dynamicPersonGroupId, content, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "PersonDirectoryDynamicPersonGroups.CreateGroup", OperationFinalStateVia.OriginalUri, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] The most basic operation that applies to a resource.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateGroup(WaitUntil,string,DynamicPersonGroup,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/PersonDirectoryDynamicPersonGroups.xml" path="doc/members/member[@name='CreateGroup(WaitUntil,string,RequestContent,RequestContext)']/*" />
        public virtual Operation<BinaryData> CreateGroup(WaitUntil waitUntil, string dynamicPersonGroupId, RequestContent content, RequestContext context = null)
        {
            if (dynamicPersonGroupId == null)
            {
                throw new ArgumentNullException(nameof(dynamicPersonGroupId));
            }
            if (dynamicPersonGroupId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(dynamicPersonGroupId));
            }
            if (content == null)
            {
                throw new ArgumentNullException(nameof(content));
            }

            using var scope = ClientDiagnostics.CreateScope("PersonDirectoryDynamicPersonGroups.CreateGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateGroupRequest(dynamicPersonGroupId, content, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "PersonDirectoryDynamicPersonGroups.CreateGroup", OperationFinalStateVia.OriginalUri, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] The most basic operation that applies to a resource.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/PersonDirectoryDynamicPersonGroups.xml" path="doc/members/member[@name='DeleteGroupAsync(WaitUntil,string,RequestContext)']/*" />
        public virtual async Task<Operation> DeleteGroupAsync(WaitUntil waitUntil, string dynamicPersonGroupId, RequestContext context = null)
        {
            if (dynamicPersonGroupId == null)
            {
                throw new ArgumentNullException(nameof(dynamicPersonGroupId));
            }
            if (dynamicPersonGroupId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(dynamicPersonGroupId));
            }

            using var scope = ClientDiagnostics.CreateScope("PersonDirectoryDynamicPersonGroups.DeleteGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteGroupRequest(dynamicPersonGroupId, context);
                return await ProtocolOperationHelpers.ProcessMessageWithoutResponseValueAsync(_pipeline, message, ClientDiagnostics, "PersonDirectoryDynamicPersonGroups.DeleteGroup", OperationFinalStateVia.OperationLocation, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] The most basic operation that applies to a resource.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/PersonDirectoryDynamicPersonGroups.xml" path="doc/members/member[@name='DeleteGroup(WaitUntil,string,RequestContext)']/*" />
        public virtual Operation DeleteGroup(WaitUntil waitUntil, string dynamicPersonGroupId, RequestContext context = null)
        {
            if (dynamicPersonGroupId == null)
            {
                throw new ArgumentNullException(nameof(dynamicPersonGroupId));
            }
            if (dynamicPersonGroupId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(dynamicPersonGroupId));
            }

            using var scope = ClientDiagnostics.CreateScope("PersonDirectoryDynamicPersonGroups.DeleteGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteGroupRequest(dynamicPersonGroupId, context);
                return ProtocolOperationHelpers.ProcessMessageWithoutResponseValue(_pipeline, message, ClientDiagnostics, "PersonDirectoryDynamicPersonGroups.DeleteGroup", OperationFinalStateVia.OperationLocation, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] The most basic operation that applies to a resource.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/PersonDirectoryDynamicPersonGroups.xml" path="doc/members/member[@name='UpdateGroupAsync(WaitUntil,string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Operation<BinaryData>> UpdateGroupAsync(WaitUntil waitUntil, string dynamicPersonGroupId, RequestContent content, RequestContext context = null)
        {
            if (dynamicPersonGroupId == null)
            {
                throw new ArgumentNullException(nameof(dynamicPersonGroupId));
            }
            if (dynamicPersonGroupId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(dynamicPersonGroupId));
            }
            if (content == null)
            {
                throw new ArgumentNullException(nameof(content));
            }

            using var scope = ClientDiagnostics.CreateScope("PersonDirectoryDynamicPersonGroups.UpdateGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateGroupRequest(dynamicPersonGroupId, content, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "PersonDirectoryDynamicPersonGroups.UpdateGroup", OperationFinalStateVia.OriginalUri, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] The most basic operation that applies to a resource.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/PersonDirectoryDynamicPersonGroups.xml" path="doc/members/member[@name='UpdateGroup(WaitUntil,string,RequestContent,RequestContext)']/*" />
        public virtual Operation<BinaryData> UpdateGroup(WaitUntil waitUntil, string dynamicPersonGroupId, RequestContent content, RequestContext context = null)
        {
            if (dynamicPersonGroupId == null)
            {
                throw new ArgumentNullException(nameof(dynamicPersonGroupId));
            }
            if (dynamicPersonGroupId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(dynamicPersonGroupId));
            }
            if (content == null)
            {
                throw new ArgumentNullException(nameof(content));
            }

            using var scope = ClientDiagnostics.CreateScope("PersonDirectoryDynamicPersonGroups.UpdateGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateGroupRequest(dynamicPersonGroupId, content, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "PersonDirectoryDynamicPersonGroups.UpdateGroup", OperationFinalStateVia.OriginalUri, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateCreateGroupRequest(string dynamicPersonGroupId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/dynamicpersongroups/", false);
            uri.AppendPath(dynamicPersonGroupId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteGroupRequest(string dynamicPersonGroupId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/dynamicpersongroups/", false);
            uri.AppendPath(dynamicPersonGroupId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetGroupRequest(string dynamicPersonGroupId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/dynamicpersongroups/", false);
            uri.AppendPath(dynamicPersonGroupId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateUpdateGroupRequest(string dynamicPersonGroupId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/dynamicpersongroups/", false);
            uri.AppendPath(dynamicPersonGroupId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetGroupsRequest(string start, int? top, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/dynamicpersongroups", false);
            if (start != null)
            {
                uri.AppendQuery("start", start, true);
            }
            if (top != null)
            {
                uri.AppendQuery("top", top.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetGroupPeopleRequest(string dynamicPersonGroupId, string start, int? top, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/dynamicpersongroups/", false);
            uri.AppendPath(dynamicPersonGroupId, true);
            uri.AppendPath("/persons", false);
            if (start != null)
            {
                uri.AppendQuery("start", start, true);
            }
            if (top != null)
            {
                uri.AppendQuery("top", top.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateIdentifyFromDynamicPersonGroupRequest(RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/identify", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        private static RequestContext DefaultRequestContext = new RequestContext();
        internal static RequestContext FromCancellationToken(CancellationToken cancellationToken = default)
        {
            if (!cancellationToken.CanBeCanceled)
            {
                return DefaultRequestContext;
            }

            return new RequestContext() { CancellationToken = cancellationToken };
        }

        private static ResponseClassifier _responseClassifier200202;
        private static ResponseClassifier ResponseClassifier200202 => _responseClassifier200202 ??= new StatusCodeClassifier(stackalloc ushort[] { 200, 202 });
        private static ResponseClassifier _responseClassifier202;
        private static ResponseClassifier ResponseClassifier202 => _responseClassifier202 ??= new StatusCodeClassifier(stackalloc ushort[] { 202 });
        private static ResponseClassifier _responseClassifier200;
        private static ResponseClassifier ResponseClassifier200 => _responseClassifier200 ??= new StatusCodeClassifier(stackalloc ushort[] { 200 });
    }
}
