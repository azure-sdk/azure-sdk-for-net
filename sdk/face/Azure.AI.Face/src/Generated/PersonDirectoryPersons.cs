// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.AI.Face
{
    // Data plane generated sub-client.
    /// <summary> The PersonDirectoryPersons sub-client. </summary>
    public partial class PersonDirectoryPersons
    {
        private const string AuthorizationHeader = "Ocp-Apim-Subscription-Key";
        private readonly AzureKeyCredential _keyCredential;
        private static readonly string[] AuthorizationScopes = new string[] { "https://cognitiveservices.azure.com/.default" };
        private readonly TokenCredential _tokenCredential;
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;
        private readonly string _apiVersion;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of PersonDirectoryPersons for mocking. </summary>
        protected PersonDirectoryPersons()
        {
        }

        /// <summary> Initializes a new instance of PersonDirectoryPersons. </summary>
        /// <param name="clientDiagnostics"> The handler for diagnostic messaging in the client. </param>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="keyCredential"> The key credential to copy. </param>
        /// <param name="tokenCredential"> The token credential to copy. </param>
        /// <param name="endpoint">
        /// Supported Cognitive Services endpoints (protocol and hostname, for example:
        /// https://&lt;resource-name&gt;.cognitiveservices.azure.com).
        /// </param>
        /// <param name="apiVersion"> The API version to use for this operation. </param>
        internal PersonDirectoryPersons(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, AzureKeyCredential keyCredential, TokenCredential tokenCredential, Uri endpoint, string apiVersion)
        {
            ClientDiagnostics = clientDiagnostics;
            _pipeline = pipeline;
            _keyCredential = keyCredential;
            _tokenCredential = tokenCredential;
            _endpoint = endpoint;
            _apiVersion = apiVersion;
        }

        /// <summary> Resource read operation template. </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='GetPersonAsync(string,CancellationToken)']/*" />
        public virtual async Task<Response<PersonDirectoryPerson>> GetPersonAsync(string personId, CancellationToken cancellationToken = default)
        {
            if (personId == null)
            {
                throw new ArgumentNullException(nameof(personId));
            }
            if (personId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(personId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetPersonAsync(personId, context).ConfigureAwait(false);
            return Response.FromValue(PersonDirectoryPerson.FromResponse(response), response);
        }

        /// <summary> Resource read operation template. </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='GetPerson(string,CancellationToken)']/*" />
        public virtual Response<PersonDirectoryPerson> GetPerson(string personId, CancellationToken cancellationToken = default)
        {
            if (personId == null)
            {
                throw new ArgumentNullException(nameof(personId));
            }
            if (personId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(personId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetPerson(personId, context);
            return Response.FromValue(PersonDirectoryPerson.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Resource read operation template.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPersonAsync(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='GetPersonAsync(string,RequestContext)']/*" />
        public virtual async Task<Response> GetPersonAsync(string personId, RequestContext context)
        {
            if (personId == null)
            {
                throw new ArgumentNullException(nameof(personId));
            }
            if (personId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(personId));
            }

            using var scope = ClientDiagnostics.CreateScope("PersonDirectoryPersons.GetPerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPersonRequest(personId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Resource read operation template.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPerson(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='GetPerson(string,RequestContext)']/*" />
        public virtual Response GetPerson(string personId, RequestContext context)
        {
            if (personId == null)
            {
                throw new ArgumentNullException(nameof(personId));
            }
            if (personId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(personId));
            }

            using var scope = ClientDiagnostics.CreateScope("PersonDirectoryPersons.GetPerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPersonRequest(personId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] The most basic operation that applies to a resource.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='UpdatePersonAsync(string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> UpdatePersonAsync(string personId, RequestContent content, RequestContext context = null)
        {
            if (personId == null)
            {
                throw new ArgumentNullException(nameof(personId));
            }
            if (personId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(personId));
            }
            if (content == null)
            {
                throw new ArgumentNullException(nameof(content));
            }

            using var scope = ClientDiagnostics.CreateScope("PersonDirectoryPersons.UpdatePerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdatePersonRequest(personId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] The most basic operation that applies to a resource.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='UpdatePerson(string,RequestContent,RequestContext)']/*" />
        public virtual Response UpdatePerson(string personId, RequestContent content, RequestContext context = null)
        {
            if (personId == null)
            {
                throw new ArgumentNullException(nameof(personId));
            }
            if (personId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(personId));
            }
            if (content == null)
            {
                throw new ArgumentNullException(nameof(content));
            }

            using var scope = ClientDiagnostics.CreateScope("PersonDirectoryPersons.UpdatePerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdatePersonRequest(personId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Operation that lists resources in a paginated way. </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='GetPeopleAsync(string,int?,CancellationToken)']/*" />
        public virtual async Task<Response<IReadOnlyList<PersonDirectoryPerson>>> GetPeopleAsync(string start = null, int? top = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetPeopleAsync(start, top, context).ConfigureAwait(false);
            IReadOnlyList<PersonDirectoryPerson> value = default;
            using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
            List<PersonDirectoryPerson> array = new List<PersonDirectoryPerson>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(PersonDirectoryPerson.DeserializePersonDirectoryPerson(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary> Operation that lists resources in a paginated way. </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='GetPeople(string,int?,CancellationToken)']/*" />
        public virtual Response<IReadOnlyList<PersonDirectoryPerson>> GetPeople(string start = null, int? top = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetPeople(start, top, context);
            IReadOnlyList<PersonDirectoryPerson> value = default;
            using var document = JsonDocument.Parse(response.ContentStream);
            List<PersonDirectoryPerson> array = new List<PersonDirectoryPerson>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(PersonDirectoryPerson.DeserializePersonDirectoryPerson(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// [Protocol Method] Operation that lists resources in a paginated way.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPeopleAsync(string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='GetPeopleAsync(string,int?,RequestContext)']/*" />
        public virtual async Task<Response> GetPeopleAsync(string start, int? top, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("PersonDirectoryPersons.GetPeople");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPeopleRequest(start, top, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Operation that lists resources in a paginated way.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPeople(string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='GetPeople(string,int?,RequestContext)']/*" />
        public virtual Response GetPeople(string start, int? top, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("PersonDirectoryPersons.GetPeople");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPeopleRequest(start, top, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> The most basic operation that applies to a resource. </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='GetGroupReferencesAsync(string,string,int?,CancellationToken)']/*" />
        public virtual async Task<Response<ListGroupReferenceResult>> GetGroupReferencesAsync(string personId, string start = null, int? top = null, CancellationToken cancellationToken = default)
        {
            if (personId == null)
            {
                throw new ArgumentNullException(nameof(personId));
            }
            if (personId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(personId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetGroupReferencesAsync(personId, start, top, context).ConfigureAwait(false);
            return Response.FromValue(ListGroupReferenceResult.FromResponse(response), response);
        }

        /// <summary> The most basic operation that applies to a resource. </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='GetGroupReferences(string,string,int?,CancellationToken)']/*" />
        public virtual Response<ListGroupReferenceResult> GetGroupReferences(string personId, string start = null, int? top = null, CancellationToken cancellationToken = default)
        {
            if (personId == null)
            {
                throw new ArgumentNullException(nameof(personId));
            }
            if (personId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(personId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetGroupReferences(personId, start, top, context);
            return Response.FromValue(ListGroupReferenceResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] The most basic operation that applies to a resource.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetGroupReferencesAsync(string,string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='GetGroupReferencesAsync(string,string,int?,RequestContext)']/*" />
        public virtual async Task<Response> GetGroupReferencesAsync(string personId, string start, int? top, RequestContext context)
        {
            if (personId == null)
            {
                throw new ArgumentNullException(nameof(personId));
            }
            if (personId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(personId));
            }

            using var scope = ClientDiagnostics.CreateScope("PersonDirectoryPersons.GetGroupReferences");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetGroupReferencesRequest(personId, start, top, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] The most basic operation that applies to a resource.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetGroupReferences(string,string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='GetGroupReferences(string,string,int?,RequestContext)']/*" />
        public virtual Response GetGroupReferences(string personId, string start, int? top, RequestContext context)
        {
            if (personId == null)
            {
                throw new ArgumentNullException(nameof(personId));
            }
            if (personId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(personId));
            }

            using var scope = ClientDiagnostics.CreateScope("PersonDirectoryPersons.GetGroupReferences");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetGroupReferencesRequest(personId, start, top, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Resource read operation template. </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> or <paramref name="persistedFaceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='GetFaceAsync(string,RecognitionModel,string,CancellationToken)']/*" />
        public virtual async Task<Response<PersonDirectoryFace>> GetFaceAsync(string personId, RecognitionModel recognitionModel, string persistedFaceId, CancellationToken cancellationToken = default)
        {
            if (personId == null)
            {
                throw new ArgumentNullException(nameof(personId));
            }
            if (personId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(personId));
            }
            if (persistedFaceId == null)
            {
                throw new ArgumentNullException(nameof(persistedFaceId));
            }
            if (persistedFaceId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(persistedFaceId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetFaceAsync(personId, recognitionModel.ToString(), persistedFaceId, context).ConfigureAwait(false);
            return Response.FromValue(PersonDirectoryFace.FromResponse(response), response);
        }

        /// <summary> Resource read operation template. </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> or <paramref name="persistedFaceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='GetFace(string,RecognitionModel,string,CancellationToken)']/*" />
        public virtual Response<PersonDirectoryFace> GetFace(string personId, RecognitionModel recognitionModel, string persistedFaceId, CancellationToken cancellationToken = default)
        {
            if (personId == null)
            {
                throw new ArgumentNullException(nameof(personId));
            }
            if (personId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(personId));
            }
            if (persistedFaceId == null)
            {
                throw new ArgumentNullException(nameof(persistedFaceId));
            }
            if (persistedFaceId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(persistedFaceId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetFace(personId, recognitionModel.ToString(), persistedFaceId, context);
            return Response.FromValue(PersonDirectoryFace.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Resource read operation template.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetFaceAsync(string,RecognitionModel,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/>, <paramref name="recognitionModel"/> or <paramref name="persistedFaceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/>, <paramref name="recognitionModel"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='GetFaceAsync(string,string,string,RequestContext)']/*" />
        public virtual async Task<Response> GetFaceAsync(string personId, string recognitionModel, string persistedFaceId, RequestContext context = null)
        {
            if (personId == null)
            {
                throw new ArgumentNullException(nameof(personId));
            }
            if (personId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(personId));
            }
            if (recognitionModel == null)
            {
                throw new ArgumentNullException(nameof(recognitionModel));
            }
            if (recognitionModel.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(recognitionModel));
            }
            if (persistedFaceId == null)
            {
                throw new ArgumentNullException(nameof(persistedFaceId));
            }
            if (persistedFaceId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(persistedFaceId));
            }

            using var scope = ClientDiagnostics.CreateScope("PersonDirectoryPersons.GetFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetFaceRequest(personId, recognitionModel, persistedFaceId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Resource read operation template.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetFace(string,RecognitionModel,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/>, <paramref name="recognitionModel"/> or <paramref name="persistedFaceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/>, <paramref name="recognitionModel"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='GetFace(string,string,string,RequestContext)']/*" />
        public virtual Response GetFace(string personId, string recognitionModel, string persistedFaceId, RequestContext context = null)
        {
            if (personId == null)
            {
                throw new ArgumentNullException(nameof(personId));
            }
            if (personId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(personId));
            }
            if (recognitionModel == null)
            {
                throw new ArgumentNullException(nameof(recognitionModel));
            }
            if (recognitionModel.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(recognitionModel));
            }
            if (persistedFaceId == null)
            {
                throw new ArgumentNullException(nameof(persistedFaceId));
            }
            if (persistedFaceId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(persistedFaceId));
            }

            using var scope = ClientDiagnostics.CreateScope("PersonDirectoryPersons.GetFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetFaceRequest(personId, recognitionModel, persistedFaceId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] The most basic operation that applies to a resource.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/>, <paramref name="recognitionModel"/>, <paramref name="persistedFaceId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/>, <paramref name="recognitionModel"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='UpdateFaceAsync(string,string,string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> UpdateFaceAsync(string personId, string recognitionModel, string persistedFaceId, RequestContent content, RequestContext context = null)
        {
            if (personId == null)
            {
                throw new ArgumentNullException(nameof(personId));
            }
            if (personId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(personId));
            }
            if (recognitionModel == null)
            {
                throw new ArgumentNullException(nameof(recognitionModel));
            }
            if (recognitionModel.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(recognitionModel));
            }
            if (persistedFaceId == null)
            {
                throw new ArgumentNullException(nameof(persistedFaceId));
            }
            if (persistedFaceId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(persistedFaceId));
            }
            if (content == null)
            {
                throw new ArgumentNullException(nameof(content));
            }

            using var scope = ClientDiagnostics.CreateScope("PersonDirectoryPersons.UpdateFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateFaceRequest(personId, recognitionModel, persistedFaceId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] The most basic operation that applies to a resource.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/>, <paramref name="recognitionModel"/>, <paramref name="persistedFaceId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/>, <paramref name="recognitionModel"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='UpdateFace(string,string,string,RequestContent,RequestContext)']/*" />
        public virtual Response UpdateFace(string personId, string recognitionModel, string persistedFaceId, RequestContent content, RequestContext context = null)
        {
            if (personId == null)
            {
                throw new ArgumentNullException(nameof(personId));
            }
            if (personId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(personId));
            }
            if (recognitionModel == null)
            {
                throw new ArgumentNullException(nameof(recognitionModel));
            }
            if (recognitionModel.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(recognitionModel));
            }
            if (persistedFaceId == null)
            {
                throw new ArgumentNullException(nameof(persistedFaceId));
            }
            if (persistedFaceId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(persistedFaceId));
            }
            if (content == null)
            {
                throw new ArgumentNullException(nameof(content));
            }

            using var scope = ClientDiagnostics.CreateScope("PersonDirectoryPersons.UpdateFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateFaceRequest(personId, recognitionModel, persistedFaceId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Operation that lists resources in a paginated way. </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='GetFacesAsync(string,RecognitionModel,CancellationToken)']/*" />
        public virtual async Task<Response<ListFaceResult>> GetFacesAsync(string personId, RecognitionModel recognitionModel, CancellationToken cancellationToken = default)
        {
            if (personId == null)
            {
                throw new ArgumentNullException(nameof(personId));
            }
            if (personId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(personId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetFacesAsync(personId, recognitionModel.ToString(), context).ConfigureAwait(false);
            return Response.FromValue(ListFaceResult.FromResponse(response), response);
        }

        /// <summary> Operation that lists resources in a paginated way. </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='GetFaces(string,RecognitionModel,CancellationToken)']/*" />
        public virtual Response<ListFaceResult> GetFaces(string personId, RecognitionModel recognitionModel, CancellationToken cancellationToken = default)
        {
            if (personId == null)
            {
                throw new ArgumentNullException(nameof(personId));
            }
            if (personId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(personId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetFaces(personId, recognitionModel.ToString(), context);
            return Response.FromValue(ListFaceResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Operation that lists resources in a paginated way.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetFacesAsync(string,RecognitionModel,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> or <paramref name="recognitionModel"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> or <paramref name="recognitionModel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='GetFacesAsync(string,string,RequestContext)']/*" />
        public virtual async Task<Response> GetFacesAsync(string personId, string recognitionModel, RequestContext context = null)
        {
            if (personId == null)
            {
                throw new ArgumentNullException(nameof(personId));
            }
            if (personId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(personId));
            }
            if (recognitionModel == null)
            {
                throw new ArgumentNullException(nameof(recognitionModel));
            }
            if (recognitionModel.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(recognitionModel));
            }

            using var scope = ClientDiagnostics.CreateScope("PersonDirectoryPersons.GetFaces");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetFacesRequest(personId, recognitionModel, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Operation that lists resources in a paginated way.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetFaces(string,RecognitionModel,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> or <paramref name="recognitionModel"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> or <paramref name="recognitionModel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='GetFaces(string,string,RequestContext)']/*" />
        public virtual Response GetFaces(string personId, string recognitionModel, RequestContext context = null)
        {
            if (personId == null)
            {
                throw new ArgumentNullException(nameof(personId));
            }
            if (personId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(personId));
            }
            if (recognitionModel == null)
            {
                throw new ArgumentNullException(nameof(recognitionModel));
            }
            if (recognitionModel.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(recognitionModel));
            }

            using var scope = ClientDiagnostics.CreateScope("PersonDirectoryPersons.GetFaces");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetFacesRequest(personId, recognitionModel, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> A remote procedure call (RPC) operation. </summary>
        /// <param name="faceIds"> Array of query faces faceIds, created by the Face - Detect. Each of the faces are identified independently. The valid number of faceIds is between [1, 10]. </param>
        /// <param name="personIds"> Array of personIds created in PersonDirectory - PersonCreate. The valid number of personIds is between [1,30]. </param>
        /// <param name="maxNumOfCandidatesReturned"> The range of maxNumOfCandidatesReturned is between 1 and 100 (default is 10). </param>
        /// <param name="confidenceThreshold"> Customized identification confidence threshold, in the range of [0, 1]. Advanced user can tweak this value to override default internal threshold for better precision on their scenario data. Note there is no guarantee of this threshold value working on other data and after algorithm updates. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceIds"/> or <paramref name="personIds"/> is null. </exception>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='IdentifyFromPersonDirectoryAsync(IEnumerable{string},IEnumerable{string},int?,float?,CancellationToken)']/*" />
        public virtual async Task<Response<IReadOnlyList<IdentifyResult>>> IdentifyFromPersonDirectoryAsync(IEnumerable<string> faceIds, IEnumerable<string> personIds, int? maxNumOfCandidatesReturned = null, float? confidenceThreshold = null, CancellationToken cancellationToken = default)
        {
            if (faceIds == null)
            {
                throw new ArgumentNullException(nameof(faceIds));
            }
            if (personIds == null)
            {
                throw new ArgumentNullException(nameof(personIds));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            IdentifyFromPersonDirectoryRequest identifyFromPersonDirectoryRequest = new IdentifyFromPersonDirectoryRequest(faceIds.ToList(), personIds.ToList())
            {
                MaxNumOfCandidatesReturned = maxNumOfCandidatesReturned,
                ConfidenceThreshold = confidenceThreshold
            };
            Response response = await IdentifyFromPersonDirectoryAsync(identifyFromPersonDirectoryRequest.ToRequestContent(), context).ConfigureAwait(false);
            IReadOnlyList<IdentifyResult> value = default;
            using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
            List<IdentifyResult> array = new List<IdentifyResult>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(IdentifyResult.DeserializeIdentifyResult(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary> A remote procedure call (RPC) operation. </summary>
        /// <param name="faceIds"> Array of query faces faceIds, created by the Face - Detect. Each of the faces are identified independently. The valid number of faceIds is between [1, 10]. </param>
        /// <param name="personIds"> Array of personIds created in PersonDirectory - PersonCreate. The valid number of personIds is between [1,30]. </param>
        /// <param name="maxNumOfCandidatesReturned"> The range of maxNumOfCandidatesReturned is between 1 and 100 (default is 10). </param>
        /// <param name="confidenceThreshold"> Customized identification confidence threshold, in the range of [0, 1]. Advanced user can tweak this value to override default internal threshold for better precision on their scenario data. Note there is no guarantee of this threshold value working on other data and after algorithm updates. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceIds"/> or <paramref name="personIds"/> is null. </exception>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='IdentifyFromPersonDirectory(IEnumerable{string},IEnumerable{string},int?,float?,CancellationToken)']/*" />
        public virtual Response<IReadOnlyList<IdentifyResult>> IdentifyFromPersonDirectory(IEnumerable<string> faceIds, IEnumerable<string> personIds, int? maxNumOfCandidatesReturned = null, float? confidenceThreshold = null, CancellationToken cancellationToken = default)
        {
            if (faceIds == null)
            {
                throw new ArgumentNullException(nameof(faceIds));
            }
            if (personIds == null)
            {
                throw new ArgumentNullException(nameof(personIds));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            IdentifyFromPersonDirectoryRequest identifyFromPersonDirectoryRequest = new IdentifyFromPersonDirectoryRequest(faceIds.ToList(), personIds.ToList())
            {
                MaxNumOfCandidatesReturned = maxNumOfCandidatesReturned,
                ConfidenceThreshold = confidenceThreshold
            };
            Response response = IdentifyFromPersonDirectory(identifyFromPersonDirectoryRequest.ToRequestContent(), context);
            IReadOnlyList<IdentifyResult> value = default;
            using var document = JsonDocument.Parse(response.ContentStream);
            List<IdentifyResult> array = new List<IdentifyResult>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(IdentifyResult.DeserializeIdentifyResult(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// [Protocol Method] A remote procedure call (RPC) operation.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="IdentifyFromPersonDirectoryAsync(IEnumerable{string},IEnumerable{string},int?,float?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='IdentifyFromPersonDirectoryAsync(RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> IdentifyFromPersonDirectoryAsync(RequestContent content, RequestContext context = null)
        {
            if (content == null)
            {
                throw new ArgumentNullException(nameof(content));
            }

            using var scope = ClientDiagnostics.CreateScope("PersonDirectoryPersons.IdentifyFromPersonDirectory");
            scope.Start();
            try
            {
                using HttpMessage message = CreateIdentifyFromPersonDirectoryRequest(content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] A remote procedure call (RPC) operation.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="IdentifyFromPersonDirectory(IEnumerable{string},IEnumerable{string},int?,float?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='IdentifyFromPersonDirectory(RequestContent,RequestContext)']/*" />
        public virtual Response IdentifyFromPersonDirectory(RequestContent content, RequestContext context = null)
        {
            if (content == null)
            {
                throw new ArgumentNullException(nameof(content));
            }

            using var scope = ClientDiagnostics.CreateScope("PersonDirectoryPersons.IdentifyFromPersonDirectory");
            scope.Start();
            try
            {
                using HttpMessage message = CreateIdentifyFromPersonDirectoryRequest(content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> A remote procedure call (RPC) operation. </summary>
        /// <param name="faceId"> faceId of the face, comes from Face - Detect. </param>
        /// <param name="personId"> Specify a certain person in PersonDirectory Person. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceId"/> or <paramref name="personId"/> is null. </exception>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='VerifyFromPersonDirectoryAsync(string,string,CancellationToken)']/*" />
        public virtual async Task<Response<VerifyResult>> VerifyFromPersonDirectoryAsync(string faceId, string personId, CancellationToken cancellationToken = default)
        {
            if (faceId == null)
            {
                throw new ArgumentNullException(nameof(faceId));
            }
            if (personId == null)
            {
                throw new ArgumentNullException(nameof(personId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            VerifyFromPersonDirectoryRequest verifyFromPersonDirectoryRequest = new VerifyFromPersonDirectoryRequest(faceId, personId);
            Response response = await VerifyFromPersonDirectoryAsync(verifyFromPersonDirectoryRequest.ToRequestContent(), context).ConfigureAwait(false);
            return Response.FromValue(VerifyResult.FromResponse(response), response);
        }

        /// <summary> A remote procedure call (RPC) operation. </summary>
        /// <param name="faceId"> faceId of the face, comes from Face - Detect. </param>
        /// <param name="personId"> Specify a certain person in PersonDirectory Person. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceId"/> or <paramref name="personId"/> is null. </exception>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='VerifyFromPersonDirectory(string,string,CancellationToken)']/*" />
        public virtual Response<VerifyResult> VerifyFromPersonDirectory(string faceId, string personId, CancellationToken cancellationToken = default)
        {
            if (faceId == null)
            {
                throw new ArgumentNullException(nameof(faceId));
            }
            if (personId == null)
            {
                throw new ArgumentNullException(nameof(personId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            VerifyFromPersonDirectoryRequest verifyFromPersonDirectoryRequest = new VerifyFromPersonDirectoryRequest(faceId, personId);
            Response response = VerifyFromPersonDirectory(verifyFromPersonDirectoryRequest.ToRequestContent(), context);
            return Response.FromValue(VerifyResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] A remote procedure call (RPC) operation.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="VerifyFromPersonDirectoryAsync(string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='VerifyFromPersonDirectoryAsync(RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> VerifyFromPersonDirectoryAsync(RequestContent content, RequestContext context = null)
        {
            if (content == null)
            {
                throw new ArgumentNullException(nameof(content));
            }

            using var scope = ClientDiagnostics.CreateScope("PersonDirectoryPersons.VerifyFromPersonDirectory");
            scope.Start();
            try
            {
                using HttpMessage message = CreateVerifyFromPersonDirectoryRequest(content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] A remote procedure call (RPC) operation.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="VerifyFromPersonDirectory(string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='VerifyFromPersonDirectory(RequestContent,RequestContext)']/*" />
        public virtual Response VerifyFromPersonDirectory(RequestContent content, RequestContext context = null)
        {
            if (content == null)
            {
                throw new ArgumentNullException(nameof(content));
            }

            using var scope = ClientDiagnostics.CreateScope("PersonDirectoryPersons.VerifyFromPersonDirectory");
            scope.Start();
            try
            {
                using HttpMessage message = CreateVerifyFromPersonDirectoryRequest(content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Operation that applies to a collection of resources. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="resource"> The resource instance. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resource"/> is null. </exception>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='CreatePersonAsync(WaitUntil,PersonDirectoryPerson,CancellationToken)']/*" />
        public virtual async Task<Operation<CreatePersonResult>> CreatePersonAsync(WaitUntil waitUntil, PersonDirectoryPerson resource, CancellationToken cancellationToken = default)
        {
            if (resource == null)
            {
                throw new ArgumentNullException(nameof(resource));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = resource.ToRequestContent();
            Operation<BinaryData> response = await CreatePersonAsync(waitUntil, content, context).ConfigureAwait(false);
            return ProtocolOperationHelpers.Convert(response, CreatePersonResult.FromResponse, ClientDiagnostics, "PersonDirectoryPersons.CreatePerson");
        }

        /// <summary> Operation that applies to a collection of resources. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="resource"> The resource instance. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resource"/> is null. </exception>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='CreatePerson(WaitUntil,PersonDirectoryPerson,CancellationToken)']/*" />
        public virtual Operation<CreatePersonResult> CreatePerson(WaitUntil waitUntil, PersonDirectoryPerson resource, CancellationToken cancellationToken = default)
        {
            if (resource == null)
            {
                throw new ArgumentNullException(nameof(resource));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = resource.ToRequestContent();
            Operation<BinaryData> response = CreatePerson(waitUntil, content, context);
            return ProtocolOperationHelpers.Convert(response, CreatePersonResult.FromResponse, ClientDiagnostics, "PersonDirectoryPersons.CreatePerson");
        }

        /// <summary>
        /// [Protocol Method] Operation that applies to a collection of resources.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreatePersonAsync(WaitUntil,PersonDirectoryPerson,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='CreatePersonAsync(WaitUntil,RequestContent,RequestContext)']/*" />
        public virtual async Task<Operation<BinaryData>> CreatePersonAsync(WaitUntil waitUntil, RequestContent content, RequestContext context = null)
        {
            if (content == null)
            {
                throw new ArgumentNullException(nameof(content));
            }

            using var scope = ClientDiagnostics.CreateScope("PersonDirectoryPersons.CreatePerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreatePersonRequest(content, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "PersonDirectoryPersons.CreatePerson", OperationFinalStateVia.OriginalUri, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Operation that applies to a collection of resources.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreatePerson(WaitUntil,PersonDirectoryPerson,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='CreatePerson(WaitUntil,RequestContent,RequestContext)']/*" />
        public virtual Operation<BinaryData> CreatePerson(WaitUntil waitUntil, RequestContent content, RequestContext context = null)
        {
            if (content == null)
            {
                throw new ArgumentNullException(nameof(content));
            }

            using var scope = ClientDiagnostics.CreateScope("PersonDirectoryPersons.CreatePerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreatePersonRequest(content, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "PersonDirectoryPersons.CreatePerson", OperationFinalStateVia.OriginalUri, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] The most basic operation that applies to a resource.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='DeletePersonAsync(WaitUntil,string,RequestContext)']/*" />
        public virtual async Task<Operation> DeletePersonAsync(WaitUntil waitUntil, string personId, RequestContext context = null)
        {
            if (personId == null)
            {
                throw new ArgumentNullException(nameof(personId));
            }
            if (personId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(personId));
            }

            using var scope = ClientDiagnostics.CreateScope("PersonDirectoryPersons.DeletePerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeletePersonRequest(personId, context);
                return await ProtocolOperationHelpers.ProcessMessageWithoutResponseValueAsync(_pipeline, message, ClientDiagnostics, "PersonDirectoryPersons.DeletePerson", OperationFinalStateVia.OperationLocation, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] The most basic operation that applies to a resource.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='DeletePerson(WaitUntil,string,RequestContext)']/*" />
        public virtual Operation DeletePerson(WaitUntil waitUntil, string personId, RequestContext context = null)
        {
            if (personId == null)
            {
                throw new ArgumentNullException(nameof(personId));
            }
            if (personId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(personId));
            }

            using var scope = ClientDiagnostics.CreateScope("PersonDirectoryPersons.DeletePerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeletePersonRequest(personId, context);
                return ProtocolOperationHelpers.ProcessMessageWithoutResponseValue(_pipeline, message, ClientDiagnostics, "PersonDirectoryPersons.DeletePerson", OperationFinalStateVia.OperationLocation, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Operation that applies to a collection of resources. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. </param>
        /// <param name="body"> The body type of the operation request or response. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='AddFaceFromUrlAsync(WaitUntil,string,RecognitionModel,AddFaceFromUrlContent,string,DetectionModel?,string,CancellationToken)']/*" />
        public virtual async Task<Operation<AddFaceResult>> AddFaceFromUrlAsync(WaitUntil waitUntil, string personId, RecognitionModel recognitionModel, AddFaceFromUrlContent body, string targetFace = null, DetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            if (personId == null)
            {
                throw new ArgumentNullException(nameof(personId));
            }
            if (personId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(personId));
            }
            if (body == null)
            {
                throw new ArgumentNullException(nameof(body));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = body.ToRequestContent();
            Operation<BinaryData> response = await AddFaceFromUrlAsync(waitUntil, personId, recognitionModel.ToString(), content, targetFace, detectionModel?.ToString(), userData, context).ConfigureAwait(false);
            return ProtocolOperationHelpers.Convert(response, AddFaceResult.FromResponse, ClientDiagnostics, "PersonDirectoryPersons.AddFaceFromUrl");
        }

        /// <summary> Operation that applies to a collection of resources. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. </param>
        /// <param name="body"> The body type of the operation request or response. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='AddFaceFromUrl(WaitUntil,string,RecognitionModel,AddFaceFromUrlContent,string,DetectionModel?,string,CancellationToken)']/*" />
        public virtual Operation<AddFaceResult> AddFaceFromUrl(WaitUntil waitUntil, string personId, RecognitionModel recognitionModel, AddFaceFromUrlContent body, string targetFace = null, DetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            if (personId == null)
            {
                throw new ArgumentNullException(nameof(personId));
            }
            if (personId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(personId));
            }
            if (body == null)
            {
                throw new ArgumentNullException(nameof(body));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = body.ToRequestContent();
            Operation<BinaryData> response = AddFaceFromUrl(waitUntil, personId, recognitionModel.ToString(), content, targetFace, detectionModel?.ToString(), userData, context);
            return ProtocolOperationHelpers.Convert(response, AddFaceResult.FromResponse, ClientDiagnostics, "PersonDirectoryPersons.AddFaceFromUrl");
        }

        /// <summary>
        /// [Protocol Method] Operation that applies to a collection of resources.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddFaceFromUrlAsync(WaitUntil,string,RecognitionModel,AddFaceFromUrlContent,string,DetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/>, <paramref name="recognitionModel"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> or <paramref name="recognitionModel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='AddFaceFromUrlAsync(WaitUntil,string,string,RequestContent,string,string,string,RequestContext)']/*" />
        public virtual async Task<Operation<BinaryData>> AddFaceFromUrlAsync(WaitUntil waitUntil, string personId, string recognitionModel, RequestContent content, string targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            if (personId == null)
            {
                throw new ArgumentNullException(nameof(personId));
            }
            if (personId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(personId));
            }
            if (recognitionModel == null)
            {
                throw new ArgumentNullException(nameof(recognitionModel));
            }
            if (recognitionModel.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(recognitionModel));
            }
            if (content == null)
            {
                throw new ArgumentNullException(nameof(content));
            }

            using var scope = ClientDiagnostics.CreateScope("PersonDirectoryPersons.AddFaceFromUrl");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddFaceFromUrlRequest(personId, recognitionModel, content, targetFace, detectionModel, userData, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "PersonDirectoryPersons.AddFaceFromUrl", OperationFinalStateVia.OriginalUri, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Operation that applies to a collection of resources.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddFaceFromUrl(WaitUntil,string,RecognitionModel,AddFaceFromUrlContent,string,DetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/>, <paramref name="recognitionModel"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> or <paramref name="recognitionModel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='AddFaceFromUrl(WaitUntil,string,string,RequestContent,string,string,string,RequestContext)']/*" />
        public virtual Operation<BinaryData> AddFaceFromUrl(WaitUntil waitUntil, string personId, string recognitionModel, RequestContent content, string targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            if (personId == null)
            {
                throw new ArgumentNullException(nameof(personId));
            }
            if (personId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(personId));
            }
            if (recognitionModel == null)
            {
                throw new ArgumentNullException(nameof(recognitionModel));
            }
            if (recognitionModel.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(recognitionModel));
            }
            if (content == null)
            {
                throw new ArgumentNullException(nameof(content));
            }

            using var scope = ClientDiagnostics.CreateScope("PersonDirectoryPersons.AddFaceFromUrl");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddFaceFromUrlRequest(personId, recognitionModel, content, targetFace, detectionModel, userData, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "PersonDirectoryPersons.AddFaceFromUrl", OperationFinalStateVia.OriginalUri, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Operation that applies to a collection of resources. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. </param>
        /// <param name="imageContent"> The image to be analyzed. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> or <paramref name="imageContent"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='AddFaceFromStreamAsync(WaitUntil,string,RecognitionModel,BinaryData,string,DetectionModel?,string,CancellationToken)']/*" />
        public virtual async Task<Operation<AddFaceResult>> AddFaceFromStreamAsync(WaitUntil waitUntil, string personId, RecognitionModel recognitionModel, BinaryData imageContent, string targetFace = null, DetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            if (personId == null)
            {
                throw new ArgumentNullException(nameof(personId));
            }
            if (personId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(personId));
            }
            if (imageContent == null)
            {
                throw new ArgumentNullException(nameof(imageContent));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = imageContent;
            Operation<BinaryData> response = await AddFaceFromStreamAsync(waitUntil, personId, recognitionModel.ToString(), content, targetFace, detectionModel?.ToString(), userData, context).ConfigureAwait(false);
            return ProtocolOperationHelpers.Convert(response, AddFaceResult.FromResponse, ClientDiagnostics, "PersonDirectoryPersons.AddFaceFromStream");
        }

        /// <summary> Operation that applies to a collection of resources. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. </param>
        /// <param name="imageContent"> The image to be analyzed. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> or <paramref name="imageContent"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='AddFaceFromStream(WaitUntil,string,RecognitionModel,BinaryData,string,DetectionModel?,string,CancellationToken)']/*" />
        public virtual Operation<AddFaceResult> AddFaceFromStream(WaitUntil waitUntil, string personId, RecognitionModel recognitionModel, BinaryData imageContent, string targetFace = null, DetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            if (personId == null)
            {
                throw new ArgumentNullException(nameof(personId));
            }
            if (personId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(personId));
            }
            if (imageContent == null)
            {
                throw new ArgumentNullException(nameof(imageContent));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = imageContent;
            Operation<BinaryData> response = AddFaceFromStream(waitUntil, personId, recognitionModel.ToString(), content, targetFace, detectionModel?.ToString(), userData, context);
            return ProtocolOperationHelpers.Convert(response, AddFaceResult.FromResponse, ClientDiagnostics, "PersonDirectoryPersons.AddFaceFromStream");
        }

        /// <summary>
        /// [Protocol Method] Operation that applies to a collection of resources.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddFaceFromStreamAsync(WaitUntil,string,RecognitionModel,BinaryData,string,DetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/>, <paramref name="recognitionModel"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> or <paramref name="recognitionModel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='AddFaceFromStreamAsync(WaitUntil,string,string,RequestContent,string,string,string,RequestContext)']/*" />
        public virtual async Task<Operation<BinaryData>> AddFaceFromStreamAsync(WaitUntil waitUntil, string personId, string recognitionModel, RequestContent content, string targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            if (personId == null)
            {
                throw new ArgumentNullException(nameof(personId));
            }
            if (personId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(personId));
            }
            if (recognitionModel == null)
            {
                throw new ArgumentNullException(nameof(recognitionModel));
            }
            if (recognitionModel.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(recognitionModel));
            }
            if (content == null)
            {
                throw new ArgumentNullException(nameof(content));
            }

            using var scope = ClientDiagnostics.CreateScope("PersonDirectoryPersons.AddFaceFromStream");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddFaceFromStreamRequest(personId, recognitionModel, content, targetFace, detectionModel, userData, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "PersonDirectoryPersons.AddFaceFromStream", OperationFinalStateVia.OriginalUri, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Operation that applies to a collection of resources.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddFaceFromStream(WaitUntil,string,RecognitionModel,BinaryData,string,DetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/>, <paramref name="recognitionModel"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> or <paramref name="recognitionModel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='AddFaceFromStream(WaitUntil,string,string,RequestContent,string,string,string,RequestContext)']/*" />
        public virtual Operation<BinaryData> AddFaceFromStream(WaitUntil waitUntil, string personId, string recognitionModel, RequestContent content, string targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            if (personId == null)
            {
                throw new ArgumentNullException(nameof(personId));
            }
            if (personId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(personId));
            }
            if (recognitionModel == null)
            {
                throw new ArgumentNullException(nameof(recognitionModel));
            }
            if (recognitionModel.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(recognitionModel));
            }
            if (content == null)
            {
                throw new ArgumentNullException(nameof(content));
            }

            using var scope = ClientDiagnostics.CreateScope("PersonDirectoryPersons.AddFaceFromStream");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddFaceFromStreamRequest(personId, recognitionModel, content, targetFace, detectionModel, userData, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "PersonDirectoryPersons.AddFaceFromStream", OperationFinalStateVia.OriginalUri, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> The most basic operation that applies to a resource. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> or <paramref name="persistedFaceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='DeleteFaceAsync(WaitUntil,string,RecognitionModel,string,CancellationToken)']/*" />
        public virtual async Task<Operation> DeleteFaceAsync(WaitUntil waitUntil, string personId, RecognitionModel recognitionModel, string persistedFaceId, CancellationToken cancellationToken = default)
        {
            if (personId == null)
            {
                throw new ArgumentNullException(nameof(personId));
            }
            if (personId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(personId));
            }
            if (persistedFaceId == null)
            {
                throw new ArgumentNullException(nameof(persistedFaceId));
            }
            if (persistedFaceId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(persistedFaceId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            return await DeleteFaceAsync(waitUntil, personId, recognitionModel.ToString(), persistedFaceId, context).ConfigureAwait(false);
        }

        /// <summary> The most basic operation that applies to a resource. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/> or <paramref name="persistedFaceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='DeleteFace(WaitUntil,string,RecognitionModel,string,CancellationToken)']/*" />
        public virtual Operation DeleteFace(WaitUntil waitUntil, string personId, RecognitionModel recognitionModel, string persistedFaceId, CancellationToken cancellationToken = default)
        {
            if (personId == null)
            {
                throw new ArgumentNullException(nameof(personId));
            }
            if (personId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(personId));
            }
            if (persistedFaceId == null)
            {
                throw new ArgumentNullException(nameof(persistedFaceId));
            }
            if (persistedFaceId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(persistedFaceId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            return DeleteFace(waitUntil, personId, recognitionModel.ToString(), persistedFaceId, context);
        }

        /// <summary>
        /// [Protocol Method] The most basic operation that applies to a resource.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="DeleteFaceAsync(WaitUntil,string,RecognitionModel,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/>, <paramref name="recognitionModel"/> or <paramref name="persistedFaceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/>, <paramref name="recognitionModel"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='DeleteFaceAsync(WaitUntil,string,string,string,RequestContext)']/*" />
        public virtual async Task<Operation> DeleteFaceAsync(WaitUntil waitUntil, string personId, string recognitionModel, string persistedFaceId, RequestContext context = null)
        {
            if (personId == null)
            {
                throw new ArgumentNullException(nameof(personId));
            }
            if (personId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(personId));
            }
            if (recognitionModel == null)
            {
                throw new ArgumentNullException(nameof(recognitionModel));
            }
            if (recognitionModel.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(recognitionModel));
            }
            if (persistedFaceId == null)
            {
                throw new ArgumentNullException(nameof(persistedFaceId));
            }
            if (persistedFaceId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(persistedFaceId));
            }

            using var scope = ClientDiagnostics.CreateScope("PersonDirectoryPersons.DeleteFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteFaceRequest(personId, recognitionModel, persistedFaceId, context);
                return await ProtocolOperationHelpers.ProcessMessageWithoutResponseValueAsync(_pipeline, message, ClientDiagnostics, "PersonDirectoryPersons.DeleteFace", OperationFinalStateVia.OperationLocation, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] The most basic operation that applies to a resource.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="DeleteFace(WaitUntil,string,RecognitionModel,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personId"/>, <paramref name="recognitionModel"/> or <paramref name="persistedFaceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personId"/>, <paramref name="recognitionModel"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/PersonDirectoryPersons.xml" path="doc/members/member[@name='DeleteFace(WaitUntil,string,string,string,RequestContext)']/*" />
        public virtual Operation DeleteFace(WaitUntil waitUntil, string personId, string recognitionModel, string persistedFaceId, RequestContext context = null)
        {
            if (personId == null)
            {
                throw new ArgumentNullException(nameof(personId));
            }
            if (personId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(personId));
            }
            if (recognitionModel == null)
            {
                throw new ArgumentNullException(nameof(recognitionModel));
            }
            if (recognitionModel.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(recognitionModel));
            }
            if (persistedFaceId == null)
            {
                throw new ArgumentNullException(nameof(persistedFaceId));
            }
            if (persistedFaceId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(persistedFaceId));
            }

            using var scope = ClientDiagnostics.CreateScope("PersonDirectoryPersons.DeleteFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteFaceRequest(personId, recognitionModel, persistedFaceId, context);
                return ProtocolOperationHelpers.ProcessMessageWithoutResponseValue(_pipeline, message, ClientDiagnostics, "PersonDirectoryPersons.DeleteFace", OperationFinalStateVia.OperationLocation, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateCreatePersonRequest(RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/persons", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeletePersonRequest(string personId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetPersonRequest(string personId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateUpdatePersonRequest(string personId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetPeopleRequest(string start, int? top, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/persons", false);
            if (start != null)
            {
                uri.AppendQuery("start", start, true);
            }
            if (top != null)
            {
                uri.AppendQuery("top", top.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetGroupReferencesRequest(string personId, string start, int? top, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/dynamicPersonGroupReferences", false);
            if (start != null)
            {
                uri.AppendQuery("start", start, true);
            }
            if (top != null)
            {
                uri.AppendQuery("top", top.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateAddFaceFromUrlRequest(string personId, string recognitionModel, RequestContent content, string targetFace, string detectionModel, string userData, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/recognitionModels/", false);
            uri.AppendPath(recognitionModel, true);
            uri.AppendPath("/persistedfaces", false);
            if (targetFace != null)
            {
                uri.AppendQuery("targetFace", targetFace, true);
            }
            if (detectionModel != null)
            {
                uri.AppendQuery("detectionModel", detectionModel, true);
            }
            if (userData != null)
            {
                uri.AppendQuery("userData", userData, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateAddFaceFromStreamRequest(string personId, string recognitionModel, RequestContent content, string targetFace, string detectionModel, string userData, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/recognitionModels/", false);
            uri.AppendPath(recognitionModel, true);
            uri.AppendPath("/persistedfaces", false);
            if (targetFace != null)
            {
                uri.AppendQuery("targetFace", targetFace, true);
            }
            if (detectionModel != null)
            {
                uri.AppendQuery("detectionModel", detectionModel, true);
            }
            if (userData != null)
            {
                uri.AppendQuery("userData", userData, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("content-type", "application/octet-stream");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteFaceRequest(string personId, string recognitionModel, string persistedFaceId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/recognitionModels/", false);
            uri.AppendPath(recognitionModel, true);
            uri.AppendPath("/persistedfaces/", false);
            uri.AppendPath(persistedFaceId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetFaceRequest(string personId, string recognitionModel, string persistedFaceId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/recognitionModels/", false);
            uri.AppendPath(recognitionModel, true);
            uri.AppendPath("/persistedfaces/", false);
            uri.AppendPath(persistedFaceId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateUpdateFaceRequest(string personId, string recognitionModel, string persistedFaceId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/recognitionModels/", false);
            uri.AppendPath(recognitionModel, true);
            uri.AppendPath("/persistedfaces/", false);
            uri.AppendPath(persistedFaceId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetFacesRequest(string personId, string recognitionModel, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/recognitionModels/", false);
            uri.AppendPath(recognitionModel, true);
            uri.AppendPath("/persistedfaces", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateIdentifyFromPersonDirectoryRequest(RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/identify", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateVerifyFromPersonDirectoryRequest(RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/verify", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        private static RequestContext DefaultRequestContext = new RequestContext();
        internal static RequestContext FromCancellationToken(CancellationToken cancellationToken = default)
        {
            if (!cancellationToken.CanBeCanceled)
            {
                return DefaultRequestContext;
            }

            return new RequestContext() { CancellationToken = cancellationToken };
        }

        private static ResponseClassifier _responseClassifier202;
        private static ResponseClassifier ResponseClassifier202 => _responseClassifier202 ??= new StatusCodeClassifier(stackalloc ushort[] { 202 });
        private static ResponseClassifier _responseClassifier200;
        private static ResponseClassifier ResponseClassifier200 => _responseClassifier200 ??= new StatusCodeClassifier(stackalloc ushort[] { 200 });
    }
}
