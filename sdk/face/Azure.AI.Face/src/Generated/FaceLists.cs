// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.AI.Face
{
    // Data plane generated sub-client.
    /// <summary> The FaceLists sub-client. </summary>
    public partial class FaceLists
    {
        private const string AuthorizationHeader = "Ocp-Apim-Subscription-Key";
        private readonly AzureKeyCredential _keyCredential;
        private static readonly string[] AuthorizationScopes = new string[] { "https://cognitiveservices.azure.com/.default" };
        private readonly TokenCredential _tokenCredential;
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;
        private readonly string _apiVersion;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of FaceLists for mocking. </summary>
        protected FaceLists()
        {
        }

        /// <summary> Initializes a new instance of FaceLists. </summary>
        /// <param name="clientDiagnostics"> The handler for diagnostic messaging in the client. </param>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="keyCredential"> The key credential to copy. </param>
        /// <param name="tokenCredential"> The token credential to copy. </param>
        /// <param name="endpoint">
        /// Supported Cognitive Services endpoints (protocol and hostname, for example:
        /// https://&lt;resource-name&gt;.cognitiveservices.azure.com).
        /// </param>
        /// <param name="apiVersion"> The API version to use for this operation. </param>
        internal FaceLists(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, AzureKeyCredential keyCredential, TokenCredential tokenCredential, Uri endpoint, string apiVersion)
        {
            ClientDiagnostics = clientDiagnostics;
            _pipeline = pipeline;
            _keyCredential = keyCredential;
            _tokenCredential = tokenCredential;
            _endpoint = endpoint;
            _apiVersion = apiVersion;
        }

        /// <summary> The most basic operation that applies to a resource. </summary>
        /// <param name="faceListId"> ID of the container. </param>
        /// <param name="resource"> The resource instance. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> or <paramref name="resource"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceLists.xml" path="doc/members/member[@name='CreateListAsync(string,FaceList,CancellationToken)']/*" />
        public virtual async Task<Response> CreateListAsync(string faceListId, FaceList resource, CancellationToken cancellationToken = default)
        {
            if (faceListId == null)
            {
                throw new ArgumentNullException(nameof(faceListId));
            }
            if (faceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(faceListId));
            }
            if (resource == null)
            {
                throw new ArgumentNullException(nameof(resource));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = resource.ToRequestContent();
            Response response = await CreateListAsync(faceListId, content, context).ConfigureAwait(false);
            return response;
        }

        /// <summary> The most basic operation that applies to a resource. </summary>
        /// <param name="faceListId"> ID of the container. </param>
        /// <param name="resource"> The resource instance. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> or <paramref name="resource"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceLists.xml" path="doc/members/member[@name='CreateList(string,FaceList,CancellationToken)']/*" />
        public virtual Response CreateList(string faceListId, FaceList resource, CancellationToken cancellationToken = default)
        {
            if (faceListId == null)
            {
                throw new ArgumentNullException(nameof(faceListId));
            }
            if (faceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(faceListId));
            }
            if (resource == null)
            {
                throw new ArgumentNullException(nameof(resource));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = resource.ToRequestContent();
            Response response = CreateList(faceListId, content, context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] The most basic operation that applies to a resource.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateListAsync(string,FaceList,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="faceListId"> ID of the container. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceLists.xml" path="doc/members/member[@name='CreateListAsync(string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> CreateListAsync(string faceListId, RequestContent content, RequestContext context = null)
        {
            if (faceListId == null)
            {
                throw new ArgumentNullException(nameof(faceListId));
            }
            if (faceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(faceListId));
            }
            if (content == null)
            {
                throw new ArgumentNullException(nameof(content));
            }

            using var scope = ClientDiagnostics.CreateScope("FaceLists.CreateList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateListRequest(faceListId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] The most basic operation that applies to a resource.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateList(string,FaceList,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="faceListId"> ID of the container. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceLists.xml" path="doc/members/member[@name='CreateList(string,RequestContent,RequestContext)']/*" />
        public virtual Response CreateList(string faceListId, RequestContent content, RequestContext context = null)
        {
            if (faceListId == null)
            {
                throw new ArgumentNullException(nameof(faceListId));
            }
            if (faceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(faceListId));
            }
            if (content == null)
            {
                throw new ArgumentNullException(nameof(content));
            }

            using var scope = ClientDiagnostics.CreateScope("FaceLists.CreateList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateListRequest(faceListId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] The most basic operation that applies to a resource.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="faceListId"> ID of the container. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceLists.xml" path="doc/members/member[@name='DeleteListAsync(string,RequestContext)']/*" />
        public virtual async Task<Response> DeleteListAsync(string faceListId, RequestContext context = null)
        {
            if (faceListId == null)
            {
                throw new ArgumentNullException(nameof(faceListId));
            }
            if (faceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(faceListId));
            }

            using var scope = ClientDiagnostics.CreateScope("FaceLists.DeleteList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteListRequest(faceListId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] The most basic operation that applies to a resource.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="faceListId"> ID of the container. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceLists.xml" path="doc/members/member[@name='DeleteList(string,RequestContext)']/*" />
        public virtual Response DeleteList(string faceListId, RequestContext context = null)
        {
            if (faceListId == null)
            {
                throw new ArgumentNullException(nameof(faceListId));
            }
            if (faceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(faceListId));
            }

            using var scope = ClientDiagnostics.CreateScope("FaceLists.DeleteList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteListRequest(faceListId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Resource read operation template. </summary>
        /// <param name="faceListId"> ID of the container. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceLists.xml" path="doc/members/member[@name='GetListAsync(string,bool?,CancellationToken)']/*" />
        public virtual async Task<Response<FaceList>> GetListAsync(string faceListId, bool? returnRecognitionModel = null, CancellationToken cancellationToken = default)
        {
            if (faceListId == null)
            {
                throw new ArgumentNullException(nameof(faceListId));
            }
            if (faceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(faceListId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetListAsync(faceListId, returnRecognitionModel, context).ConfigureAwait(false);
            return Response.FromValue(FaceList.FromResponse(response), response);
        }

        /// <summary> Resource read operation template. </summary>
        /// <param name="faceListId"> ID of the container. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceLists.xml" path="doc/members/member[@name='GetList(string,bool?,CancellationToken)']/*" />
        public virtual Response<FaceList> GetList(string faceListId, bool? returnRecognitionModel = null, CancellationToken cancellationToken = default)
        {
            if (faceListId == null)
            {
                throw new ArgumentNullException(nameof(faceListId));
            }
            if (faceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(faceListId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetList(faceListId, returnRecognitionModel, context);
            return Response.FromValue(FaceList.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Resource read operation template.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetListAsync(string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="faceListId"> ID of the container. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceLists.xml" path="doc/members/member[@name='GetListAsync(string,bool?,RequestContext)']/*" />
        public virtual async Task<Response> GetListAsync(string faceListId, bool? returnRecognitionModel, RequestContext context)
        {
            if (faceListId == null)
            {
                throw new ArgumentNullException(nameof(faceListId));
            }
            if (faceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(faceListId));
            }

            using var scope = ClientDiagnostics.CreateScope("FaceLists.GetList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetListRequest(faceListId, returnRecognitionModel, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Resource read operation template.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetList(string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="faceListId"> ID of the container. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceLists.xml" path="doc/members/member[@name='GetList(string,bool?,RequestContext)']/*" />
        public virtual Response GetList(string faceListId, bool? returnRecognitionModel, RequestContext context)
        {
            if (faceListId == null)
            {
                throw new ArgumentNullException(nameof(faceListId));
            }
            if (faceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(faceListId));
            }

            using var scope = ClientDiagnostics.CreateScope("FaceLists.GetList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetListRequest(faceListId, returnRecognitionModel, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] The most basic operation that applies to a resource.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="faceListId"> ID of the container. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceLists.xml" path="doc/members/member[@name='UpdateListAsync(string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> UpdateListAsync(string faceListId, RequestContent content, RequestContext context = null)
        {
            if (faceListId == null)
            {
                throw new ArgumentNullException(nameof(faceListId));
            }
            if (faceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(faceListId));
            }
            if (content == null)
            {
                throw new ArgumentNullException(nameof(content));
            }

            using var scope = ClientDiagnostics.CreateScope("FaceLists.UpdateList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateListRequest(faceListId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] The most basic operation that applies to a resource.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="faceListId"> ID of the container. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceLists.xml" path="doc/members/member[@name='UpdateList(string,RequestContent,RequestContext)']/*" />
        public virtual Response UpdateList(string faceListId, RequestContent content, RequestContext context = null)
        {
            if (faceListId == null)
            {
                throw new ArgumentNullException(nameof(faceListId));
            }
            if (faceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(faceListId));
            }
            if (content == null)
            {
                throw new ArgumentNullException(nameof(content));
            }

            using var scope = ClientDiagnostics.CreateScope("FaceLists.UpdateList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateListRequest(faceListId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Operation that applies to a collection of resources. </summary>
        /// <param name="faceListId"> ID of the container. </param>
        /// <param name="addFaceFromUrlContent"> Model for add face by url. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> or <paramref name="addFaceFromUrlContent"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceLists.xml" path="doc/members/member[@name='AddFaceFromUrlAsync(string,AddFaceFromUrlContent,string,DetectionModel?,string,CancellationToken)']/*" />
        public virtual async Task<Response<AddFaceResult>> AddFaceFromUrlAsync(string faceListId, AddFaceFromUrlContent addFaceFromUrlContent, string targetFace = null, DetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            if (faceListId == null)
            {
                throw new ArgumentNullException(nameof(faceListId));
            }
            if (faceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(faceListId));
            }
            if (addFaceFromUrlContent == null)
            {
                throw new ArgumentNullException(nameof(addFaceFromUrlContent));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = addFaceFromUrlContent.ToRequestContent();
            Response response = await AddFaceFromUrlAsync(faceListId, content, targetFace, detectionModel?.ToString(), userData, context).ConfigureAwait(false);
            return Response.FromValue(AddFaceResult.FromResponse(response), response);
        }

        /// <summary> Operation that applies to a collection of resources. </summary>
        /// <param name="faceListId"> ID of the container. </param>
        /// <param name="addFaceFromUrlContent"> Model for add face by url. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> or <paramref name="addFaceFromUrlContent"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceLists.xml" path="doc/members/member[@name='AddFaceFromUrl(string,AddFaceFromUrlContent,string,DetectionModel?,string,CancellationToken)']/*" />
        public virtual Response<AddFaceResult> AddFaceFromUrl(string faceListId, AddFaceFromUrlContent addFaceFromUrlContent, string targetFace = null, DetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            if (faceListId == null)
            {
                throw new ArgumentNullException(nameof(faceListId));
            }
            if (faceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(faceListId));
            }
            if (addFaceFromUrlContent == null)
            {
                throw new ArgumentNullException(nameof(addFaceFromUrlContent));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = addFaceFromUrlContent.ToRequestContent();
            Response response = AddFaceFromUrl(faceListId, content, targetFace, detectionModel?.ToString(), userData, context);
            return Response.FromValue(AddFaceResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Operation that applies to a collection of resources.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddFaceFromUrlAsync(string,AddFaceFromUrlContent,string,DetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="faceListId"> ID of the container. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceLists.xml" path="doc/members/member[@name='AddFaceFromUrlAsync(string,RequestContent,string,string,string,RequestContext)']/*" />
        public virtual async Task<Response> AddFaceFromUrlAsync(string faceListId, RequestContent content, string targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            if (faceListId == null)
            {
                throw new ArgumentNullException(nameof(faceListId));
            }
            if (faceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(faceListId));
            }
            if (content == null)
            {
                throw new ArgumentNullException(nameof(content));
            }

            using var scope = ClientDiagnostics.CreateScope("FaceLists.AddFaceFromUrl");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddFaceFromUrlRequest(faceListId, content, targetFace, detectionModel, userData, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Operation that applies to a collection of resources.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddFaceFromUrl(string,AddFaceFromUrlContent,string,DetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="faceListId"> ID of the container. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceLists.xml" path="doc/members/member[@name='AddFaceFromUrl(string,RequestContent,string,string,string,RequestContext)']/*" />
        public virtual Response AddFaceFromUrl(string faceListId, RequestContent content, string targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            if (faceListId == null)
            {
                throw new ArgumentNullException(nameof(faceListId));
            }
            if (faceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(faceListId));
            }
            if (content == null)
            {
                throw new ArgumentNullException(nameof(content));
            }

            using var scope = ClientDiagnostics.CreateScope("FaceLists.AddFaceFromUrl");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddFaceFromUrlRequest(faceListId, content, targetFace, detectionModel, userData, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Operation that applies to a collection of resources. </summary>
        /// <param name="faceListId"> ID of the container. </param>
        /// <param name="imageContent"> The image to be analyzed. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> or <paramref name="imageContent"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceLists.xml" path="doc/members/member[@name='AddFaceFromStreamAsync(string,BinaryData,string,DetectionModel?,string,CancellationToken)']/*" />
        public virtual async Task<Response<AddFaceResult>> AddFaceFromStreamAsync(string faceListId, BinaryData imageContent, string targetFace = null, DetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            if (faceListId == null)
            {
                throw new ArgumentNullException(nameof(faceListId));
            }
            if (faceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(faceListId));
            }
            if (imageContent == null)
            {
                throw new ArgumentNullException(nameof(imageContent));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = imageContent;
            Response response = await AddFaceFromStreamAsync(faceListId, content, targetFace, detectionModel?.ToString(), userData, context).ConfigureAwait(false);
            return Response.FromValue(AddFaceResult.FromResponse(response), response);
        }

        /// <summary> Operation that applies to a collection of resources. </summary>
        /// <param name="faceListId"> ID of the container. </param>
        /// <param name="imageContent"> The image to be analyzed. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> or <paramref name="imageContent"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceLists.xml" path="doc/members/member[@name='AddFaceFromStream(string,BinaryData,string,DetectionModel?,string,CancellationToken)']/*" />
        public virtual Response<AddFaceResult> AddFaceFromStream(string faceListId, BinaryData imageContent, string targetFace = null, DetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            if (faceListId == null)
            {
                throw new ArgumentNullException(nameof(faceListId));
            }
            if (faceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(faceListId));
            }
            if (imageContent == null)
            {
                throw new ArgumentNullException(nameof(imageContent));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = imageContent;
            Response response = AddFaceFromStream(faceListId, content, targetFace, detectionModel?.ToString(), userData, context);
            return Response.FromValue(AddFaceResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Operation that applies to a collection of resources.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddFaceFromStreamAsync(string,BinaryData,string,DetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="faceListId"> ID of the container. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceLists.xml" path="doc/members/member[@name='AddFaceFromStreamAsync(string,RequestContent,string,string,string,RequestContext)']/*" />
        public virtual async Task<Response> AddFaceFromStreamAsync(string faceListId, RequestContent content, string targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            if (faceListId == null)
            {
                throw new ArgumentNullException(nameof(faceListId));
            }
            if (faceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(faceListId));
            }
            if (content == null)
            {
                throw new ArgumentNullException(nameof(content));
            }

            using var scope = ClientDiagnostics.CreateScope("FaceLists.AddFaceFromStream");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddFaceFromStreamRequest(faceListId, content, targetFace, detectionModel, userData, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Operation that applies to a collection of resources.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddFaceFromStream(string,BinaryData,string,DetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="faceListId"> ID of the container. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1KB. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceLists.xml" path="doc/members/member[@name='AddFaceFromStream(string,RequestContent,string,string,string,RequestContext)']/*" />
        public virtual Response AddFaceFromStream(string faceListId, RequestContent content, string targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            if (faceListId == null)
            {
                throw new ArgumentNullException(nameof(faceListId));
            }
            if (faceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(faceListId));
            }
            if (content == null)
            {
                throw new ArgumentNullException(nameof(content));
            }

            using var scope = ClientDiagnostics.CreateScope("FaceLists.AddFaceFromStream");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddFaceFromStreamRequest(faceListId, content, targetFace, detectionModel, userData, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] The most basic operation that applies to a resource.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="faceListId"> ID of the container. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> or <paramref name="persistedFaceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceLists.xml" path="doc/members/member[@name='DeleteFaceAsync(string,string,RequestContext)']/*" />
        public virtual async Task<Response> DeleteFaceAsync(string faceListId, string persistedFaceId, RequestContext context = null)
        {
            if (faceListId == null)
            {
                throw new ArgumentNullException(nameof(faceListId));
            }
            if (faceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(faceListId));
            }
            if (persistedFaceId == null)
            {
                throw new ArgumentNullException(nameof(persistedFaceId));
            }
            if (persistedFaceId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(persistedFaceId));
            }

            using var scope = ClientDiagnostics.CreateScope("FaceLists.DeleteFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteFaceRequest(faceListId, persistedFaceId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] The most basic operation that applies to a resource.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="faceListId"> ID of the container. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> or <paramref name="persistedFaceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> or <paramref name="persistedFaceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceLists.xml" path="doc/members/member[@name='DeleteFace(string,string,RequestContext)']/*" />
        public virtual Response DeleteFace(string faceListId, string persistedFaceId, RequestContext context = null)
        {
            if (faceListId == null)
            {
                throw new ArgumentNullException(nameof(faceListId));
            }
            if (faceListId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(faceListId));
            }
            if (persistedFaceId == null)
            {
                throw new ArgumentNullException(nameof(persistedFaceId));
            }
            if (persistedFaceId.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", nameof(persistedFaceId));
            }

            using var scope = ClientDiagnostics.CreateScope("FaceLists.DeleteFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteFaceRequest(faceListId, persistedFaceId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Operation that lists resources in a paginated way. </summary>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/FaceLists.xml" path="doc/members/member[@name='GetListsAsync(bool?,CancellationToken)']/*" />
        public virtual async Task<Response<IReadOnlyList<FaceList>>> GetListsAsync(bool? returnRecognitionModel = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetListsAsync(returnRecognitionModel, context).ConfigureAwait(false);
            IReadOnlyList<FaceList> value = default;
            using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
            List<FaceList> array = new List<FaceList>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(FaceList.DeserializeFaceList(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary> Operation that lists resources in a paginated way. </summary>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/FaceLists.xml" path="doc/members/member[@name='GetLists(bool?,CancellationToken)']/*" />
        public virtual Response<IReadOnlyList<FaceList>> GetLists(bool? returnRecognitionModel = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetLists(returnRecognitionModel, context);
            IReadOnlyList<FaceList> value = default;
            using var document = JsonDocument.Parse(response.ContentStream);
            List<FaceList> array = new List<FaceList>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(FaceList.DeserializeFaceList(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// [Protocol Method] Operation that lists resources in a paginated way.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetListsAsync(bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceLists.xml" path="doc/members/member[@name='GetListsAsync(bool?,RequestContext)']/*" />
        public virtual async Task<Response> GetListsAsync(bool? returnRecognitionModel, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("FaceLists.GetLists");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetListsRequest(returnRecognitionModel, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Operation that lists resources in a paginated way.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLists(bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceLists.xml" path="doc/members/member[@name='GetLists(bool?,RequestContext)']/*" />
        public virtual Response GetLists(bool? returnRecognitionModel, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("FaceLists.GetLists");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetListsRequest(returnRecognitionModel, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Given query face's faceId, to search the similar-looking faces from a faceId array, a face list or a large face list. </summary>
        /// <param name="faceId"> faceId of the face, comes from Face - Detect. </param>
        /// <param name="faceListId"> An existing user-specified unique candidate face list, created in FaceList - Create. Face list contains a set of persistedFaceIds which are persisted and will never expire. </param>
        /// <param name="maxNumOfCandidatesReturned"> The number of top similar faces returned. The valid range is [1, 1000].It defaults to 20. </param>
        /// <param name="mode"> Similar face searching mode. It can be 'matchPerson' or 'matchFace'. It defaults to 'matchPerson'. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceId"/> or <paramref name="faceListId"/> is null. </exception>
        /// <include file="Docs/FaceLists.xml" path="doc/members/member[@name='FindSimilarFromFaceListAsync(string,string,int?,FindSimilarMatchMode?,CancellationToken)']/*" />
        public virtual async Task<Response<IReadOnlyList<FindSimilarResult>>> FindSimilarFromFaceListAsync(string faceId, string faceListId, int? maxNumOfCandidatesReturned = null, FindSimilarMatchMode? mode = null, CancellationToken cancellationToken = default)
        {
            if (faceId == null)
            {
                throw new ArgumentNullException(nameof(faceId));
            }
            if (faceListId == null)
            {
                throw new ArgumentNullException(nameof(faceListId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            FindSimilarFromFaceListRequest findSimilarFromFaceListRequest = new FindSimilarFromFaceListRequest(faceId, faceListId)
            {
                MaxNumOfCandidatesReturned = maxNumOfCandidatesReturned,
                Mode = mode
            };
            Response response = await FindSimilarFromFaceListAsync(findSimilarFromFaceListRequest.ToRequestContent(), context).ConfigureAwait(false);
            IReadOnlyList<FindSimilarResult> value = default;
            using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
            List<FindSimilarResult> array = new List<FindSimilarResult>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(FindSimilarResult.DeserializeFindSimilarResult(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary> Given query face's faceId, to search the similar-looking faces from a faceId array, a face list or a large face list. </summary>
        /// <param name="faceId"> faceId of the face, comes from Face - Detect. </param>
        /// <param name="faceListId"> An existing user-specified unique candidate face list, created in FaceList - Create. Face list contains a set of persistedFaceIds which are persisted and will never expire. </param>
        /// <param name="maxNumOfCandidatesReturned"> The number of top similar faces returned. The valid range is [1, 1000].It defaults to 20. </param>
        /// <param name="mode"> Similar face searching mode. It can be 'matchPerson' or 'matchFace'. It defaults to 'matchPerson'. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceId"/> or <paramref name="faceListId"/> is null. </exception>
        /// <include file="Docs/FaceLists.xml" path="doc/members/member[@name='FindSimilarFromFaceList(string,string,int?,FindSimilarMatchMode?,CancellationToken)']/*" />
        public virtual Response<IReadOnlyList<FindSimilarResult>> FindSimilarFromFaceList(string faceId, string faceListId, int? maxNumOfCandidatesReturned = null, FindSimilarMatchMode? mode = null, CancellationToken cancellationToken = default)
        {
            if (faceId == null)
            {
                throw new ArgumentNullException(nameof(faceId));
            }
            if (faceListId == null)
            {
                throw new ArgumentNullException(nameof(faceListId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            FindSimilarFromFaceListRequest findSimilarFromFaceListRequest = new FindSimilarFromFaceListRequest(faceId, faceListId)
            {
                MaxNumOfCandidatesReturned = maxNumOfCandidatesReturned,
                Mode = mode
            };
            Response response = FindSimilarFromFaceList(findSimilarFromFaceListRequest.ToRequestContent(), context);
            IReadOnlyList<FindSimilarResult> value = default;
            using var document = JsonDocument.Parse(response.ContentStream);
            List<FindSimilarResult> array = new List<FindSimilarResult>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(FindSimilarResult.DeserializeFindSimilarResult(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// [Protocol Method] Given query face's faceId, to search the similar-looking faces from a faceId array, a face list or a large face list.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="FindSimilarFromFaceListAsync(string,string,int?,FindSimilarMatchMode?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceLists.xml" path="doc/members/member[@name='FindSimilarFromFaceListAsync(RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> FindSimilarFromFaceListAsync(RequestContent content, RequestContext context = null)
        {
            if (content == null)
            {
                throw new ArgumentNullException(nameof(content));
            }

            using var scope = ClientDiagnostics.CreateScope("FaceLists.FindSimilarFromFaceList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateFindSimilarFromFaceListRequest(content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Given query face's faceId, to search the similar-looking faces from a faceId array, a face list or a large face list.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="FindSimilarFromFaceList(string,string,int?,FindSimilarMatchMode?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceLists.xml" path="doc/members/member[@name='FindSimilarFromFaceList(RequestContent,RequestContext)']/*" />
        public virtual Response FindSimilarFromFaceList(RequestContent content, RequestContext context = null)
        {
            if (content == null)
            {
                throw new ArgumentNullException(nameof(content));
            }

            using var scope = ClientDiagnostics.CreateScope("FaceLists.FindSimilarFromFaceList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateFindSimilarFromFaceListRequest(content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateCreateListRequest(string faceListId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/facelists/", false);
            uri.AppendPath(faceListId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteListRequest(string faceListId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/facelists/", false);
            uri.AppendPath(faceListId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetListRequest(string faceListId, bool? returnRecognitionModel, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/facelists/", false);
            uri.AppendPath(faceListId, true);
            if (returnRecognitionModel != null)
            {
                uri.AppendQuery("returnRecognitionModel", returnRecognitionModel.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateUpdateListRequest(string faceListId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/facelists/", false);
            uri.AppendPath(faceListId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateAddFaceFromUrlRequest(string faceListId, RequestContent content, string targetFace, string detectionModel, string userData, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/facelists/", false);
            uri.AppendPath(faceListId, true);
            uri.AppendPath("/persistedfaces", false);
            if (targetFace != null)
            {
                uri.AppendQuery("targetFace", targetFace, true);
            }
            if (detectionModel != null)
            {
                uri.AppendQuery("detectionModel", detectionModel, true);
            }
            if (userData != null)
            {
                uri.AppendQuery("userData", userData, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateAddFaceFromStreamRequest(string faceListId, RequestContent content, string targetFace, string detectionModel, string userData, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/facelists/", false);
            uri.AppendPath(faceListId, true);
            uri.AppendPath("/persistedfaces", false);
            if (targetFace != null)
            {
                uri.AppendQuery("targetFace", targetFace, true);
            }
            if (detectionModel != null)
            {
                uri.AppendQuery("detectionModel", detectionModel, true);
            }
            if (userData != null)
            {
                uri.AppendQuery("userData", userData, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("content-type", "application/octet-stream");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteFaceRequest(string faceListId, string persistedFaceId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/facelists/", false);
            uri.AppendPath(faceListId, true);
            uri.AppendPath("/persistedfaces/", false);
            uri.AppendPath(persistedFaceId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetListsRequest(bool? returnRecognitionModel, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/facelists", false);
            if (returnRecognitionModel != null)
            {
                uri.AppendQuery("returnRecognitionModel", returnRecognitionModel.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateFindSimilarFromFaceListRequest(RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/face/", false);
            uri.AppendPath(_apiVersion, true);
            uri.AppendPath("/findsimilars", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        private static RequestContext DefaultRequestContext = new RequestContext();
        internal static RequestContext FromCancellationToken(CancellationToken cancellationToken = default)
        {
            if (!cancellationToken.CanBeCanceled)
            {
                return DefaultRequestContext;
            }

            return new RequestContext() { CancellationToken = cancellationToken };
        }

        private static ResponseClassifier _responseClassifier200;
        private static ResponseClassifier ResponseClassifier200 => _responseClassifier200 ??= new StatusCodeClassifier(stackalloc ushort[] { 200 });
    }
}
