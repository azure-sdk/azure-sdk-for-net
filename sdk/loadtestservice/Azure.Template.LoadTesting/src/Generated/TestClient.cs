// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.Template.LoadTesting
{
    // Data plane generated client. The Test service client.
    /// <summary> The Test service client. </summary>
    public partial class TestClient
    {
        private static readonly string[] AuthorizationScopes = new string[] { "https://loadtest.azure-dev.com/.default" };
        private readonly TokenCredential _tokenCredential;
        private readonly HttpPipeline _pipeline;
        private readonly string _endpoint;
        private readonly string _apiVersion;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of TestClient for mocking. </summary>
        protected TestClient()
        {
        }

        /// <summary> Initializes a new instance of TestClient. </summary>
        /// <param name="endpoint"> URL to perform data plane API operations on the resource. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="endpoint"/> or <paramref name="credential"/> is null. </exception>
        public TestClient(string endpoint, TokenCredential credential) : this(endpoint, credential, new LoadTestingClientOptions())
        {
        }

        /// <summary> Initializes a new instance of TestClient. </summary>
        /// <param name="endpoint"> URL to perform data plane API operations on the resource. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="endpoint"/> or <paramref name="credential"/> is null. </exception>
        public TestClient(string endpoint, TokenCredential credential, LoadTestingClientOptions options)
        {
            Argument.AssertNotNull(endpoint, nameof(endpoint));
            Argument.AssertNotNull(credential, nameof(credential));
            options ??= new LoadTestingClientOptions();

            ClientDiagnostics = new ClientDiagnostics(options, true);
            _tokenCredential = credential;
            _pipeline = HttpPipelineBuilder.Build(options, Array.Empty<HttpPipelinePolicy>(), new HttpPipelinePolicy[] { new BearerTokenAuthenticationPolicy(_tokenCredential, AuthorizationScopes) }, new ResponseClassifier());
            _endpoint = endpoint;
            _apiVersion = options.Version;
        }

        /// <summary> Create a new test or update an existing test. </summary>
        /// <param name="testId"> Unique name for the load test, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call CreateOrUpdateAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// var data = new {};
        /// 
        /// Response response = await client.CreateOrUpdateAsync("<testId>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.ToString());
        /// ]]></code>
        /// This sample shows how to call CreateOrUpdateAsync with all parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// var data = new {
        ///     passFailCriteria = new {
        ///         passFailMetrics = new {
        ///             key = new {
        ///                 clientmetric = "response_time_ms",
        ///                 aggregate = "count",
        ///                 condition = "<condition>",
        ///                 requestName = "<requestName>",
        ///                 value = 123.45d,
        ///                 action = "stop",
        ///             },
        ///         },
        ///     },
        ///     secrets = new {
        ///         key = new {
        ///             value = "<value>",
        ///             type = "AKV_SECRET_URI",
        ///         },
        ///     },
        ///     certificate = new {
        ///         value = "<value>",
        ///         type = "AKV_CERT_URI",
        ///         name = "<name>",
        ///     },
        ///     environmentVariables = new {
        ///         key = "<String>",
        ///     },
        ///     loadTestConfig = new {
        ///         engineInstances = 1234,
        ///         splitAllCSVs = true,
        ///         quickStartTest = true,
        ///         optionalLoadTestConfig = new {
        ///             endpointUrl = "<endpointUrl>",
        ///             vusers = 1234,
        ///             rampUpTime = 1234,
        ///             duration = 1234,
        ///         },
        ///     },
        ///     description = "<description>",
        ///     displayName = "<displayName>",
        ///     subnetId = "<subnetId>",
        ///     keyvaultReferenceIdentityType = "<keyvaultReferenceIdentityType>",
        ///     keyvaultReferenceIdentityId = "<keyvaultReferenceIdentityId>",
        /// };
        /// 
        /// Response response = await client.CreateOrUpdateAsync("<testId>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("clientmetric").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("aggregate").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("condition").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("requestName").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("action").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("actualValue").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("result").ToString());
        /// Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("certificate").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("certificate").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("certificate").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("environmentVariables").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("engineInstances").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("splitAllCSVs").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("quickStartTest").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("endpointUrl").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("vusers").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("rampUpTime").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("duration").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("testId").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("subnetId").ToString());
        /// Console.WriteLine(result.GetProperty("keyvaultReferenceIdentityType").ToString());
        /// Console.WriteLine(result.GetProperty("keyvaultReferenceIdentityId").ToString());
        /// Console.WriteLine(result.GetProperty("resourceId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>TestModel20221101</c>:
        /// <code>{
        ///   passFailCriteria: {
        ///     passFailMetrics: Dictionary&lt;string, PassFailMetric20221101&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
        ///   }, # Optional. Pass fail criteria for a test.
        ///   secrets: Dictionary&lt;string, SecretMetadata20221101&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
        ///   certificate: {
        ///     value: string, # Optional. The value of the certificate for respective type
        ///     type: &quot;AKV_CERT_URI&quot;, # Optional. Type of certificate
        ///     name: string, # Optional. Name of the certificate.
        ///   }, # Optional.
        ///   environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
        ///   loadTestConfig: {
        ///     engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
        ///     splitAllCSVs: boolean, # Optional. Whether all the input CSV files should be split evenly across all engines.
        ///     quickStartTest: boolean, # Optional. If true, optionalLoadTestConfig is required and JMX script for the load test is not required to upload.
        ///     optionalLoadTestConfig: {
        ///       endpointUrl: string, # Optional. Endpoint url
        ///       vusers: number, # Optional. No of virtual users 
        ///       rampUpTime: number, # Optional. ramp up time
        ///       duration: number, # Optional. duration
        ///     }, # Optional. Quick start load test config
        ///   }, # Optional. The load test configuration.
        ///   inputArtifacts: {
        ///     configUrl: {
        ///       url: string, # Optional. File URL.
        ///       fileId: string, # Optional. File unique identifier.
        ///       filename: string, # Optional. Name of the file.
        ///       fileType: &quot;JMX_FILE&quot; | &quot;USER_PROPERTIES&quot; | &quot;ADDITIONAL_ARTIFACTS&quot;, # Optional. File type
        ///       expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///       validationStatus: &quot;NOT_VALIDATED&quot; | &quot;VALIDATION_SUCCESS&quot; | &quot;VALIDATION_FAILURE&quot; | &quot;VALIDATION_INITIATED&quot;, # Optional. Validation status of the file
        ///     }, # Optional. FileUrl Model.
        ///     testScriptUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///     userPropUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///     inputArtifactsZipFileurl: FileUrl20221101, # Optional. FileUrl Model.
        ///     additionalUrls: [FileUrl20221101], # Optional. Additional supported files for the test run
        ///   }, # Optional. The input artifacts for the test.
        ///   testId: string, # Optional. Unique test name as identifier.
        ///   description: string, # Optional. The test description.
        ///   displayName: string, # Optional. Display name of a test.
        ///   subnetId: string, # Optional. Subnet ID on which the load test instances should run.
        ///   keyvaultReferenceIdentityType: string, # Optional. Type of the managed identity referencing the Key vault.
        ///   keyvaultReferenceIdentityId: string, # Optional. Resource Id of the managed identity referencing the Key vault.
        ///   resourceId: string, # Optional. Fully qualified resource Id e.g /subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}.
        ///   createdDateTime: string (ISO 8601 Format), # Optional. The created DateTime(ISO 8601 literal format) of the test model.
        ///   createdBy: string, # Optional. The user that created the test model.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified DateTime(ISO 8601 literal format) of the test model.
        ///   lastModifiedBy: string, # Optional. The user that last modified the test model.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TestModel20221101</c>:
        /// <code>{
        ///   passFailCriteria: {
        ///     passFailMetrics: Dictionary&lt;string, PassFailMetric20221101&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
        ///   }, # Optional. Pass fail criteria for a test.
        ///   secrets: Dictionary&lt;string, SecretMetadata20221101&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
        ///   certificate: {
        ///     value: string, # Optional. The value of the certificate for respective type
        ///     type: &quot;AKV_CERT_URI&quot;, # Optional. Type of certificate
        ///     name: string, # Optional. Name of the certificate.
        ///   }, # Optional.
        ///   environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
        ///   loadTestConfig: {
        ///     engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
        ///     splitAllCSVs: boolean, # Optional. Whether all the input CSV files should be split evenly across all engines.
        ///     quickStartTest: boolean, # Optional. If true, optionalLoadTestConfig is required and JMX script for the load test is not required to upload.
        ///     optionalLoadTestConfig: {
        ///       endpointUrl: string, # Optional. Endpoint url
        ///       vusers: number, # Optional. No of virtual users 
        ///       rampUpTime: number, # Optional. ramp up time
        ///       duration: number, # Optional. duration
        ///     }, # Optional. Quick start load test config
        ///   }, # Optional. The load test configuration.
        ///   inputArtifacts: {
        ///     configUrl: {
        ///       url: string, # Optional. File URL.
        ///       fileId: string, # Optional. File unique identifier.
        ///       filename: string, # Optional. Name of the file.
        ///       fileType: &quot;JMX_FILE&quot; | &quot;USER_PROPERTIES&quot; | &quot;ADDITIONAL_ARTIFACTS&quot;, # Optional. File type
        ///       expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///       validationStatus: &quot;NOT_VALIDATED&quot; | &quot;VALIDATION_SUCCESS&quot; | &quot;VALIDATION_FAILURE&quot; | &quot;VALIDATION_INITIATED&quot;, # Optional. Validation status of the file
        ///     }, # Optional. FileUrl Model.
        ///     testScriptUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///     userPropUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///     inputArtifactsZipFileurl: FileUrl20221101, # Optional. FileUrl Model.
        ///     additionalUrls: [FileUrl20221101], # Optional. Additional supported files for the test run
        ///   }, # Optional. The input artifacts for the test.
        ///   testId: string, # Optional. Unique test name as identifier.
        ///   description: string, # Optional. The test description.
        ///   displayName: string, # Optional. Display name of a test.
        ///   subnetId: string, # Optional. Subnet ID on which the load test instances should run.
        ///   keyvaultReferenceIdentityType: string, # Optional. Type of the managed identity referencing the Key vault.
        ///   keyvaultReferenceIdentityId: string, # Optional. Resource Id of the managed identity referencing the Key vault.
        ///   resourceId: string, # Optional. Fully qualified resource Id e.g /subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}.
        ///   createdDateTime: string (ISO 8601 Format), # Optional. The created DateTime(ISO 8601 literal format) of the test model.
        ///   createdBy: string, # Optional. The user that created the test model.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified DateTime(ISO 8601 literal format) of the test model.
        ///   lastModifiedBy: string, # Optional. The user that last modified the test model.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> CreateOrUpdateAsync(string testId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testId, nameof(testId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("TestClient.CreateOrUpdate");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateOrUpdateRequest(testId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create a new test or update an existing test. </summary>
        /// <param name="testId"> Unique name for the load test, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call CreateOrUpdate with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// var data = new {};
        /// 
        /// Response response = client.CreateOrUpdate("<testId>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.ToString());
        /// ]]></code>
        /// This sample shows how to call CreateOrUpdate with all parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// var data = new {
        ///     passFailCriteria = new {
        ///         passFailMetrics = new {
        ///             key = new {
        ///                 clientmetric = "response_time_ms",
        ///                 aggregate = "count",
        ///                 condition = "<condition>",
        ///                 requestName = "<requestName>",
        ///                 value = 123.45d,
        ///                 action = "stop",
        ///             },
        ///         },
        ///     },
        ///     secrets = new {
        ///         key = new {
        ///             value = "<value>",
        ///             type = "AKV_SECRET_URI",
        ///         },
        ///     },
        ///     certificate = new {
        ///         value = "<value>",
        ///         type = "AKV_CERT_URI",
        ///         name = "<name>",
        ///     },
        ///     environmentVariables = new {
        ///         key = "<String>",
        ///     },
        ///     loadTestConfig = new {
        ///         engineInstances = 1234,
        ///         splitAllCSVs = true,
        ///         quickStartTest = true,
        ///         optionalLoadTestConfig = new {
        ///             endpointUrl = "<endpointUrl>",
        ///             vusers = 1234,
        ///             rampUpTime = 1234,
        ///             duration = 1234,
        ///         },
        ///     },
        ///     description = "<description>",
        ///     displayName = "<displayName>",
        ///     subnetId = "<subnetId>",
        ///     keyvaultReferenceIdentityType = "<keyvaultReferenceIdentityType>",
        ///     keyvaultReferenceIdentityId = "<keyvaultReferenceIdentityId>",
        /// };
        /// 
        /// Response response = client.CreateOrUpdate("<testId>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("clientmetric").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("aggregate").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("condition").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("requestName").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("action").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("actualValue").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("result").ToString());
        /// Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("certificate").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("certificate").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("certificate").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("environmentVariables").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("engineInstances").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("splitAllCSVs").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("quickStartTest").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("endpointUrl").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("vusers").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("rampUpTime").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("duration").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("testId").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("subnetId").ToString());
        /// Console.WriteLine(result.GetProperty("keyvaultReferenceIdentityType").ToString());
        /// Console.WriteLine(result.GetProperty("keyvaultReferenceIdentityId").ToString());
        /// Console.WriteLine(result.GetProperty("resourceId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>TestModel20221101</c>:
        /// <code>{
        ///   passFailCriteria: {
        ///     passFailMetrics: Dictionary&lt;string, PassFailMetric20221101&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
        ///   }, # Optional. Pass fail criteria for a test.
        ///   secrets: Dictionary&lt;string, SecretMetadata20221101&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
        ///   certificate: {
        ///     value: string, # Optional. The value of the certificate for respective type
        ///     type: &quot;AKV_CERT_URI&quot;, # Optional. Type of certificate
        ///     name: string, # Optional. Name of the certificate.
        ///   }, # Optional.
        ///   environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
        ///   loadTestConfig: {
        ///     engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
        ///     splitAllCSVs: boolean, # Optional. Whether all the input CSV files should be split evenly across all engines.
        ///     quickStartTest: boolean, # Optional. If true, optionalLoadTestConfig is required and JMX script for the load test is not required to upload.
        ///     optionalLoadTestConfig: {
        ///       endpointUrl: string, # Optional. Endpoint url
        ///       vusers: number, # Optional. No of virtual users 
        ///       rampUpTime: number, # Optional. ramp up time
        ///       duration: number, # Optional. duration
        ///     }, # Optional. Quick start load test config
        ///   }, # Optional. The load test configuration.
        ///   inputArtifacts: {
        ///     configUrl: {
        ///       url: string, # Optional. File URL.
        ///       fileId: string, # Optional. File unique identifier.
        ///       filename: string, # Optional. Name of the file.
        ///       fileType: &quot;JMX_FILE&quot; | &quot;USER_PROPERTIES&quot; | &quot;ADDITIONAL_ARTIFACTS&quot;, # Optional. File type
        ///       expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///       validationStatus: &quot;NOT_VALIDATED&quot; | &quot;VALIDATION_SUCCESS&quot; | &quot;VALIDATION_FAILURE&quot; | &quot;VALIDATION_INITIATED&quot;, # Optional. Validation status of the file
        ///     }, # Optional. FileUrl Model.
        ///     testScriptUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///     userPropUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///     inputArtifactsZipFileurl: FileUrl20221101, # Optional. FileUrl Model.
        ///     additionalUrls: [FileUrl20221101], # Optional. Additional supported files for the test run
        ///   }, # Optional. The input artifacts for the test.
        ///   testId: string, # Optional. Unique test name as identifier.
        ///   description: string, # Optional. The test description.
        ///   displayName: string, # Optional. Display name of a test.
        ///   subnetId: string, # Optional. Subnet ID on which the load test instances should run.
        ///   keyvaultReferenceIdentityType: string, # Optional. Type of the managed identity referencing the Key vault.
        ///   keyvaultReferenceIdentityId: string, # Optional. Resource Id of the managed identity referencing the Key vault.
        ///   resourceId: string, # Optional. Fully qualified resource Id e.g /subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}.
        ///   createdDateTime: string (ISO 8601 Format), # Optional. The created DateTime(ISO 8601 literal format) of the test model.
        ///   createdBy: string, # Optional. The user that created the test model.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified DateTime(ISO 8601 literal format) of the test model.
        ///   lastModifiedBy: string, # Optional. The user that last modified the test model.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TestModel20221101</c>:
        /// <code>{
        ///   passFailCriteria: {
        ///     passFailMetrics: Dictionary&lt;string, PassFailMetric20221101&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
        ///   }, # Optional. Pass fail criteria for a test.
        ///   secrets: Dictionary&lt;string, SecretMetadata20221101&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
        ///   certificate: {
        ///     value: string, # Optional. The value of the certificate for respective type
        ///     type: &quot;AKV_CERT_URI&quot;, # Optional. Type of certificate
        ///     name: string, # Optional. Name of the certificate.
        ///   }, # Optional.
        ///   environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
        ///   loadTestConfig: {
        ///     engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
        ///     splitAllCSVs: boolean, # Optional. Whether all the input CSV files should be split evenly across all engines.
        ///     quickStartTest: boolean, # Optional. If true, optionalLoadTestConfig is required and JMX script for the load test is not required to upload.
        ///     optionalLoadTestConfig: {
        ///       endpointUrl: string, # Optional. Endpoint url
        ///       vusers: number, # Optional. No of virtual users 
        ///       rampUpTime: number, # Optional. ramp up time
        ///       duration: number, # Optional. duration
        ///     }, # Optional. Quick start load test config
        ///   }, # Optional. The load test configuration.
        ///   inputArtifacts: {
        ///     configUrl: {
        ///       url: string, # Optional. File URL.
        ///       fileId: string, # Optional. File unique identifier.
        ///       filename: string, # Optional. Name of the file.
        ///       fileType: &quot;JMX_FILE&quot; | &quot;USER_PROPERTIES&quot; | &quot;ADDITIONAL_ARTIFACTS&quot;, # Optional. File type
        ///       expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///       validationStatus: &quot;NOT_VALIDATED&quot; | &quot;VALIDATION_SUCCESS&quot; | &quot;VALIDATION_FAILURE&quot; | &quot;VALIDATION_INITIATED&quot;, # Optional. Validation status of the file
        ///     }, # Optional. FileUrl Model.
        ///     testScriptUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///     userPropUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///     inputArtifactsZipFileurl: FileUrl20221101, # Optional. FileUrl Model.
        ///     additionalUrls: [FileUrl20221101], # Optional. Additional supported files for the test run
        ///   }, # Optional. The input artifacts for the test.
        ///   testId: string, # Optional. Unique test name as identifier.
        ///   description: string, # Optional. The test description.
        ///   displayName: string, # Optional. Display name of a test.
        ///   subnetId: string, # Optional. Subnet ID on which the load test instances should run.
        ///   keyvaultReferenceIdentityType: string, # Optional. Type of the managed identity referencing the Key vault.
        ///   keyvaultReferenceIdentityId: string, # Optional. Resource Id of the managed identity referencing the Key vault.
        ///   resourceId: string, # Optional. Fully qualified resource Id e.g /subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}.
        ///   createdDateTime: string (ISO 8601 Format), # Optional. The created DateTime(ISO 8601 literal format) of the test model.
        ///   createdBy: string, # Optional. The user that created the test model.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified DateTime(ISO 8601 literal format) of the test model.
        ///   lastModifiedBy: string, # Optional. The user that last modified the test model.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response CreateOrUpdate(string testId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testId, nameof(testId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("TestClient.CreateOrUpdate");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateOrUpdateRequest(testId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete a test by its name. </summary>
        /// <param name="testId"> Unique name for the load test, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call DeleteAsync with required parameters.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = await client.DeleteAsync("<testId>");
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        public virtual async Task<Response> DeleteAsync(string testId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testId, nameof(testId));

            using var scope = ClientDiagnostics.CreateScope("TestClient.Delete");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteRequest(testId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete a test by its name. </summary>
        /// <param name="testId"> Unique name for the load test, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call Delete with required parameters.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = client.Delete("<testId>");
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        public virtual Response Delete(string testId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testId, nameof(testId));

            using var scope = ClientDiagnostics.CreateScope("TestClient.Delete");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteRequest(testId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get load test details by test name. </summary>
        /// <param name="testId"> Unique name for the load test, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTestAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = await client.GetTestAsync("<testId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("clientmetric").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("aggregate").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("condition").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("requestName").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("action").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("actualValue").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("result").ToString());
        /// Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("certificate").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("certificate").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("certificate").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("environmentVariables").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("engineInstances").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("splitAllCSVs").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("quickStartTest").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("endpointUrl").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("vusers").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("rampUpTime").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("duration").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("testId").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("subnetId").ToString());
        /// Console.WriteLine(result.GetProperty("keyvaultReferenceIdentityType").ToString());
        /// Console.WriteLine(result.GetProperty("keyvaultReferenceIdentityId").ToString());
        /// Console.WriteLine(result.GetProperty("resourceId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TestModel20221101</c>:
        /// <code>{
        ///   passFailCriteria: {
        ///     passFailMetrics: Dictionary&lt;string, PassFailMetric20221101&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
        ///   }, # Optional. Pass fail criteria for a test.
        ///   secrets: Dictionary&lt;string, SecretMetadata20221101&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
        ///   certificate: {
        ///     value: string, # Optional. The value of the certificate for respective type
        ///     type: &quot;AKV_CERT_URI&quot;, # Optional. Type of certificate
        ///     name: string, # Optional. Name of the certificate.
        ///   }, # Optional.
        ///   environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
        ///   loadTestConfig: {
        ///     engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
        ///     splitAllCSVs: boolean, # Optional. Whether all the input CSV files should be split evenly across all engines.
        ///     quickStartTest: boolean, # Optional. If true, optionalLoadTestConfig is required and JMX script for the load test is not required to upload.
        ///     optionalLoadTestConfig: {
        ///       endpointUrl: string, # Optional. Endpoint url
        ///       vusers: number, # Optional. No of virtual users 
        ///       rampUpTime: number, # Optional. ramp up time
        ///       duration: number, # Optional. duration
        ///     }, # Optional. Quick start load test config
        ///   }, # Optional. The load test configuration.
        ///   inputArtifacts: {
        ///     configUrl: {
        ///       url: string, # Optional. File URL.
        ///       fileId: string, # Optional. File unique identifier.
        ///       filename: string, # Optional. Name of the file.
        ///       fileType: &quot;JMX_FILE&quot; | &quot;USER_PROPERTIES&quot; | &quot;ADDITIONAL_ARTIFACTS&quot;, # Optional. File type
        ///       expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///       validationStatus: &quot;NOT_VALIDATED&quot; | &quot;VALIDATION_SUCCESS&quot; | &quot;VALIDATION_FAILURE&quot; | &quot;VALIDATION_INITIATED&quot;, # Optional. Validation status of the file
        ///     }, # Optional. FileUrl Model.
        ///     testScriptUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///     userPropUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///     inputArtifactsZipFileurl: FileUrl20221101, # Optional. FileUrl Model.
        ///     additionalUrls: [FileUrl20221101], # Optional. Additional supported files for the test run
        ///   }, # Optional. The input artifacts for the test.
        ///   testId: string, # Optional. Unique test name as identifier.
        ///   description: string, # Optional. The test description.
        ///   displayName: string, # Optional. Display name of a test.
        ///   subnetId: string, # Optional. Subnet ID on which the load test instances should run.
        ///   keyvaultReferenceIdentityType: string, # Optional. Type of the managed identity referencing the Key vault.
        ///   keyvaultReferenceIdentityId: string, # Optional. Resource Id of the managed identity referencing the Key vault.
        ///   resourceId: string, # Optional. Fully qualified resource Id e.g /subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}.
        ///   createdDateTime: string (ISO 8601 Format), # Optional. The created DateTime(ISO 8601 literal format) of the test model.
        ///   createdBy: string, # Optional. The user that created the test model.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified DateTime(ISO 8601 literal format) of the test model.
        ///   lastModifiedBy: string, # Optional. The user that last modified the test model.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetTestAsync(string testId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testId, nameof(testId));

            using var scope = ClientDiagnostics.CreateScope("TestClient.GetTest");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTestRequest(testId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get load test details by test name. </summary>
        /// <param name="testId"> Unique name for the load test, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTest with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = client.GetTest("<testId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("clientmetric").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("aggregate").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("condition").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("requestName").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("action").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("actualValue").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("result").ToString());
        /// Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("certificate").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("certificate").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("certificate").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("environmentVariables").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("engineInstances").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("splitAllCSVs").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("quickStartTest").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("endpointUrl").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("vusers").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("rampUpTime").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("duration").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("testId").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("subnetId").ToString());
        /// Console.WriteLine(result.GetProperty("keyvaultReferenceIdentityType").ToString());
        /// Console.WriteLine(result.GetProperty("keyvaultReferenceIdentityId").ToString());
        /// Console.WriteLine(result.GetProperty("resourceId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TestModel20221101</c>:
        /// <code>{
        ///   passFailCriteria: {
        ///     passFailMetrics: Dictionary&lt;string, PassFailMetric20221101&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
        ///   }, # Optional. Pass fail criteria for a test.
        ///   secrets: Dictionary&lt;string, SecretMetadata20221101&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
        ///   certificate: {
        ///     value: string, # Optional. The value of the certificate for respective type
        ///     type: &quot;AKV_CERT_URI&quot;, # Optional. Type of certificate
        ///     name: string, # Optional. Name of the certificate.
        ///   }, # Optional.
        ///   environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
        ///   loadTestConfig: {
        ///     engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
        ///     splitAllCSVs: boolean, # Optional. Whether all the input CSV files should be split evenly across all engines.
        ///     quickStartTest: boolean, # Optional. If true, optionalLoadTestConfig is required and JMX script for the load test is not required to upload.
        ///     optionalLoadTestConfig: {
        ///       endpointUrl: string, # Optional. Endpoint url
        ///       vusers: number, # Optional. No of virtual users 
        ///       rampUpTime: number, # Optional. ramp up time
        ///       duration: number, # Optional. duration
        ///     }, # Optional. Quick start load test config
        ///   }, # Optional. The load test configuration.
        ///   inputArtifacts: {
        ///     configUrl: {
        ///       url: string, # Optional. File URL.
        ///       fileId: string, # Optional. File unique identifier.
        ///       filename: string, # Optional. Name of the file.
        ///       fileType: &quot;JMX_FILE&quot; | &quot;USER_PROPERTIES&quot; | &quot;ADDITIONAL_ARTIFACTS&quot;, # Optional. File type
        ///       expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///       validationStatus: &quot;NOT_VALIDATED&quot; | &quot;VALIDATION_SUCCESS&quot; | &quot;VALIDATION_FAILURE&quot; | &quot;VALIDATION_INITIATED&quot;, # Optional. Validation status of the file
        ///     }, # Optional. FileUrl Model.
        ///     testScriptUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///     userPropUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///     inputArtifactsZipFileurl: FileUrl20221101, # Optional. FileUrl Model.
        ///     additionalUrls: [FileUrl20221101], # Optional. Additional supported files for the test run
        ///   }, # Optional. The input artifacts for the test.
        ///   testId: string, # Optional. Unique test name as identifier.
        ///   description: string, # Optional. The test description.
        ///   displayName: string, # Optional. Display name of a test.
        ///   subnetId: string, # Optional. Subnet ID on which the load test instances should run.
        ///   keyvaultReferenceIdentityType: string, # Optional. Type of the managed identity referencing the Key vault.
        ///   keyvaultReferenceIdentityId: string, # Optional. Resource Id of the managed identity referencing the Key vault.
        ///   resourceId: string, # Optional. Fully qualified resource Id e.g /subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}.
        ///   createdDateTime: string (ISO 8601 Format), # Optional. The created DateTime(ISO 8601 literal format) of the test model.
        ///   createdBy: string, # Optional. The user that created the test model.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified DateTime(ISO 8601 literal format) of the test model.
        ///   lastModifiedBy: string, # Optional. The user that last modified the test model.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetTest(string testId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testId, nameof(testId));

            using var scope = ClientDiagnostics.CreateScope("TestClient.GetTest");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTestRequest(testId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Upload input file for a given test name. File size can&apos;t be more than 50 MB. Existing file with same name for the given test will be overwritten. File should be provided in the request body as multipart/form-data. </summary>
        /// <param name="testId"> Unique name for the load test, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        /// <param name="fileId"> Unique name for test file, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="fileType"> fileType. Allowed values: &quot;JMX_FILE&quot; | &quot;USER_PROPERTIES&quot; | &quot;ADDITIONAL_ARTIFACTS&quot;. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testId"/>, <paramref name="fileId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testId"/> or <paramref name="fileId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call UploadFileAsync with required parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// var data = File.OpenRead("<filePath>");
        /// 
        /// Response response = await client.UploadFileAsync("<testId>", "<fileId>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.ToString());
        /// ]]></code>
        /// This sample shows how to call UploadFileAsync with all parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// var data = File.OpenRead("<filePath>");
        /// 
        /// Response response = await client.UploadFileAsync("<testId>", "<fileId>", RequestContent.Create(data), "<fileType>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("validationStatus").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>FileUrl20221101</c>:
        /// <code>{
        ///   url: string, # Optional. File URL.
        ///   fileId: string, # Optional. File unique identifier.
        ///   filename: string, # Optional. Name of the file.
        ///   fileType: &quot;JMX_FILE&quot; | &quot;USER_PROPERTIES&quot; | &quot;ADDITIONAL_ARTIFACTS&quot;, # Optional. File type
        ///   expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///   validationStatus: &quot;NOT_VALIDATED&quot; | &quot;VALIDATION_SUCCESS&quot; | &quot;VALIDATION_FAILURE&quot; | &quot;VALIDATION_INITIATED&quot;, # Optional. Validation status of the file
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> UploadFileAsync(string testId, string fileId, RequestContent content, string fileType = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testId, nameof(testId));
            Argument.AssertNotNullOrEmpty(fileId, nameof(fileId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("TestClient.UploadFile");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUploadFileRequest(testId, fileId, content, fileType, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Upload input file for a given test name. File size can&apos;t be more than 50 MB. Existing file with same name for the given test will be overwritten. File should be provided in the request body as multipart/form-data. </summary>
        /// <param name="testId"> Unique name for the load test, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        /// <param name="fileId"> Unique name for test file, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="fileType"> fileType. Allowed values: &quot;JMX_FILE&quot; | &quot;USER_PROPERTIES&quot; | &quot;ADDITIONAL_ARTIFACTS&quot;. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testId"/>, <paramref name="fileId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testId"/> or <paramref name="fileId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call UploadFile with required parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// var data = File.OpenRead("<filePath>");
        /// 
        /// Response response = client.UploadFile("<testId>", "<fileId>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.ToString());
        /// ]]></code>
        /// This sample shows how to call UploadFile with all parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// var data = File.OpenRead("<filePath>");
        /// 
        /// Response response = client.UploadFile("<testId>", "<fileId>", RequestContent.Create(data), "<fileType>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("validationStatus").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>FileUrl20221101</c>:
        /// <code>{
        ///   url: string, # Optional. File URL.
        ///   fileId: string, # Optional. File unique identifier.
        ///   filename: string, # Optional. Name of the file.
        ///   fileType: &quot;JMX_FILE&quot; | &quot;USER_PROPERTIES&quot; | &quot;ADDITIONAL_ARTIFACTS&quot;, # Optional. File type
        ///   expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///   validationStatus: &quot;NOT_VALIDATED&quot; | &quot;VALIDATION_SUCCESS&quot; | &quot;VALIDATION_FAILURE&quot; | &quot;VALIDATION_INITIATED&quot;, # Optional. Validation status of the file
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response UploadFile(string testId, string fileId, RequestContent content, string fileType = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testId, nameof(testId));
            Argument.AssertNotNullOrEmpty(fileId, nameof(fileId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("TestClient.UploadFile");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUploadFileRequest(testId, fileId, content, fileType, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get test file by the file name. </summary>
        /// <param name="testId"> Unique name for the load test, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        /// <param name="fileId"> Unique name for test file, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testId"/> or <paramref name="fileId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testId"/> or <paramref name="fileId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetFileAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = await client.GetFileAsync("<testId>", "<fileId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("validationStatus").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>FileUrl20221101</c>:
        /// <code>{
        ///   url: string, # Optional. File URL.
        ///   fileId: string, # Optional. File unique identifier.
        ///   filename: string, # Optional. Name of the file.
        ///   fileType: &quot;JMX_FILE&quot; | &quot;USER_PROPERTIES&quot; | &quot;ADDITIONAL_ARTIFACTS&quot;, # Optional. File type
        ///   expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///   validationStatus: &quot;NOT_VALIDATED&quot; | &quot;VALIDATION_SUCCESS&quot; | &quot;VALIDATION_FAILURE&quot; | &quot;VALIDATION_INITIATED&quot;, # Optional. Validation status of the file
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetFileAsync(string testId, string fileId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testId, nameof(testId));
            Argument.AssertNotNullOrEmpty(fileId, nameof(fileId));

            using var scope = ClientDiagnostics.CreateScope("TestClient.GetFile");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetFileRequest(testId, fileId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get test file by the file name. </summary>
        /// <param name="testId"> Unique name for the load test, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        /// <param name="fileId"> Unique name for test file, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testId"/> or <paramref name="fileId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testId"/> or <paramref name="fileId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetFile with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = client.GetFile("<testId>", "<fileId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("validationStatus").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>FileUrl20221101</c>:
        /// <code>{
        ///   url: string, # Optional. File URL.
        ///   fileId: string, # Optional. File unique identifier.
        ///   filename: string, # Optional. Name of the file.
        ///   fileType: &quot;JMX_FILE&quot; | &quot;USER_PROPERTIES&quot; | &quot;ADDITIONAL_ARTIFACTS&quot;, # Optional. File type
        ///   expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///   validationStatus: &quot;NOT_VALIDATED&quot; | &quot;VALIDATION_SUCCESS&quot; | &quot;VALIDATION_FAILURE&quot; | &quot;VALIDATION_INITIATED&quot;, # Optional. Validation status of the file
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetFile(string testId, string fileId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testId, nameof(testId));
            Argument.AssertNotNullOrEmpty(fileId, nameof(fileId));

            using var scope = ClientDiagnostics.CreateScope("TestClient.GetFile");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetFileRequest(testId, fileId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete file by the file name for a test. </summary>
        /// <param name="testId"> Unique name for the load test, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        /// <param name="fileId"> Unique name for test file, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testId"/> or <paramref name="fileId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testId"/> or <paramref name="fileId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call DeleteFileAsync with required parameters.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = await client.DeleteFileAsync("<testId>", "<fileId>");
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        public virtual async Task<Response> DeleteFileAsync(string testId, string fileId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testId, nameof(testId));
            Argument.AssertNotNullOrEmpty(fileId, nameof(fileId));

            using var scope = ClientDiagnostics.CreateScope("TestClient.DeleteFile");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteFileRequest(testId, fileId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete file by the file name for a test. </summary>
        /// <param name="testId"> Unique name for the load test, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        /// <param name="fileId"> Unique name for test file, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testId"/> or <paramref name="fileId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testId"/> or <paramref name="fileId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call DeleteFile with required parameters.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = client.DeleteFile("<testId>", "<fileId>");
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        public virtual Response DeleteFile(string testId, string fileId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testId, nameof(testId));
            Argument.AssertNotNullOrEmpty(fileId, nameof(fileId));

            using var scope = ClientDiagnostics.CreateScope("TestClient.DeleteFile");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteFileRequest(testId, fileId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get all load tests by the fully qualified resource Id e.g subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}. </summary>
        /// <param name="orderBy"> Sort on one of the field - lastModifiedDateTime, displayName, createdBy in (field asc/desc) format. eg: displayName asc. </param>
        /// <param name="search"> Filter search based on searchable fields - testId, createdBy. </param>
        /// <param name="lastUpdatedStartTime"> Start DateTime(ISO 8601 literal format) of the last updated time range to filter tests. </param>
        /// <param name="lastUpdatedEndTime"> End DateTime(ISO 8601 literal format) of the last updated time range to filter tests. </param>
        /// <param name="continuationToken"> Continuation token to get the next page of response. </param>
        /// <param name="maxPageSize"> Number of results in response. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTestsAsync and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// await foreach (var data in client.GetTestsAsync())
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetTestsAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// await foreach (var data in client.GetTestsAsync("<orderBy>", "<search>", DateTimeOffset.UtcNow, DateTimeOffset.UtcNow, "<continuationToken>", 1234))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("clientmetric").ToString());
        ///     Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("aggregate").ToString());
        ///     Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("condition").ToString());
        ///     Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("requestName").ToString());
        ///     Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("value").ToString());
        ///     Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("action").ToString());
        ///     Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("actualValue").ToString());
        ///     Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("result").ToString());
        ///     Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("value").ToString());
        ///     Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("type").ToString());
        ///     Console.WriteLine(result.GetProperty("certificate").GetProperty("value").ToString());
        ///     Console.WriteLine(result.GetProperty("certificate").GetProperty("type").ToString());
        ///     Console.WriteLine(result.GetProperty("certificate").GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("environmentVariables").GetProperty("<test>").ToString());
        ///     Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("engineInstances").ToString());
        ///     Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("splitAllCSVs").ToString());
        ///     Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("quickStartTest").ToString());
        ///     Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("endpointUrl").ToString());
        ///     Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("vusers").ToString());
        ///     Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("rampUpTime").ToString());
        ///     Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("duration").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("url").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileId").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("filename").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileType").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("expireTime").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("validationStatus").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("url").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileId").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("filename").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileType").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("expireTime").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("validationStatus").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("url").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileId").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("filename").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileType").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("expireTime").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("validationStatus").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("url").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileId").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("filename").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileType").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("expireTime").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("validationStatus").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("url").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileId").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("filename").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileType").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("expireTime").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("validationStatus").ToString());
        ///     Console.WriteLine(result.GetProperty("testId").ToString());
        ///     Console.WriteLine(result.GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("displayName").ToString());
        ///     Console.WriteLine(result.GetProperty("subnetId").ToString());
        ///     Console.WriteLine(result.GetProperty("keyvaultReferenceIdentityType").ToString());
        ///     Console.WriteLine(result.GetProperty("keyvaultReferenceIdentityId").ToString());
        ///     Console.WriteLine(result.GetProperty("resourceId").ToString());
        ///     Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("createdBy").ToString());
        ///     Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TestModel20221101ResourceListValue</c>:
        /// <code>{
        ///   passFailCriteria: {
        ///     passFailMetrics: Dictionary&lt;string, PassFailMetric20221101&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
        ///   }, # Optional. Pass fail criteria for a test.
        ///   secrets: Dictionary&lt;string, SecretMetadata20221101&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
        ///   certificate: {
        ///     value: string, # Optional. The value of the certificate for respective type
        ///     type: &quot;AKV_CERT_URI&quot;, # Optional. Type of certificate
        ///     name: string, # Optional. Name of the certificate.
        ///   }, # Optional.
        ///   environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
        ///   loadTestConfig: {
        ///     engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
        ///     splitAllCSVs: boolean, # Optional. Whether all the input CSV files should be split evenly across all engines.
        ///     quickStartTest: boolean, # Optional. If true, optionalLoadTestConfig is required and JMX script for the load test is not required to upload.
        ///     optionalLoadTestConfig: {
        ///       endpointUrl: string, # Optional. Endpoint url
        ///       vusers: number, # Optional. No of virtual users 
        ///       rampUpTime: number, # Optional. ramp up time
        ///       duration: number, # Optional. duration
        ///     }, # Optional. Quick start load test config
        ///   }, # Optional. The load test configuration.
        ///   inputArtifacts: {
        ///     configUrl: {
        ///       url: string, # Optional. File URL.
        ///       fileId: string, # Optional. File unique identifier.
        ///       filename: string, # Optional. Name of the file.
        ///       fileType: &quot;JMX_FILE&quot; | &quot;USER_PROPERTIES&quot; | &quot;ADDITIONAL_ARTIFACTS&quot;, # Optional. File type
        ///       expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///       validationStatus: &quot;NOT_VALIDATED&quot; | &quot;VALIDATION_SUCCESS&quot; | &quot;VALIDATION_FAILURE&quot; | &quot;VALIDATION_INITIATED&quot;, # Optional. Validation status of the file
        ///     }, # Optional. FileUrl Model.
        ///     testScriptUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///     userPropUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///     inputArtifactsZipFileurl: FileUrl20221101, # Optional. FileUrl Model.
        ///     additionalUrls: [FileUrl20221101], # Optional. Additional supported files for the test run
        ///   }, # Optional. The input artifacts for the test.
        ///   testId: string, # Optional. Unique test name as identifier.
        ///   description: string, # Optional. The test description.
        ///   displayName: string, # Optional. Display name of a test.
        ///   subnetId: string, # Optional. Subnet ID on which the load test instances should run.
        ///   keyvaultReferenceIdentityType: string, # Optional. Type of the managed identity referencing the Key vault.
        ///   keyvaultReferenceIdentityId: string, # Optional. Resource Id of the managed identity referencing the Key vault.
        ///   resourceId: string, # Optional. Fully qualified resource Id e.g /subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}.
        ///   createdDateTime: string (ISO 8601 Format), # Optional. The created DateTime(ISO 8601 literal format) of the test model.
        ///   createdBy: string, # Optional. The user that created the test model.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified DateTime(ISO 8601 literal format) of the test model.
        ///   lastModifiedBy: string, # Optional. The user that last modified the test model.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetTestsAsync(string orderBy = null, string search = null, DateTimeOffset? lastUpdatedStartTime = null, DateTimeOffset? lastUpdatedEndTime = null, string continuationToken = null, int? maxPageSize = null, RequestContext context = null)
        {
            return GetTestsImplementationAsync("TestClient.GetTests", orderBy, search, lastUpdatedStartTime, lastUpdatedEndTime, continuationToken, maxPageSize, context);
        }

        private AsyncPageable<BinaryData> GetTestsImplementationAsync(string diagnosticsScopeName, string orderBy, string search, DateTimeOffset? lastUpdatedStartTime, DateTimeOffset? lastUpdatedEndTime, string continuationToken, int? maxPageSize, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetTestsRequest(orderBy, search, lastUpdatedStartTime, lastUpdatedEndTime, continuationToken, maxPageSize, context)
                        : CreateGetTestsNextPageRequest(nextLink, orderBy, search, lastUpdatedStartTime, lastUpdatedEndTime, continuationToken, maxPageSize, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Get all load tests by the fully qualified resource Id e.g subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}. </summary>
        /// <param name="orderBy"> Sort on one of the field - lastModifiedDateTime, displayName, createdBy in (field asc/desc) format. eg: displayName asc. </param>
        /// <param name="search"> Filter search based on searchable fields - testId, createdBy. </param>
        /// <param name="lastUpdatedStartTime"> Start DateTime(ISO 8601 literal format) of the last updated time range to filter tests. </param>
        /// <param name="lastUpdatedEndTime"> End DateTime(ISO 8601 literal format) of the last updated time range to filter tests. </param>
        /// <param name="continuationToken"> Continuation token to get the next page of response. </param>
        /// <param name="maxPageSize"> Number of results in response. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTests and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// foreach (var data in client.GetTests())
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetTests with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// foreach (var data in client.GetTests("<orderBy>", "<search>", DateTimeOffset.UtcNow, DateTimeOffset.UtcNow, "<continuationToken>", 1234))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("clientmetric").ToString());
        ///     Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("aggregate").ToString());
        ///     Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("condition").ToString());
        ///     Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("requestName").ToString());
        ///     Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("value").ToString());
        ///     Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("action").ToString());
        ///     Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("actualValue").ToString());
        ///     Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("result").ToString());
        ///     Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("value").ToString());
        ///     Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("type").ToString());
        ///     Console.WriteLine(result.GetProperty("certificate").GetProperty("value").ToString());
        ///     Console.WriteLine(result.GetProperty("certificate").GetProperty("type").ToString());
        ///     Console.WriteLine(result.GetProperty("certificate").GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("environmentVariables").GetProperty("<test>").ToString());
        ///     Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("engineInstances").ToString());
        ///     Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("splitAllCSVs").ToString());
        ///     Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("quickStartTest").ToString());
        ///     Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("endpointUrl").ToString());
        ///     Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("vusers").ToString());
        ///     Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("rampUpTime").ToString());
        ///     Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("duration").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("url").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileId").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("filename").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileType").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("expireTime").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("validationStatus").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("url").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileId").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("filename").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileType").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("expireTime").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("validationStatus").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("url").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileId").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("filename").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileType").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("expireTime").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("validationStatus").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("url").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileId").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("filename").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileType").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("expireTime").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("validationStatus").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("url").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileId").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("filename").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileType").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("expireTime").ToString());
        ///     Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("validationStatus").ToString());
        ///     Console.WriteLine(result.GetProperty("testId").ToString());
        ///     Console.WriteLine(result.GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("displayName").ToString());
        ///     Console.WriteLine(result.GetProperty("subnetId").ToString());
        ///     Console.WriteLine(result.GetProperty("keyvaultReferenceIdentityType").ToString());
        ///     Console.WriteLine(result.GetProperty("keyvaultReferenceIdentityId").ToString());
        ///     Console.WriteLine(result.GetProperty("resourceId").ToString());
        ///     Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("createdBy").ToString());
        ///     Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TestModel20221101ResourceListValue</c>:
        /// <code>{
        ///   passFailCriteria: {
        ///     passFailMetrics: Dictionary&lt;string, PassFailMetric20221101&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
        ///   }, # Optional. Pass fail criteria for a test.
        ///   secrets: Dictionary&lt;string, SecretMetadata20221101&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
        ///   certificate: {
        ///     value: string, # Optional. The value of the certificate for respective type
        ///     type: &quot;AKV_CERT_URI&quot;, # Optional. Type of certificate
        ///     name: string, # Optional. Name of the certificate.
        ///   }, # Optional.
        ///   environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
        ///   loadTestConfig: {
        ///     engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
        ///     splitAllCSVs: boolean, # Optional. Whether all the input CSV files should be split evenly across all engines.
        ///     quickStartTest: boolean, # Optional. If true, optionalLoadTestConfig is required and JMX script for the load test is not required to upload.
        ///     optionalLoadTestConfig: {
        ///       endpointUrl: string, # Optional. Endpoint url
        ///       vusers: number, # Optional. No of virtual users 
        ///       rampUpTime: number, # Optional. ramp up time
        ///       duration: number, # Optional. duration
        ///     }, # Optional. Quick start load test config
        ///   }, # Optional. The load test configuration.
        ///   inputArtifacts: {
        ///     configUrl: {
        ///       url: string, # Optional. File URL.
        ///       fileId: string, # Optional. File unique identifier.
        ///       filename: string, # Optional. Name of the file.
        ///       fileType: &quot;JMX_FILE&quot; | &quot;USER_PROPERTIES&quot; | &quot;ADDITIONAL_ARTIFACTS&quot;, # Optional. File type
        ///       expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///       validationStatus: &quot;NOT_VALIDATED&quot; | &quot;VALIDATION_SUCCESS&quot; | &quot;VALIDATION_FAILURE&quot; | &quot;VALIDATION_INITIATED&quot;, # Optional. Validation status of the file
        ///     }, # Optional. FileUrl Model.
        ///     testScriptUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///     userPropUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///     inputArtifactsZipFileurl: FileUrl20221101, # Optional. FileUrl Model.
        ///     additionalUrls: [FileUrl20221101], # Optional. Additional supported files for the test run
        ///   }, # Optional. The input artifacts for the test.
        ///   testId: string, # Optional. Unique test name as identifier.
        ///   description: string, # Optional. The test description.
        ///   displayName: string, # Optional. Display name of a test.
        ///   subnetId: string, # Optional. Subnet ID on which the load test instances should run.
        ///   keyvaultReferenceIdentityType: string, # Optional. Type of the managed identity referencing the Key vault.
        ///   keyvaultReferenceIdentityId: string, # Optional. Resource Id of the managed identity referencing the Key vault.
        ///   resourceId: string, # Optional. Fully qualified resource Id e.g /subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}.
        ///   createdDateTime: string (ISO 8601 Format), # Optional. The created DateTime(ISO 8601 literal format) of the test model.
        ///   createdBy: string, # Optional. The user that created the test model.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified DateTime(ISO 8601 literal format) of the test model.
        ///   lastModifiedBy: string, # Optional. The user that last modified the test model.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetTests(string orderBy = null, string search = null, DateTimeOffset? lastUpdatedStartTime = null, DateTimeOffset? lastUpdatedEndTime = null, string continuationToken = null, int? maxPageSize = null, RequestContext context = null)
        {
            return GetTestsImplementation("TestClient.GetTests", orderBy, search, lastUpdatedStartTime, lastUpdatedEndTime, continuationToken, maxPageSize, context);
        }

        private Pageable<BinaryData> GetTestsImplementation(string diagnosticsScopeName, string orderBy, string search, DateTimeOffset? lastUpdatedStartTime, DateTimeOffset? lastUpdatedEndTime, string continuationToken, int? maxPageSize, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetTestsRequest(orderBy, search, lastUpdatedStartTime, lastUpdatedEndTime, continuationToken, maxPageSize, context)
                        : CreateGetTestsNextPageRequest(nextLink, orderBy, search, lastUpdatedStartTime, lastUpdatedEndTime, continuationToken, maxPageSize, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Get all test files. </summary>
        /// <param name="testId"> Unique name for the load test, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        /// <param name="continuationToken"> Continuation token to get the next page of response. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetAllFilesAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// await foreach (var data in client.GetAllFilesAsync("<testId>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetAllFilesAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// await foreach (var data in client.GetAllFilesAsync("<testId>", "<continuationToken>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("url").ToString());
        ///     Console.WriteLine(result.GetProperty("fileId").ToString());
        ///     Console.WriteLine(result.GetProperty("filename").ToString());
        ///     Console.WriteLine(result.GetProperty("fileType").ToString());
        ///     Console.WriteLine(result.GetProperty("expireTime").ToString());
        ///     Console.WriteLine(result.GetProperty("validationStatus").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>FileUrlListValue</c>:
        /// <code>{
        ///   url: string, # Optional. File URL.
        ///   fileId: string, # Optional. File unique identifier.
        ///   filename: string, # Optional. Name of the file.
        ///   fileType: &quot;JMX_FILE&quot; | &quot;USER_PROPERTIES&quot; | &quot;ADDITIONAL_ARTIFACTS&quot;, # Optional. File type
        ///   expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///   validationStatus: &quot;NOT_VALIDATED&quot; | &quot;VALIDATION_SUCCESS&quot; | &quot;VALIDATION_FAILURE&quot; | &quot;VALIDATION_INITIATED&quot;, # Optional. Validation status of the file
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetAllFilesAsync(string testId, string continuationToken = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testId, nameof(testId));

            return GetAllFilesImplementationAsync("TestClient.GetAllFiles", testId, continuationToken, context);
        }

        private AsyncPageable<BinaryData> GetAllFilesImplementationAsync(string diagnosticsScopeName, string testId, string continuationToken, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetAllFilesRequest(testId, continuationToken, context)
                        : CreateGetAllFilesNextPageRequest(nextLink, testId, continuationToken, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Get all test files. </summary>
        /// <param name="testId"> Unique name for the load test, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        /// <param name="continuationToken"> Continuation token to get the next page of response. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetAllFiles with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// foreach (var data in client.GetAllFiles("<testId>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetAllFiles with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// foreach (var data in client.GetAllFiles("<testId>", "<continuationToken>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("url").ToString());
        ///     Console.WriteLine(result.GetProperty("fileId").ToString());
        ///     Console.WriteLine(result.GetProperty("filename").ToString());
        ///     Console.WriteLine(result.GetProperty("fileType").ToString());
        ///     Console.WriteLine(result.GetProperty("expireTime").ToString());
        ///     Console.WriteLine(result.GetProperty("validationStatus").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>FileUrlListValue</c>:
        /// <code>{
        ///   url: string, # Optional. File URL.
        ///   fileId: string, # Optional. File unique identifier.
        ///   filename: string, # Optional. Name of the file.
        ///   fileType: &quot;JMX_FILE&quot; | &quot;USER_PROPERTIES&quot; | &quot;ADDITIONAL_ARTIFACTS&quot;, # Optional. File type
        ///   expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///   validationStatus: &quot;NOT_VALIDATED&quot; | &quot;VALIDATION_SUCCESS&quot; | &quot;VALIDATION_FAILURE&quot; | &quot;VALIDATION_INITIATED&quot;, # Optional. Validation status of the file
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetAllFiles(string testId, string continuationToken = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testId, nameof(testId));

            return GetAllFilesImplementation("TestClient.GetAllFiles", testId, continuationToken, context);
        }

        private Pageable<BinaryData> GetAllFilesImplementation(string diagnosticsScopeName, string testId, string continuationToken, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetAllFilesRequest(testId, continuationToken, context)
                        : CreateGetAllFilesNextPageRequest(nextLink, testId, continuationToken, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        internal HttpMessage CreateCreateOrUpdateRequest(string testId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200201);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_endpoint, false);
            uri.AppendPath("/loadtests/", false);
            uri.AppendPath(testId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/merge-patch+json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteRequest(string testId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_endpoint, false);
            uri.AppendPath("/loadtests/", false);
            uri.AppendPath(testId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetTestRequest(string testId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_endpoint, false);
            uri.AppendPath("/loadtests/", false);
            uri.AppendPath(testId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetTestsRequest(string orderBy, string search, DateTimeOffset? lastUpdatedStartTime, DateTimeOffset? lastUpdatedEndTime, string continuationToken, int? maxPageSize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_endpoint, false);
            uri.AppendPath("/loadtests/sortAndFilter", false);
            if (orderBy != null)
            {
                uri.AppendQuery("orderBy", orderBy, true);
            }
            if (search != null)
            {
                uri.AppendQuery("search", search, true);
            }
            if (lastUpdatedStartTime != null)
            {
                uri.AppendQuery("lastUpdatedStartTime", lastUpdatedStartTime.Value, "O", true);
            }
            if (lastUpdatedEndTime != null)
            {
                uri.AppendQuery("lastUpdatedEndTime", lastUpdatedEndTime.Value, "O", true);
            }
            if (continuationToken != null)
            {
                uri.AppendQuery("continuationToken", continuationToken, true);
            }
            if (maxPageSize != null)
            {
                uri.AppendQuery("maxPageSize", maxPageSize.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateUploadFileRequest(string testId, string fileId, RequestContent content, string fileType, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier201);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_endpoint, false);
            uri.AppendPath("/loadtests/", false);
            uri.AppendPath(testId, true);
            uri.AppendPath("/files/", false);
            uri.AppendPath(fileId, true);
            if (fileType != null)
            {
                uri.AppendQuery("fileType", fileType, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "multipart/form-data");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetFileRequest(string testId, string fileId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_endpoint, false);
            uri.AppendPath("/loadtests/", false);
            uri.AppendPath(testId, true);
            uri.AppendPath("/files/", false);
            uri.AppendPath(fileId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateDeleteFileRequest(string testId, string fileId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_endpoint, false);
            uri.AppendPath("/loadtests/", false);
            uri.AppendPath(testId, true);
            uri.AppendPath("/files/", false);
            uri.AppendPath(fileId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetAllFilesRequest(string testId, string continuationToken, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_endpoint, false);
            uri.AppendPath("/loadtests/", false);
            uri.AppendPath(testId, true);
            uri.AppendPath("/files", false);
            if (continuationToken != null)
            {
                uri.AppendQuery("continuationToken", continuationToken, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetTestsNextPageRequest(string nextLink, string orderBy, string search, DateTimeOffset? lastUpdatedStartTime, DateTimeOffset? lastUpdatedEndTime, string continuationToken, int? maxPageSize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_endpoint, false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetAllFilesNextPageRequest(string nextLink, string testId, string continuationToken, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_endpoint, false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        private static ResponseClassifier _responseClassifier200201;
        private static ResponseClassifier ResponseClassifier200201 => _responseClassifier200201 ??= new StatusCodeClassifier(stackalloc ushort[] { 200, 201 });
        private static ResponseClassifier _responseClassifier204;
        private static ResponseClassifier ResponseClassifier204 => _responseClassifier204 ??= new StatusCodeClassifier(stackalloc ushort[] { 204 });
        private static ResponseClassifier _responseClassifier200;
        private static ResponseClassifier ResponseClassifier200 => _responseClassifier200 ??= new StatusCodeClassifier(stackalloc ushort[] { 200 });
        private static ResponseClassifier _responseClassifier201;
        private static ResponseClassifier ResponseClassifier201 => _responseClassifier201 ??= new StatusCodeClassifier(stackalloc ushort[] { 201 });
    }
}
