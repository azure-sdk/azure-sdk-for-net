// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.Template.LoadTesting
{
    // Data plane generated client. The TestRun service client.
    /// <summary> The TestRun service client. </summary>
    public partial class TestRunClient
    {
        private static readonly string[] AuthorizationScopes = new string[] { "https://loadtest.azure-dev.com/.default" };
        private readonly TokenCredential _tokenCredential;
        private readonly HttpPipeline _pipeline;
        private readonly string _endpoint;
        private readonly string _apiVersion;
        private readonly string _testId;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of TestRunClient for mocking. </summary>
        protected TestRunClient()
        {
        }

        /// <summary> Initializes a new instance of TestRunClient. </summary>
        /// <param name="endpoint"> URL to perform data plane API operations on the resource. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="endpoint"/> or <paramref name="credential"/> is null. </exception>
        public TestRunClient(string endpoint, TokenCredential credential) : this(endpoint, credential, null, new LoadTestingClientOptions())
        {
        }

        /// <summary> Initializes a new instance of TestRunClient. </summary>
        /// <param name="endpoint"> URL to perform data plane API operations on the resource. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <param name="testId"> Unique name of an existing load test. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="endpoint"/> or <paramref name="credential"/> is null. </exception>
        public TestRunClient(string endpoint, TokenCredential credential, string testId, LoadTestingClientOptions options)
        {
            Argument.AssertNotNull(endpoint, nameof(endpoint));
            Argument.AssertNotNull(credential, nameof(credential));
            options ??= new LoadTestingClientOptions();

            ClientDiagnostics = new ClientDiagnostics(options, true);
            _tokenCredential = credential;
            _pipeline = HttpPipelineBuilder.Build(options, Array.Empty<HttpPipelinePolicy>(), new HttpPipelinePolicy[] { new BearerTokenAuthenticationPolicy(_tokenCredential, AuthorizationScopes) }, new ResponseClassifier());
            _endpoint = endpoint;
            _apiVersion = options.Version;
            _testId = testId;
        }

        /// <summary> Delete a test run by its name. </summary>
        /// <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testRunId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testRunId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call DeleteAsync with required parameters.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestRunClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = await client.DeleteAsync("<testRunId>");
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        public virtual async Task<Response> DeleteAsync(string testRunId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testRunId, nameof(testRunId));

            using var scope = ClientDiagnostics.CreateScope("TestRunClient.Delete");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteRequest(testRunId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete a test run by its name. </summary>
        /// <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testRunId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testRunId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call Delete with required parameters.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestRunClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = client.Delete("<testRunId>");
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        public virtual Response Delete(string testRunId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testRunId, nameof(testRunId));

            using var scope = ClientDiagnostics.CreateScope("TestRunClient.Delete");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteRequest(testRunId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create and start a new test run with the given name. </summary>
        /// <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="oldTestRunId"> Existing test run Id that should be rerun. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testRunId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testRunId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call CreateOrUpdateAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestRunClient("<https://my-service.azure.com>", credential);
        /// 
        /// var data = new {};
        /// 
        /// Response response = await client.CreateOrUpdateAsync("<testRunId>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.ToString());
        /// ]]></code>
        /// This sample shows how to call CreateOrUpdateAsync with all parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestRunClient("<https://my-service.azure.com>", credential);
        /// 
        /// var data = new {
        ///     passFailCriteria = new {
        ///         passFailMetrics = new {
        ///             key = new {
        ///                 clientmetric = "response_time_ms",
        ///                 aggregate = "count",
        ///                 condition = "<condition>",
        ///                 requestName = "<requestName>",
        ///                 value = 123.45d,
        ///                 action = "stop",
        ///             },
        ///         },
        ///     },
        ///     secrets = new {
        ///         key = new {
        ///             value = "<value>",
        ///             type = "AKV_SECRET_URI",
        ///         },
        ///     },
        ///     certificate = new {
        ///         value = "<value>",
        ///         type = "AKV_CERT_URI",
        ///         name = "<name>",
        ///     },
        ///     environmentVariables = new {
        ///         key = "<String>",
        ///     },
        ///     loadTestConfig = new {
        ///         engineInstances = 1234,
        ///         splitAllCSVs = true,
        ///         quickStartTest = true,
        ///         optionalLoadTestConfig = new {
        ///             endpointUrl = "<endpointUrl>",
        ///             vusers = 1234,
        ///             rampUpTime = 1234,
        ///             duration = 1234,
        ///         },
        ///     },
        ///     displayName = "<displayName>",
        ///     testId = "<testId>",
        ///     description = "<description>",
        /// };
        /// 
        /// Response response = await client.CreateOrUpdateAsync("<testRunId>", RequestContent.Create(data), "<oldTestRunId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("clientmetric").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("aggregate").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("condition").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("requestName").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("action").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("actualValue").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("result").ToString());
        /// Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("certificate").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("certificate").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("certificate").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("environmentVariables").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errorDetails")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("transaction").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("sampleCount").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("errorCount").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("errorPct").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("meanResTime").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("medianResTime").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("maxResTime").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("minResTime").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("pct1ResTime").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("pct2ResTime").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("pct3ResTime").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("throughput").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("receivedKBytesPerSec").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("sentKBytesPerSec").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("engineInstances").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("splitAllCSVs").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("quickStartTest").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("endpointUrl").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("vusers").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("rampUpTime").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("duration").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("testResult").ToString());
        /// Console.WriteLine(result.GetProperty("testRunId").ToString());
        /// Console.WriteLine(result.GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("testId").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("startDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("endDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("executedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("vusers").ToString());
        /// Console.WriteLine(result.GetProperty("portalUrl").ToString());
        /// Console.WriteLine(result.GetProperty("duration").ToString());
        /// Console.WriteLine(result.GetProperty("subnetId").ToString());
        /// Console.WriteLine(result.GetProperty("resourceId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>TestRunModel20221101</c>:
        /// <code>{
        ///   passFailCriteria: {
        ///     passFailMetrics: Dictionary&lt;string, PassFailMetric20221101&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
        ///   }, # Optional. Pass fail criteria for a test.
        ///   secrets: Dictionary&lt;string, SecretMetadata20221101&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
        ///   certificate: {
        ///     value: string, # Optional. The value of the certificate for respective type
        ///     type: &quot;AKV_CERT_URI&quot;, # Optional. Type of certificate
        ///     name: string, # Optional. Name of the certificate.
        ///   }, # Optional.
        ///   environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
        ///   errorDetails: [
        ///     {
        ///       message: string, # Optional. Error details in case test run was not successfully run.
        ///     }
        ///   ], # Optional. Error details if there is any failure in load test run
        ///   testRunStatistics: Dictionary&lt;string, TestRunStatisticsModel&gt;, # Optional. Test run statistics.
        ///   loadTestConfig: {
        ///     engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
        ///     splitAllCSVs: boolean, # Optional. Whether all the input CSV files should be split evenly across all engines.
        ///     quickStartTest: boolean, # Optional. If true, optionalLoadTestConfig is required and JMX script for the load test is not required to upload.
        ///     optionalLoadTestConfig: {
        ///       endpointUrl: string, # Optional. Endpoint url
        ///       vusers: number, # Optional. No of virtual users 
        ///       rampUpTime: number, # Optional. ramp up time
        ///       duration: number, # Optional. duration
        ///     }, # Optional. Quick start load test config
        ///   }, # Optional. The load test configuration.
        ///   testArtifacts: {
        ///     inputArtifacts: {
        ///       configUrl: {
        ///         url: string, # Optional. File URL.
        ///         fileId: string, # Optional. File unique identifier.
        ///         filename: string, # Optional. Name of the file.
        ///         fileType: &quot;JMX_FILE&quot; | &quot;USER_PROPERTIES&quot; | &quot;ADDITIONAL_ARTIFACTS&quot;, # Optional. File type
        ///         expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///         validationStatus: &quot;NOT_VALIDATED&quot; | &quot;VALIDATION_SUCCESS&quot; | &quot;VALIDATION_FAILURE&quot; | &quot;VALIDATION_INITIATED&quot;, # Optional. Validation status of the file
        ///       }, # Optional. FileUrl Model.
        ///       testScriptUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///       userPropUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///       inputArtifactsZipFileurl: FileUrl20221101, # Optional. FileUrl Model.
        ///       additionalUrls: [FileUrl20221101], # Optional. Additional supported files for the test run
        ///     }, # Required. The input artifacts for the test.
        ///     outputArtifacts: {
        ///       resultUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///       logsUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///     }, # Optional. The output artifacts for the test run.
        ///   }, # Optional. test artifact 20221101
        ///   testResult: &quot;PASSED&quot; | &quot;NOT_APPLICABLE&quot; | &quot;FAILED&quot;, # Optional. Test result for pass/Fail criteria used during the test run.
        ///   testRunId: string, # Optional. Unique test run name as identifier
        ///   displayName: string, # Optional. Display name of a testRun.
        ///   testId: string, # Optional. Associated test Id.
        ///   description: string, # Optional. The test run description.
        ///   status: &quot;ACCEPTED&quot; | &quot;NOTSTARTED&quot; | &quot;PROVISIONING&quot; | &quot;PROVISIONED&quot; | &quot;CONFIGURING&quot; | &quot;CONFIGURED&quot; | &quot;EXECUTING&quot; | &quot;EXECUTED&quot; | &quot;DEPROVISIONING&quot; | &quot;DEPROVISIONED&quot; | &quot;DONE&quot; | &quot;CANCELLING&quot; | &quot;CANCELLED&quot; | &quot;FAILED&quot; | &quot;VALIDATION_SUCCESS&quot; | &quot;VALIDATION_FAILURE&quot;, # Optional. The test run status.
        ///   startDateTime: string (ISO 8601 Format), # Optional. The test run start DateTime(ISO 8601 literal format).
        ///   endDateTime: string (ISO 8601 Format), # Optional. The test run end DateTime(ISO 8601 literal format).
        ///   executedDateTime: string (ISO 8601 Format), # Optional. Test run initiated time.
        ///   vusers: number, # Optional. Number of virtual users, for which test has been run.
        ///   portalUrl: string, # Optional. Portal url.
        ///   duration: number, # Optional. Test run duration in milliseconds.
        ///   subnetId: string, # Optional. Subnet ID on which the load test instances should run.
        ///   resourceId: string, # Optional. Fully qualified resource Id e.g /subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}.
        ///   createdDateTime: string (ISO 8601 Format), # Optional. The created DateTime(ISO 8601 literal format) of the test model.
        ///   createdBy: string, # Optional. The user that created the test model.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified DateTime(ISO 8601 literal format) of the test model.
        ///   lastModifiedBy: string, # Optional. The user that last modified the test model.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TestRunModel20221101</c>:
        /// <code>{
        ///   passFailCriteria: {
        ///     passFailMetrics: Dictionary&lt;string, PassFailMetric20221101&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
        ///   }, # Optional. Pass fail criteria for a test.
        ///   secrets: Dictionary&lt;string, SecretMetadata20221101&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
        ///   certificate: {
        ///     value: string, # Optional. The value of the certificate for respective type
        ///     type: &quot;AKV_CERT_URI&quot;, # Optional. Type of certificate
        ///     name: string, # Optional. Name of the certificate.
        ///   }, # Optional.
        ///   environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
        ///   errorDetails: [
        ///     {
        ///       message: string, # Optional. Error details in case test run was not successfully run.
        ///     }
        ///   ], # Optional. Error details if there is any failure in load test run
        ///   testRunStatistics: Dictionary&lt;string, TestRunStatisticsModel&gt;, # Optional. Test run statistics.
        ///   loadTestConfig: {
        ///     engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
        ///     splitAllCSVs: boolean, # Optional. Whether all the input CSV files should be split evenly across all engines.
        ///     quickStartTest: boolean, # Optional. If true, optionalLoadTestConfig is required and JMX script for the load test is not required to upload.
        ///     optionalLoadTestConfig: {
        ///       endpointUrl: string, # Optional. Endpoint url
        ///       vusers: number, # Optional. No of virtual users 
        ///       rampUpTime: number, # Optional. ramp up time
        ///       duration: number, # Optional. duration
        ///     }, # Optional. Quick start load test config
        ///   }, # Optional. The load test configuration.
        ///   testArtifacts: {
        ///     inputArtifacts: {
        ///       configUrl: {
        ///         url: string, # Optional. File URL.
        ///         fileId: string, # Optional. File unique identifier.
        ///         filename: string, # Optional. Name of the file.
        ///         fileType: &quot;JMX_FILE&quot; | &quot;USER_PROPERTIES&quot; | &quot;ADDITIONAL_ARTIFACTS&quot;, # Optional. File type
        ///         expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///         validationStatus: &quot;NOT_VALIDATED&quot; | &quot;VALIDATION_SUCCESS&quot; | &quot;VALIDATION_FAILURE&quot; | &quot;VALIDATION_INITIATED&quot;, # Optional. Validation status of the file
        ///       }, # Optional. FileUrl Model.
        ///       testScriptUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///       userPropUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///       inputArtifactsZipFileurl: FileUrl20221101, # Optional. FileUrl Model.
        ///       additionalUrls: [FileUrl20221101], # Optional. Additional supported files for the test run
        ///     }, # Required. The input artifacts for the test.
        ///     outputArtifacts: {
        ///       resultUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///       logsUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///     }, # Optional. The output artifacts for the test run.
        ///   }, # Optional. test artifact 20221101
        ///   testResult: &quot;PASSED&quot; | &quot;NOT_APPLICABLE&quot; | &quot;FAILED&quot;, # Optional. Test result for pass/Fail criteria used during the test run.
        ///   testRunId: string, # Optional. Unique test run name as identifier
        ///   displayName: string, # Optional. Display name of a testRun.
        ///   testId: string, # Optional. Associated test Id.
        ///   description: string, # Optional. The test run description.
        ///   status: &quot;ACCEPTED&quot; | &quot;NOTSTARTED&quot; | &quot;PROVISIONING&quot; | &quot;PROVISIONED&quot; | &quot;CONFIGURING&quot; | &quot;CONFIGURED&quot; | &quot;EXECUTING&quot; | &quot;EXECUTED&quot; | &quot;DEPROVISIONING&quot; | &quot;DEPROVISIONED&quot; | &quot;DONE&quot; | &quot;CANCELLING&quot; | &quot;CANCELLED&quot; | &quot;FAILED&quot; | &quot;VALIDATION_SUCCESS&quot; | &quot;VALIDATION_FAILURE&quot;, # Optional. The test run status.
        ///   startDateTime: string (ISO 8601 Format), # Optional. The test run start DateTime(ISO 8601 literal format).
        ///   endDateTime: string (ISO 8601 Format), # Optional. The test run end DateTime(ISO 8601 literal format).
        ///   executedDateTime: string (ISO 8601 Format), # Optional. Test run initiated time.
        ///   vusers: number, # Optional. Number of virtual users, for which test has been run.
        ///   portalUrl: string, # Optional. Portal url.
        ///   duration: number, # Optional. Test run duration in milliseconds.
        ///   subnetId: string, # Optional. Subnet ID on which the load test instances should run.
        ///   resourceId: string, # Optional. Fully qualified resource Id e.g /subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}.
        ///   createdDateTime: string (ISO 8601 Format), # Optional. The created DateTime(ISO 8601 literal format) of the test model.
        ///   createdBy: string, # Optional. The user that created the test model.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified DateTime(ISO 8601 literal format) of the test model.
        ///   lastModifiedBy: string, # Optional. The user that last modified the test model.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> CreateOrUpdateAsync(string testRunId, RequestContent content, string oldTestRunId = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testRunId, nameof(testRunId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("TestRunClient.CreateOrUpdate");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateOrUpdateRequest(testRunId, content, oldTestRunId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create and start a new test run with the given name. </summary>
        /// <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="oldTestRunId"> Existing test run Id that should be rerun. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testRunId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testRunId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call CreateOrUpdate with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestRunClient("<https://my-service.azure.com>", credential);
        /// 
        /// var data = new {};
        /// 
        /// Response response = client.CreateOrUpdate("<testRunId>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.ToString());
        /// ]]></code>
        /// This sample shows how to call CreateOrUpdate with all parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestRunClient("<https://my-service.azure.com>", credential);
        /// 
        /// var data = new {
        ///     passFailCriteria = new {
        ///         passFailMetrics = new {
        ///             key = new {
        ///                 clientmetric = "response_time_ms",
        ///                 aggregate = "count",
        ///                 condition = "<condition>",
        ///                 requestName = "<requestName>",
        ///                 value = 123.45d,
        ///                 action = "stop",
        ///             },
        ///         },
        ///     },
        ///     secrets = new {
        ///         key = new {
        ///             value = "<value>",
        ///             type = "AKV_SECRET_URI",
        ///         },
        ///     },
        ///     certificate = new {
        ///         value = "<value>",
        ///         type = "AKV_CERT_URI",
        ///         name = "<name>",
        ///     },
        ///     environmentVariables = new {
        ///         key = "<String>",
        ///     },
        ///     loadTestConfig = new {
        ///         engineInstances = 1234,
        ///         splitAllCSVs = true,
        ///         quickStartTest = true,
        ///         optionalLoadTestConfig = new {
        ///             endpointUrl = "<endpointUrl>",
        ///             vusers = 1234,
        ///             rampUpTime = 1234,
        ///             duration = 1234,
        ///         },
        ///     },
        ///     displayName = "<displayName>",
        ///     testId = "<testId>",
        ///     description = "<description>",
        /// };
        /// 
        /// Response response = client.CreateOrUpdate("<testRunId>", RequestContent.Create(data), "<oldTestRunId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("clientmetric").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("aggregate").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("condition").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("requestName").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("action").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("actualValue").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("result").ToString());
        /// Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("certificate").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("certificate").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("certificate").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("environmentVariables").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errorDetails")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("transaction").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("sampleCount").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("errorCount").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("errorPct").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("meanResTime").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("medianResTime").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("maxResTime").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("minResTime").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("pct1ResTime").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("pct2ResTime").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("pct3ResTime").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("throughput").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("receivedKBytesPerSec").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("sentKBytesPerSec").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("engineInstances").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("splitAllCSVs").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("quickStartTest").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("endpointUrl").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("vusers").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("rampUpTime").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("duration").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("testResult").ToString());
        /// Console.WriteLine(result.GetProperty("testRunId").ToString());
        /// Console.WriteLine(result.GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("testId").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("startDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("endDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("executedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("vusers").ToString());
        /// Console.WriteLine(result.GetProperty("portalUrl").ToString());
        /// Console.WriteLine(result.GetProperty("duration").ToString());
        /// Console.WriteLine(result.GetProperty("subnetId").ToString());
        /// Console.WriteLine(result.GetProperty("resourceId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>TestRunModel20221101</c>:
        /// <code>{
        ///   passFailCriteria: {
        ///     passFailMetrics: Dictionary&lt;string, PassFailMetric20221101&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
        ///   }, # Optional. Pass fail criteria for a test.
        ///   secrets: Dictionary&lt;string, SecretMetadata20221101&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
        ///   certificate: {
        ///     value: string, # Optional. The value of the certificate for respective type
        ///     type: &quot;AKV_CERT_URI&quot;, # Optional. Type of certificate
        ///     name: string, # Optional. Name of the certificate.
        ///   }, # Optional.
        ///   environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
        ///   errorDetails: [
        ///     {
        ///       message: string, # Optional. Error details in case test run was not successfully run.
        ///     }
        ///   ], # Optional. Error details if there is any failure in load test run
        ///   testRunStatistics: Dictionary&lt;string, TestRunStatisticsModel&gt;, # Optional. Test run statistics.
        ///   loadTestConfig: {
        ///     engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
        ///     splitAllCSVs: boolean, # Optional. Whether all the input CSV files should be split evenly across all engines.
        ///     quickStartTest: boolean, # Optional. If true, optionalLoadTestConfig is required and JMX script for the load test is not required to upload.
        ///     optionalLoadTestConfig: {
        ///       endpointUrl: string, # Optional. Endpoint url
        ///       vusers: number, # Optional. No of virtual users 
        ///       rampUpTime: number, # Optional. ramp up time
        ///       duration: number, # Optional. duration
        ///     }, # Optional. Quick start load test config
        ///   }, # Optional. The load test configuration.
        ///   testArtifacts: {
        ///     inputArtifacts: {
        ///       configUrl: {
        ///         url: string, # Optional. File URL.
        ///         fileId: string, # Optional. File unique identifier.
        ///         filename: string, # Optional. Name of the file.
        ///         fileType: &quot;JMX_FILE&quot; | &quot;USER_PROPERTIES&quot; | &quot;ADDITIONAL_ARTIFACTS&quot;, # Optional. File type
        ///         expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///         validationStatus: &quot;NOT_VALIDATED&quot; | &quot;VALIDATION_SUCCESS&quot; | &quot;VALIDATION_FAILURE&quot; | &quot;VALIDATION_INITIATED&quot;, # Optional. Validation status of the file
        ///       }, # Optional. FileUrl Model.
        ///       testScriptUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///       userPropUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///       inputArtifactsZipFileurl: FileUrl20221101, # Optional. FileUrl Model.
        ///       additionalUrls: [FileUrl20221101], # Optional. Additional supported files for the test run
        ///     }, # Required. The input artifacts for the test.
        ///     outputArtifacts: {
        ///       resultUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///       logsUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///     }, # Optional. The output artifacts for the test run.
        ///   }, # Optional. test artifact 20221101
        ///   testResult: &quot;PASSED&quot; | &quot;NOT_APPLICABLE&quot; | &quot;FAILED&quot;, # Optional. Test result for pass/Fail criteria used during the test run.
        ///   testRunId: string, # Optional. Unique test run name as identifier
        ///   displayName: string, # Optional. Display name of a testRun.
        ///   testId: string, # Optional. Associated test Id.
        ///   description: string, # Optional. The test run description.
        ///   status: &quot;ACCEPTED&quot; | &quot;NOTSTARTED&quot; | &quot;PROVISIONING&quot; | &quot;PROVISIONED&quot; | &quot;CONFIGURING&quot; | &quot;CONFIGURED&quot; | &quot;EXECUTING&quot; | &quot;EXECUTED&quot; | &quot;DEPROVISIONING&quot; | &quot;DEPROVISIONED&quot; | &quot;DONE&quot; | &quot;CANCELLING&quot; | &quot;CANCELLED&quot; | &quot;FAILED&quot; | &quot;VALIDATION_SUCCESS&quot; | &quot;VALIDATION_FAILURE&quot;, # Optional. The test run status.
        ///   startDateTime: string (ISO 8601 Format), # Optional. The test run start DateTime(ISO 8601 literal format).
        ///   endDateTime: string (ISO 8601 Format), # Optional. The test run end DateTime(ISO 8601 literal format).
        ///   executedDateTime: string (ISO 8601 Format), # Optional. Test run initiated time.
        ///   vusers: number, # Optional. Number of virtual users, for which test has been run.
        ///   portalUrl: string, # Optional. Portal url.
        ///   duration: number, # Optional. Test run duration in milliseconds.
        ///   subnetId: string, # Optional. Subnet ID on which the load test instances should run.
        ///   resourceId: string, # Optional. Fully qualified resource Id e.g /subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}.
        ///   createdDateTime: string (ISO 8601 Format), # Optional. The created DateTime(ISO 8601 literal format) of the test model.
        ///   createdBy: string, # Optional. The user that created the test model.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified DateTime(ISO 8601 literal format) of the test model.
        ///   lastModifiedBy: string, # Optional. The user that last modified the test model.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TestRunModel20221101</c>:
        /// <code>{
        ///   passFailCriteria: {
        ///     passFailMetrics: Dictionary&lt;string, PassFailMetric20221101&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
        ///   }, # Optional. Pass fail criteria for a test.
        ///   secrets: Dictionary&lt;string, SecretMetadata20221101&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
        ///   certificate: {
        ///     value: string, # Optional. The value of the certificate for respective type
        ///     type: &quot;AKV_CERT_URI&quot;, # Optional. Type of certificate
        ///     name: string, # Optional. Name of the certificate.
        ///   }, # Optional.
        ///   environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
        ///   errorDetails: [
        ///     {
        ///       message: string, # Optional. Error details in case test run was not successfully run.
        ///     }
        ///   ], # Optional. Error details if there is any failure in load test run
        ///   testRunStatistics: Dictionary&lt;string, TestRunStatisticsModel&gt;, # Optional. Test run statistics.
        ///   loadTestConfig: {
        ///     engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
        ///     splitAllCSVs: boolean, # Optional. Whether all the input CSV files should be split evenly across all engines.
        ///     quickStartTest: boolean, # Optional. If true, optionalLoadTestConfig is required and JMX script for the load test is not required to upload.
        ///     optionalLoadTestConfig: {
        ///       endpointUrl: string, # Optional. Endpoint url
        ///       vusers: number, # Optional. No of virtual users 
        ///       rampUpTime: number, # Optional. ramp up time
        ///       duration: number, # Optional. duration
        ///     }, # Optional. Quick start load test config
        ///   }, # Optional. The load test configuration.
        ///   testArtifacts: {
        ///     inputArtifacts: {
        ///       configUrl: {
        ///         url: string, # Optional. File URL.
        ///         fileId: string, # Optional. File unique identifier.
        ///         filename: string, # Optional. Name of the file.
        ///         fileType: &quot;JMX_FILE&quot; | &quot;USER_PROPERTIES&quot; | &quot;ADDITIONAL_ARTIFACTS&quot;, # Optional. File type
        ///         expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///         validationStatus: &quot;NOT_VALIDATED&quot; | &quot;VALIDATION_SUCCESS&quot; | &quot;VALIDATION_FAILURE&quot; | &quot;VALIDATION_INITIATED&quot;, # Optional. Validation status of the file
        ///       }, # Optional. FileUrl Model.
        ///       testScriptUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///       userPropUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///       inputArtifactsZipFileurl: FileUrl20221101, # Optional. FileUrl Model.
        ///       additionalUrls: [FileUrl20221101], # Optional. Additional supported files for the test run
        ///     }, # Required. The input artifacts for the test.
        ///     outputArtifacts: {
        ///       resultUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///       logsUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///     }, # Optional. The output artifacts for the test run.
        ///   }, # Optional. test artifact 20221101
        ///   testResult: &quot;PASSED&quot; | &quot;NOT_APPLICABLE&quot; | &quot;FAILED&quot;, # Optional. Test result for pass/Fail criteria used during the test run.
        ///   testRunId: string, # Optional. Unique test run name as identifier
        ///   displayName: string, # Optional. Display name of a testRun.
        ///   testId: string, # Optional. Associated test Id.
        ///   description: string, # Optional. The test run description.
        ///   status: &quot;ACCEPTED&quot; | &quot;NOTSTARTED&quot; | &quot;PROVISIONING&quot; | &quot;PROVISIONED&quot; | &quot;CONFIGURING&quot; | &quot;CONFIGURED&quot; | &quot;EXECUTING&quot; | &quot;EXECUTED&quot; | &quot;DEPROVISIONING&quot; | &quot;DEPROVISIONED&quot; | &quot;DONE&quot; | &quot;CANCELLING&quot; | &quot;CANCELLED&quot; | &quot;FAILED&quot; | &quot;VALIDATION_SUCCESS&quot; | &quot;VALIDATION_FAILURE&quot;, # Optional. The test run status.
        ///   startDateTime: string (ISO 8601 Format), # Optional. The test run start DateTime(ISO 8601 literal format).
        ///   endDateTime: string (ISO 8601 Format), # Optional. The test run end DateTime(ISO 8601 literal format).
        ///   executedDateTime: string (ISO 8601 Format), # Optional. Test run initiated time.
        ///   vusers: number, # Optional. Number of virtual users, for which test has been run.
        ///   portalUrl: string, # Optional. Portal url.
        ///   duration: number, # Optional. Test run duration in milliseconds.
        ///   subnetId: string, # Optional. Subnet ID on which the load test instances should run.
        ///   resourceId: string, # Optional. Fully qualified resource Id e.g /subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}.
        ///   createdDateTime: string (ISO 8601 Format), # Optional. The created DateTime(ISO 8601 literal format) of the test model.
        ///   createdBy: string, # Optional. The user that created the test model.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified DateTime(ISO 8601 literal format) of the test model.
        ///   lastModifiedBy: string, # Optional. The user that last modified the test model.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response CreateOrUpdate(string testRunId, RequestContent content, string oldTestRunId = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testRunId, nameof(testRunId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("TestRunClient.CreateOrUpdate");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateOrUpdateRequest(testRunId, content, oldTestRunId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get test run details by name. </summary>
        /// <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testRunId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testRunId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTestRunAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestRunClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = await client.GetTestRunAsync("<testRunId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("clientmetric").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("aggregate").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("condition").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("requestName").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("action").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("actualValue").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("result").ToString());
        /// Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("certificate").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("certificate").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("certificate").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("environmentVariables").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errorDetails")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("transaction").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("sampleCount").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("errorCount").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("errorPct").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("meanResTime").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("medianResTime").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("maxResTime").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("minResTime").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("pct1ResTime").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("pct2ResTime").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("pct3ResTime").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("throughput").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("receivedKBytesPerSec").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("sentKBytesPerSec").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("engineInstances").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("splitAllCSVs").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("quickStartTest").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("endpointUrl").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("vusers").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("rampUpTime").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("duration").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("testResult").ToString());
        /// Console.WriteLine(result.GetProperty("testRunId").ToString());
        /// Console.WriteLine(result.GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("testId").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("startDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("endDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("executedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("vusers").ToString());
        /// Console.WriteLine(result.GetProperty("portalUrl").ToString());
        /// Console.WriteLine(result.GetProperty("duration").ToString());
        /// Console.WriteLine(result.GetProperty("subnetId").ToString());
        /// Console.WriteLine(result.GetProperty("resourceId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TestRunModel20221101</c>:
        /// <code>{
        ///   passFailCriteria: {
        ///     passFailMetrics: Dictionary&lt;string, PassFailMetric20221101&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
        ///   }, # Optional. Pass fail criteria for a test.
        ///   secrets: Dictionary&lt;string, SecretMetadata20221101&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
        ///   certificate: {
        ///     value: string, # Optional. The value of the certificate for respective type
        ///     type: &quot;AKV_CERT_URI&quot;, # Optional. Type of certificate
        ///     name: string, # Optional. Name of the certificate.
        ///   }, # Optional.
        ///   environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
        ///   errorDetails: [
        ///     {
        ///       message: string, # Optional. Error details in case test run was not successfully run.
        ///     }
        ///   ], # Optional. Error details if there is any failure in load test run
        ///   testRunStatistics: Dictionary&lt;string, TestRunStatisticsModel&gt;, # Optional. Test run statistics.
        ///   loadTestConfig: {
        ///     engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
        ///     splitAllCSVs: boolean, # Optional. Whether all the input CSV files should be split evenly across all engines.
        ///     quickStartTest: boolean, # Optional. If true, optionalLoadTestConfig is required and JMX script for the load test is not required to upload.
        ///     optionalLoadTestConfig: {
        ///       endpointUrl: string, # Optional. Endpoint url
        ///       vusers: number, # Optional. No of virtual users 
        ///       rampUpTime: number, # Optional. ramp up time
        ///       duration: number, # Optional. duration
        ///     }, # Optional. Quick start load test config
        ///   }, # Optional. The load test configuration.
        ///   testArtifacts: {
        ///     inputArtifacts: {
        ///       configUrl: {
        ///         url: string, # Optional. File URL.
        ///         fileId: string, # Optional. File unique identifier.
        ///         filename: string, # Optional. Name of the file.
        ///         fileType: &quot;JMX_FILE&quot; | &quot;USER_PROPERTIES&quot; | &quot;ADDITIONAL_ARTIFACTS&quot;, # Optional. File type
        ///         expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///         validationStatus: &quot;NOT_VALIDATED&quot; | &quot;VALIDATION_SUCCESS&quot; | &quot;VALIDATION_FAILURE&quot; | &quot;VALIDATION_INITIATED&quot;, # Optional. Validation status of the file
        ///       }, # Optional. FileUrl Model.
        ///       testScriptUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///       userPropUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///       inputArtifactsZipFileurl: FileUrl20221101, # Optional. FileUrl Model.
        ///       additionalUrls: [FileUrl20221101], # Optional. Additional supported files for the test run
        ///     }, # Required. The input artifacts for the test.
        ///     outputArtifacts: {
        ///       resultUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///       logsUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///     }, # Optional. The output artifacts for the test run.
        ///   }, # Optional. test artifact 20221101
        ///   testResult: &quot;PASSED&quot; | &quot;NOT_APPLICABLE&quot; | &quot;FAILED&quot;, # Optional. Test result for pass/Fail criteria used during the test run.
        ///   testRunId: string, # Optional. Unique test run name as identifier
        ///   displayName: string, # Optional. Display name of a testRun.
        ///   testId: string, # Optional. Associated test Id.
        ///   description: string, # Optional. The test run description.
        ///   status: &quot;ACCEPTED&quot; | &quot;NOTSTARTED&quot; | &quot;PROVISIONING&quot; | &quot;PROVISIONED&quot; | &quot;CONFIGURING&quot; | &quot;CONFIGURED&quot; | &quot;EXECUTING&quot; | &quot;EXECUTED&quot; | &quot;DEPROVISIONING&quot; | &quot;DEPROVISIONED&quot; | &quot;DONE&quot; | &quot;CANCELLING&quot; | &quot;CANCELLED&quot; | &quot;FAILED&quot; | &quot;VALIDATION_SUCCESS&quot; | &quot;VALIDATION_FAILURE&quot;, # Optional. The test run status.
        ///   startDateTime: string (ISO 8601 Format), # Optional. The test run start DateTime(ISO 8601 literal format).
        ///   endDateTime: string (ISO 8601 Format), # Optional. The test run end DateTime(ISO 8601 literal format).
        ///   executedDateTime: string (ISO 8601 Format), # Optional. Test run initiated time.
        ///   vusers: number, # Optional. Number of virtual users, for which test has been run.
        ///   portalUrl: string, # Optional. Portal url.
        ///   duration: number, # Optional. Test run duration in milliseconds.
        ///   subnetId: string, # Optional. Subnet ID on which the load test instances should run.
        ///   resourceId: string, # Optional. Fully qualified resource Id e.g /subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}.
        ///   createdDateTime: string (ISO 8601 Format), # Optional. The created DateTime(ISO 8601 literal format) of the test model.
        ///   createdBy: string, # Optional. The user that created the test model.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified DateTime(ISO 8601 literal format) of the test model.
        ///   lastModifiedBy: string, # Optional. The user that last modified the test model.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetTestRunAsync(string testRunId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testRunId, nameof(testRunId));

            using var scope = ClientDiagnostics.CreateScope("TestRunClient.GetTestRun");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTestRunRequest(testRunId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get test run details by name. </summary>
        /// <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testRunId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testRunId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTestRun with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestRunClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = client.GetTestRun("<testRunId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("clientmetric").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("aggregate").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("condition").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("requestName").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("action").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("actualValue").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("result").ToString());
        /// Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("certificate").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("certificate").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("certificate").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("environmentVariables").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errorDetails")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("transaction").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("sampleCount").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("errorCount").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("errorPct").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("meanResTime").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("medianResTime").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("maxResTime").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("minResTime").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("pct1ResTime").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("pct2ResTime").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("pct3ResTime").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("throughput").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("receivedKBytesPerSec").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("sentKBytesPerSec").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("engineInstances").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("splitAllCSVs").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("quickStartTest").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("endpointUrl").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("vusers").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("rampUpTime").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("duration").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("testResult").ToString());
        /// Console.WriteLine(result.GetProperty("testRunId").ToString());
        /// Console.WriteLine(result.GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("testId").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("startDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("endDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("executedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("vusers").ToString());
        /// Console.WriteLine(result.GetProperty("portalUrl").ToString());
        /// Console.WriteLine(result.GetProperty("duration").ToString());
        /// Console.WriteLine(result.GetProperty("subnetId").ToString());
        /// Console.WriteLine(result.GetProperty("resourceId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TestRunModel20221101</c>:
        /// <code>{
        ///   passFailCriteria: {
        ///     passFailMetrics: Dictionary&lt;string, PassFailMetric20221101&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
        ///   }, # Optional. Pass fail criteria for a test.
        ///   secrets: Dictionary&lt;string, SecretMetadata20221101&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
        ///   certificate: {
        ///     value: string, # Optional. The value of the certificate for respective type
        ///     type: &quot;AKV_CERT_URI&quot;, # Optional. Type of certificate
        ///     name: string, # Optional. Name of the certificate.
        ///   }, # Optional.
        ///   environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
        ///   errorDetails: [
        ///     {
        ///       message: string, # Optional. Error details in case test run was not successfully run.
        ///     }
        ///   ], # Optional. Error details if there is any failure in load test run
        ///   testRunStatistics: Dictionary&lt;string, TestRunStatisticsModel&gt;, # Optional. Test run statistics.
        ///   loadTestConfig: {
        ///     engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
        ///     splitAllCSVs: boolean, # Optional. Whether all the input CSV files should be split evenly across all engines.
        ///     quickStartTest: boolean, # Optional. If true, optionalLoadTestConfig is required and JMX script for the load test is not required to upload.
        ///     optionalLoadTestConfig: {
        ///       endpointUrl: string, # Optional. Endpoint url
        ///       vusers: number, # Optional. No of virtual users 
        ///       rampUpTime: number, # Optional. ramp up time
        ///       duration: number, # Optional. duration
        ///     }, # Optional. Quick start load test config
        ///   }, # Optional. The load test configuration.
        ///   testArtifacts: {
        ///     inputArtifacts: {
        ///       configUrl: {
        ///         url: string, # Optional. File URL.
        ///         fileId: string, # Optional. File unique identifier.
        ///         filename: string, # Optional. Name of the file.
        ///         fileType: &quot;JMX_FILE&quot; | &quot;USER_PROPERTIES&quot; | &quot;ADDITIONAL_ARTIFACTS&quot;, # Optional. File type
        ///         expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///         validationStatus: &quot;NOT_VALIDATED&quot; | &quot;VALIDATION_SUCCESS&quot; | &quot;VALIDATION_FAILURE&quot; | &quot;VALIDATION_INITIATED&quot;, # Optional. Validation status of the file
        ///       }, # Optional. FileUrl Model.
        ///       testScriptUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///       userPropUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///       inputArtifactsZipFileurl: FileUrl20221101, # Optional. FileUrl Model.
        ///       additionalUrls: [FileUrl20221101], # Optional. Additional supported files for the test run
        ///     }, # Required. The input artifacts for the test.
        ///     outputArtifacts: {
        ///       resultUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///       logsUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///     }, # Optional. The output artifacts for the test run.
        ///   }, # Optional. test artifact 20221101
        ///   testResult: &quot;PASSED&quot; | &quot;NOT_APPLICABLE&quot; | &quot;FAILED&quot;, # Optional. Test result for pass/Fail criteria used during the test run.
        ///   testRunId: string, # Optional. Unique test run name as identifier
        ///   displayName: string, # Optional. Display name of a testRun.
        ///   testId: string, # Optional. Associated test Id.
        ///   description: string, # Optional. The test run description.
        ///   status: &quot;ACCEPTED&quot; | &quot;NOTSTARTED&quot; | &quot;PROVISIONING&quot; | &quot;PROVISIONED&quot; | &quot;CONFIGURING&quot; | &quot;CONFIGURED&quot; | &quot;EXECUTING&quot; | &quot;EXECUTED&quot; | &quot;DEPROVISIONING&quot; | &quot;DEPROVISIONED&quot; | &quot;DONE&quot; | &quot;CANCELLING&quot; | &quot;CANCELLED&quot; | &quot;FAILED&quot; | &quot;VALIDATION_SUCCESS&quot; | &quot;VALIDATION_FAILURE&quot;, # Optional. The test run status.
        ///   startDateTime: string (ISO 8601 Format), # Optional. The test run start DateTime(ISO 8601 literal format).
        ///   endDateTime: string (ISO 8601 Format), # Optional. The test run end DateTime(ISO 8601 literal format).
        ///   executedDateTime: string (ISO 8601 Format), # Optional. Test run initiated time.
        ///   vusers: number, # Optional. Number of virtual users, for which test has been run.
        ///   portalUrl: string, # Optional. Portal url.
        ///   duration: number, # Optional. Test run duration in milliseconds.
        ///   subnetId: string, # Optional. Subnet ID on which the load test instances should run.
        ///   resourceId: string, # Optional. Fully qualified resource Id e.g /subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}.
        ///   createdDateTime: string (ISO 8601 Format), # Optional. The created DateTime(ISO 8601 literal format) of the test model.
        ///   createdBy: string, # Optional. The user that created the test model.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified DateTime(ISO 8601 literal format) of the test model.
        ///   lastModifiedBy: string, # Optional. The user that last modified the test model.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetTestRun(string testRunId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testRunId, nameof(testRunId));

            using var scope = ClientDiagnostics.CreateScope("TestRunClient.GetTestRun");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTestRunRequest(testRunId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get test run file by file name. </summary>
        /// <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        /// <param name="fileId"> Unique name for test run file, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testRunId"/> or <paramref name="fileId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testRunId"/> or <paramref name="fileId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetFileAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestRunClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = await client.GetFileAsync("<testRunId>", "<fileId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("validationStatus").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>FileUrl20221101</c>:
        /// <code>{
        ///   url: string, # Optional. File URL.
        ///   fileId: string, # Optional. File unique identifier.
        ///   filename: string, # Optional. Name of the file.
        ///   fileType: &quot;JMX_FILE&quot; | &quot;USER_PROPERTIES&quot; | &quot;ADDITIONAL_ARTIFACTS&quot;, # Optional. File type
        ///   expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///   validationStatus: &quot;NOT_VALIDATED&quot; | &quot;VALIDATION_SUCCESS&quot; | &quot;VALIDATION_FAILURE&quot; | &quot;VALIDATION_INITIATED&quot;, # Optional. Validation status of the file
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetFileAsync(string testRunId, string fileId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testRunId, nameof(testRunId));
            Argument.AssertNotNullOrEmpty(fileId, nameof(fileId));

            using var scope = ClientDiagnostics.CreateScope("TestRunClient.GetFile");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetFileRequest(testRunId, fileId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get test run file by file name. </summary>
        /// <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        /// <param name="fileId"> Unique name for test run file, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testRunId"/> or <paramref name="fileId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testRunId"/> or <paramref name="fileId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetFile with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestRunClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = client.GetFile("<testRunId>", "<fileId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("validationStatus").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>FileUrl20221101</c>:
        /// <code>{
        ///   url: string, # Optional. File URL.
        ///   fileId: string, # Optional. File unique identifier.
        ///   filename: string, # Optional. Name of the file.
        ///   fileType: &quot;JMX_FILE&quot; | &quot;USER_PROPERTIES&quot; | &quot;ADDITIONAL_ARTIFACTS&quot;, # Optional. File type
        ///   expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///   validationStatus: &quot;NOT_VALIDATED&quot; | &quot;VALIDATION_SUCCESS&quot; | &quot;VALIDATION_FAILURE&quot; | &quot;VALIDATION_INITIATED&quot;, # Optional. Validation status of the file
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetFile(string testRunId, string fileId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testRunId, nameof(testRunId));
            Argument.AssertNotNullOrEmpty(fileId, nameof(fileId));

            using var scope = ClientDiagnostics.CreateScope("TestRunClient.GetFile");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetFileRequest(testRunId, fileId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Stop test run by name. </summary>
        /// <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testRunId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testRunId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call StopAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestRunClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = await client.StopAsync("<testRunId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("clientmetric").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("aggregate").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("condition").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("requestName").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("action").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("actualValue").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("result").ToString());
        /// Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("certificate").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("certificate").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("certificate").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("environmentVariables").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errorDetails")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("transaction").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("sampleCount").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("errorCount").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("errorPct").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("meanResTime").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("medianResTime").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("maxResTime").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("minResTime").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("pct1ResTime").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("pct2ResTime").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("pct3ResTime").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("throughput").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("receivedKBytesPerSec").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("sentKBytesPerSec").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("engineInstances").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("splitAllCSVs").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("quickStartTest").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("endpointUrl").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("vusers").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("rampUpTime").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("duration").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("testResult").ToString());
        /// Console.WriteLine(result.GetProperty("testRunId").ToString());
        /// Console.WriteLine(result.GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("testId").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("startDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("endDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("executedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("vusers").ToString());
        /// Console.WriteLine(result.GetProperty("portalUrl").ToString());
        /// Console.WriteLine(result.GetProperty("duration").ToString());
        /// Console.WriteLine(result.GetProperty("subnetId").ToString());
        /// Console.WriteLine(result.GetProperty("resourceId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TestRunModel20221101</c>:
        /// <code>{
        ///   passFailCriteria: {
        ///     passFailMetrics: Dictionary&lt;string, PassFailMetric20221101&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
        ///   }, # Optional. Pass fail criteria for a test.
        ///   secrets: Dictionary&lt;string, SecretMetadata20221101&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
        ///   certificate: {
        ///     value: string, # Optional. The value of the certificate for respective type
        ///     type: &quot;AKV_CERT_URI&quot;, # Optional. Type of certificate
        ///     name: string, # Optional. Name of the certificate.
        ///   }, # Optional.
        ///   environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
        ///   errorDetails: [
        ///     {
        ///       message: string, # Optional. Error details in case test run was not successfully run.
        ///     }
        ///   ], # Optional. Error details if there is any failure in load test run
        ///   testRunStatistics: Dictionary&lt;string, TestRunStatisticsModel&gt;, # Optional. Test run statistics.
        ///   loadTestConfig: {
        ///     engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
        ///     splitAllCSVs: boolean, # Optional. Whether all the input CSV files should be split evenly across all engines.
        ///     quickStartTest: boolean, # Optional. If true, optionalLoadTestConfig is required and JMX script for the load test is not required to upload.
        ///     optionalLoadTestConfig: {
        ///       endpointUrl: string, # Optional. Endpoint url
        ///       vusers: number, # Optional. No of virtual users 
        ///       rampUpTime: number, # Optional. ramp up time
        ///       duration: number, # Optional. duration
        ///     }, # Optional. Quick start load test config
        ///   }, # Optional. The load test configuration.
        ///   testArtifacts: {
        ///     inputArtifacts: {
        ///       configUrl: {
        ///         url: string, # Optional. File URL.
        ///         fileId: string, # Optional. File unique identifier.
        ///         filename: string, # Optional. Name of the file.
        ///         fileType: &quot;JMX_FILE&quot; | &quot;USER_PROPERTIES&quot; | &quot;ADDITIONAL_ARTIFACTS&quot;, # Optional. File type
        ///         expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///         validationStatus: &quot;NOT_VALIDATED&quot; | &quot;VALIDATION_SUCCESS&quot; | &quot;VALIDATION_FAILURE&quot; | &quot;VALIDATION_INITIATED&quot;, # Optional. Validation status of the file
        ///       }, # Optional. FileUrl Model.
        ///       testScriptUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///       userPropUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///       inputArtifactsZipFileurl: FileUrl20221101, # Optional. FileUrl Model.
        ///       additionalUrls: [FileUrl20221101], # Optional. Additional supported files for the test run
        ///     }, # Required. The input artifacts for the test.
        ///     outputArtifacts: {
        ///       resultUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///       logsUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///     }, # Optional. The output artifacts for the test run.
        ///   }, # Optional. test artifact 20221101
        ///   testResult: &quot;PASSED&quot; | &quot;NOT_APPLICABLE&quot; | &quot;FAILED&quot;, # Optional. Test result for pass/Fail criteria used during the test run.
        ///   testRunId: string, # Optional. Unique test run name as identifier
        ///   displayName: string, # Optional. Display name of a testRun.
        ///   testId: string, # Optional. Associated test Id.
        ///   description: string, # Optional. The test run description.
        ///   status: &quot;ACCEPTED&quot; | &quot;NOTSTARTED&quot; | &quot;PROVISIONING&quot; | &quot;PROVISIONED&quot; | &quot;CONFIGURING&quot; | &quot;CONFIGURED&quot; | &quot;EXECUTING&quot; | &quot;EXECUTED&quot; | &quot;DEPROVISIONING&quot; | &quot;DEPROVISIONED&quot; | &quot;DONE&quot; | &quot;CANCELLING&quot; | &quot;CANCELLED&quot; | &quot;FAILED&quot; | &quot;VALIDATION_SUCCESS&quot; | &quot;VALIDATION_FAILURE&quot;, # Optional. The test run status.
        ///   startDateTime: string (ISO 8601 Format), # Optional. The test run start DateTime(ISO 8601 literal format).
        ///   endDateTime: string (ISO 8601 Format), # Optional. The test run end DateTime(ISO 8601 literal format).
        ///   executedDateTime: string (ISO 8601 Format), # Optional. Test run initiated time.
        ///   vusers: number, # Optional. Number of virtual users, for which test has been run.
        ///   portalUrl: string, # Optional. Portal url.
        ///   duration: number, # Optional. Test run duration in milliseconds.
        ///   subnetId: string, # Optional. Subnet ID on which the load test instances should run.
        ///   resourceId: string, # Optional. Fully qualified resource Id e.g /subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}.
        ///   createdDateTime: string (ISO 8601 Format), # Optional. The created DateTime(ISO 8601 literal format) of the test model.
        ///   createdBy: string, # Optional. The user that created the test model.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified DateTime(ISO 8601 literal format) of the test model.
        ///   lastModifiedBy: string, # Optional. The user that last modified the test model.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> StopAsync(string testRunId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testRunId, nameof(testRunId));

            using var scope = ClientDiagnostics.CreateScope("TestRunClient.Stop");
            scope.Start();
            try
            {
                using HttpMessage message = CreateStopRequest(testRunId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Stop test run by name. </summary>
        /// <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testRunId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testRunId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call Stop with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestRunClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = client.Stop("<testRunId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("clientmetric").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("aggregate").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("condition").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("requestName").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("action").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("actualValue").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("result").ToString());
        /// Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("certificate").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("certificate").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("certificate").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("environmentVariables").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errorDetails")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("transaction").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("sampleCount").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("errorCount").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("errorPct").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("meanResTime").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("medianResTime").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("maxResTime").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("minResTime").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("pct1ResTime").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("pct2ResTime").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("pct3ResTime").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("throughput").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("receivedKBytesPerSec").ToString());
        /// Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("sentKBytesPerSec").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("engineInstances").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("splitAllCSVs").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("quickStartTest").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("endpointUrl").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("vusers").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("rampUpTime").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("duration").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("testResult").ToString());
        /// Console.WriteLine(result.GetProperty("testRunId").ToString());
        /// Console.WriteLine(result.GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("testId").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("startDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("endDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("executedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("vusers").ToString());
        /// Console.WriteLine(result.GetProperty("portalUrl").ToString());
        /// Console.WriteLine(result.GetProperty("duration").ToString());
        /// Console.WriteLine(result.GetProperty("subnetId").ToString());
        /// Console.WriteLine(result.GetProperty("resourceId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TestRunModel20221101</c>:
        /// <code>{
        ///   passFailCriteria: {
        ///     passFailMetrics: Dictionary&lt;string, PassFailMetric20221101&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
        ///   }, # Optional. Pass fail criteria for a test.
        ///   secrets: Dictionary&lt;string, SecretMetadata20221101&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
        ///   certificate: {
        ///     value: string, # Optional. The value of the certificate for respective type
        ///     type: &quot;AKV_CERT_URI&quot;, # Optional. Type of certificate
        ///     name: string, # Optional. Name of the certificate.
        ///   }, # Optional.
        ///   environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
        ///   errorDetails: [
        ///     {
        ///       message: string, # Optional. Error details in case test run was not successfully run.
        ///     }
        ///   ], # Optional. Error details if there is any failure in load test run
        ///   testRunStatistics: Dictionary&lt;string, TestRunStatisticsModel&gt;, # Optional. Test run statistics.
        ///   loadTestConfig: {
        ///     engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
        ///     splitAllCSVs: boolean, # Optional. Whether all the input CSV files should be split evenly across all engines.
        ///     quickStartTest: boolean, # Optional. If true, optionalLoadTestConfig is required and JMX script for the load test is not required to upload.
        ///     optionalLoadTestConfig: {
        ///       endpointUrl: string, # Optional. Endpoint url
        ///       vusers: number, # Optional. No of virtual users 
        ///       rampUpTime: number, # Optional. ramp up time
        ///       duration: number, # Optional. duration
        ///     }, # Optional. Quick start load test config
        ///   }, # Optional. The load test configuration.
        ///   testArtifacts: {
        ///     inputArtifacts: {
        ///       configUrl: {
        ///         url: string, # Optional. File URL.
        ///         fileId: string, # Optional. File unique identifier.
        ///         filename: string, # Optional. Name of the file.
        ///         fileType: &quot;JMX_FILE&quot; | &quot;USER_PROPERTIES&quot; | &quot;ADDITIONAL_ARTIFACTS&quot;, # Optional. File type
        ///         expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///         validationStatus: &quot;NOT_VALIDATED&quot; | &quot;VALIDATION_SUCCESS&quot; | &quot;VALIDATION_FAILURE&quot; | &quot;VALIDATION_INITIATED&quot;, # Optional. Validation status of the file
        ///       }, # Optional. FileUrl Model.
        ///       testScriptUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///       userPropUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///       inputArtifactsZipFileurl: FileUrl20221101, # Optional. FileUrl Model.
        ///       additionalUrls: [FileUrl20221101], # Optional. Additional supported files for the test run
        ///     }, # Required. The input artifacts for the test.
        ///     outputArtifacts: {
        ///       resultUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///       logsUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///     }, # Optional. The output artifacts for the test run.
        ///   }, # Optional. test artifact 20221101
        ///   testResult: &quot;PASSED&quot; | &quot;NOT_APPLICABLE&quot; | &quot;FAILED&quot;, # Optional. Test result for pass/Fail criteria used during the test run.
        ///   testRunId: string, # Optional. Unique test run name as identifier
        ///   displayName: string, # Optional. Display name of a testRun.
        ///   testId: string, # Optional. Associated test Id.
        ///   description: string, # Optional. The test run description.
        ///   status: &quot;ACCEPTED&quot; | &quot;NOTSTARTED&quot; | &quot;PROVISIONING&quot; | &quot;PROVISIONED&quot; | &quot;CONFIGURING&quot; | &quot;CONFIGURED&quot; | &quot;EXECUTING&quot; | &quot;EXECUTED&quot; | &quot;DEPROVISIONING&quot; | &quot;DEPROVISIONED&quot; | &quot;DONE&quot; | &quot;CANCELLING&quot; | &quot;CANCELLED&quot; | &quot;FAILED&quot; | &quot;VALIDATION_SUCCESS&quot; | &quot;VALIDATION_FAILURE&quot;, # Optional. The test run status.
        ///   startDateTime: string (ISO 8601 Format), # Optional. The test run start DateTime(ISO 8601 literal format).
        ///   endDateTime: string (ISO 8601 Format), # Optional. The test run end DateTime(ISO 8601 literal format).
        ///   executedDateTime: string (ISO 8601 Format), # Optional. Test run initiated time.
        ///   vusers: number, # Optional. Number of virtual users, for which test has been run.
        ///   portalUrl: string, # Optional. Portal url.
        ///   duration: number, # Optional. Test run duration in milliseconds.
        ///   subnetId: string, # Optional. Subnet ID on which the load test instances should run.
        ///   resourceId: string, # Optional. Fully qualified resource Id e.g /subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}.
        ///   createdDateTime: string (ISO 8601 Format), # Optional. The created DateTime(ISO 8601 literal format) of the test model.
        ///   createdBy: string, # Optional. The user that created the test model.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified DateTime(ISO 8601 literal format) of the test model.
        ///   lastModifiedBy: string, # Optional. The user that last modified the test model.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response Stop(string testRunId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testRunId, nameof(testRunId));

            using var scope = ClientDiagnostics.CreateScope("TestRunClient.Stop");
            scope.Start();
            try
            {
                using HttpMessage message = CreateStopRequest(testRunId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Lists the metric namespaces for a load test run. </summary>
        /// <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testRunId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testRunId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call MetricNamespacesAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestRunClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = await client.MetricNamespacesAsync("<testRunId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("metricNamespaceName").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>MetricNamespaceCollection</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       name: string, # Optional. The escaped name of the namespace.
        ///       metricNamespaceName: string, # Optional. The fully qualified metric namespace name.
        ///     }
        ///   ], # Optional. The values for the metric namespaces.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> MetricNamespacesAsync(string testRunId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testRunId, nameof(testRunId));

            using var scope = ClientDiagnostics.CreateScope("TestRunClient.MetricNamespaces");
            scope.Start();
            try
            {
                using HttpMessage message = CreateMetricNamespacesRequest(testRunId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Lists the metric namespaces for a load test run. </summary>
        /// <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testRunId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testRunId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call MetricNamespaces with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestRunClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = client.MetricNamespaces("<testRunId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("metricNamespaceName").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>MetricNamespaceCollection</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       name: string, # Optional. The escaped name of the namespace.
        ///       metricNamespaceName: string, # Optional. The fully qualified metric namespace name.
        ///     }
        ///   ], # Optional. The values for the metric namespaces.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response MetricNamespaces(string testRunId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testRunId, nameof(testRunId));

            using var scope = ClientDiagnostics.CreateScope("TestRunClient.MetricNamespaces");
            scope.Start();
            try
            {
                using HttpMessage message = CreateMetricNamespacesRequest(testRunId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Lists the metric definitions for a load test run. </summary>
        /// <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        /// <param name="metricnamespace"> Metric namespace to query metric definitions for. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testRunId"/> or <paramref name="metricnamespace"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testRunId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call MetricDefinitionsAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestRunClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = await client.MetricDefinitionsAsync("<testRunId>", "<metricnamespace>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("dimensions")[0].GetProperty("localizedValue").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("dimensions")[0].GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("displayDescription").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("name").GetProperty("localizedValue").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("name").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("namespace").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("primaryAggregationType").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("supportedAggregationTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("unit").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("metricAvailabilities")[0].GetProperty("timeGrain").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>MetricDefinitionCollection</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       dimensions: [
        ///         {
        ///           localizedValue: string, # Optional. The locale specific value.
        ///           value: string, # Optional. The invariant value.
        ///         }
        ///       ], # Optional. The name and the display name of the dimension, i.e. it is a localizable string.
        ///       displayDescription: string, # Optional. Detailed description of this metric.
        ///       name: LocalizableString, # Optional. The localizable string class.
        ///       namespace: string, # Optional. The namespace the metric belongs to.
        ///       primaryAggregationType: &quot;Average&quot; | &quot;Count&quot; | &quot;Minimum&quot; | &quot;Maximum&quot; | &quot;None&quot; | &quot;Total&quot; | &quot;Percentile90&quot; | &quot;Percentile95&quot; | &quot;Percentile99&quot;, # Optional. the primary aggregation type value defining how to use the values for display.
        ///       supportedAggregationTypes: [string], # Optional. the collection of what aggregation types are supported.
        ///       unit: &quot;NotSpecified&quot; | &quot;Percent&quot; | &quot;Count&quot; | &quot;Seconds&quot; | &quot;Milliseconds&quot; | &quot;Bytes&quot; | &quot;BytesPerSecond&quot; | &quot;CountPerSecond&quot;, # Optional. The unit of the metric.
        ///       metricAvailabilities: [
        ///         {
        ///           timeGrain: &quot;PT5S&quot; | &quot;PT10S&quot; | &quot;PT1M&quot; | &quot;PT5M&quot; | &quot;PT1H&quot;, # Optional. The time grain specifies the aggregation interval for the metric. Expressed as a duration &apos;PT1M&apos;, &apos;PT1H&apos;, etc.
        ///         }
        ///       ], # Optional. Metric availability specifies the time grain (aggregation interval or frequency) and the retention period for that time grain.
        ///     }
        ///   ], # Optional. the values for the metric definitions.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> MetricDefinitionsAsync(string testRunId, string metricnamespace, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testRunId, nameof(testRunId));
            Argument.AssertNotNull(metricnamespace, nameof(metricnamespace));

            using var scope = ClientDiagnostics.CreateScope("TestRunClient.MetricDefinitions");
            scope.Start();
            try
            {
                using HttpMessage message = CreateMetricDefinitionsRequest(testRunId, metricnamespace, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Lists the metric definitions for a load test run. </summary>
        /// <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        /// <param name="metricnamespace"> Metric namespace to query metric definitions for. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testRunId"/> or <paramref name="metricnamespace"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testRunId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call MetricDefinitions with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestRunClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = client.MetricDefinitions("<testRunId>", "<metricnamespace>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("dimensions")[0].GetProperty("localizedValue").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("dimensions")[0].GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("displayDescription").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("name").GetProperty("localizedValue").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("name").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("namespace").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("primaryAggregationType").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("supportedAggregationTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("unit").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("metricAvailabilities")[0].GetProperty("timeGrain").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>MetricDefinitionCollection</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       dimensions: [
        ///         {
        ///           localizedValue: string, # Optional. The locale specific value.
        ///           value: string, # Optional. The invariant value.
        ///         }
        ///       ], # Optional. The name and the display name of the dimension, i.e. it is a localizable string.
        ///       displayDescription: string, # Optional. Detailed description of this metric.
        ///       name: LocalizableString, # Optional. The localizable string class.
        ///       namespace: string, # Optional. The namespace the metric belongs to.
        ///       primaryAggregationType: &quot;Average&quot; | &quot;Count&quot; | &quot;Minimum&quot; | &quot;Maximum&quot; | &quot;None&quot; | &quot;Total&quot; | &quot;Percentile90&quot; | &quot;Percentile95&quot; | &quot;Percentile99&quot;, # Optional. the primary aggregation type value defining how to use the values for display.
        ///       supportedAggregationTypes: [string], # Optional. the collection of what aggregation types are supported.
        ///       unit: &quot;NotSpecified&quot; | &quot;Percent&quot; | &quot;Count&quot; | &quot;Seconds&quot; | &quot;Milliseconds&quot; | &quot;Bytes&quot; | &quot;BytesPerSecond&quot; | &quot;CountPerSecond&quot;, # Optional. The unit of the metric.
        ///       metricAvailabilities: [
        ///         {
        ///           timeGrain: &quot;PT5S&quot; | &quot;PT10S&quot; | &quot;PT1M&quot; | &quot;PT5M&quot; | &quot;PT1H&quot;, # Optional. The time grain specifies the aggregation interval for the metric. Expressed as a duration &apos;PT1M&apos;, &apos;PT1H&apos;, etc.
        ///         }
        ///       ], # Optional. Metric availability specifies the time grain (aggregation interval or frequency) and the retention period for that time grain.
        ///     }
        ///   ], # Optional. the values for the metric definitions.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response MetricDefinitions(string testRunId, string metricnamespace, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testRunId, nameof(testRunId));
            Argument.AssertNotNull(metricnamespace, nameof(metricnamespace));

            using var scope = ClientDiagnostics.CreateScope("TestRunClient.MetricDefinitions");
            scope.Start();
            try
            {
                using HttpMessage message = CreateMetricDefinitionsRequest(testRunId, metricnamespace, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Lists the metric values for a load test run. </summary>
        /// <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        /// <param name="metricname"> Metric name. </param>
        /// <param name="metricnamespace"> Metric namespace to query metric definitions for. </param>
        /// <param name="resultType"> Reduces the set of data collected. The syntax allowed depends on the operation. See the operation&apos;s description for details. Allowed values: &quot;Data&quot; | &quot;Metadata&quot;. </param>
        /// <param name="timespan"> The timespan of the query. It is a string with the following format &apos;startDateTime_ISO/endDateTime_ISO&apos;. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="aggregation"> The list of aggregation types (comma separated) to retrieve. </param>
        /// <param name="interval"> The interval (i.e. timegrain) of the query. Allowed values: &quot;PT5S&quot; | &quot;PT10S&quot; | &quot;PT1M&quot; | &quot;PT5M&quot; | &quot;PT1H&quot;. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testRunId"/>, <paramref name="metricname"/>, <paramref name="metricnamespace"/>, <paramref name="resultType"/> or <paramref name="timespan"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testRunId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call MetricsAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestRunClient("<https://my-service.azure.com>", credential);
        /// 
        /// var data = new {};
        /// 
        /// Response response = await client.MetricsAsync("<testRunId>", "<metricname>", "<metricnamespace>", "<resultType>", "<timespan>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.ToString());
        /// ]]></code>
        /// This sample shows how to call MetricsAsync with all parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestRunClient("<https://my-service.azure.com>", credential);
        /// 
        /// var data = new {
        ///     filters = new[] {
        ///         new {
        ///             name = "<name>",
        ///             values = new[] {
        ///                 "<String>"
        ///             },
        ///         }
        ///     },
        /// };
        /// 
        /// Response response = await client.MetricsAsync("<testRunId>", "<metricname>", "<metricnamespace>", "<resultType>", "<timespan>", RequestContent.Create(data), "<aggregation>", "<interval>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("interval").ToString());
        /// Console.WriteLine(result.GetProperty("namespace").ToString());
        /// Console.WriteLine(result.GetProperty("timespan").ToString());
        /// Console.WriteLine(result.GetProperty("value").GetProperty("displayDescription").ToString());
        /// Console.WriteLine(result.GetProperty("value").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("value").GetProperty("name").GetProperty("localizedValue").ToString());
        /// Console.WriteLine(result.GetProperty("value").GetProperty("name").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("value").GetProperty("timeseries")[0].GetProperty("data")[0].GetProperty("average").ToString());
        /// Console.WriteLine(result.GetProperty("value").GetProperty("timeseries")[0].GetProperty("data")[0].GetProperty("count").ToString());
        /// Console.WriteLine(result.GetProperty("value").GetProperty("timeseries")[0].GetProperty("data")[0].GetProperty("maximum").ToString());
        /// Console.WriteLine(result.GetProperty("value").GetProperty("timeseries")[0].GetProperty("data")[0].GetProperty("minimum").ToString());
        /// Console.WriteLine(result.GetProperty("value").GetProperty("timeseries")[0].GetProperty("data")[0].GetProperty("timeStamp").ToString());
        /// Console.WriteLine(result.GetProperty("value").GetProperty("timeseries")[0].GetProperty("data")[0].GetProperty("total").ToString());
        /// Console.WriteLine(result.GetProperty("value").GetProperty("timeseries")[0].GetProperty("data")[0].GetProperty("percentile90").ToString());
        /// Console.WriteLine(result.GetProperty("value").GetProperty("timeseries")[0].GetProperty("data")[0].GetProperty("percentile95").ToString());
        /// Console.WriteLine(result.GetProperty("value").GetProperty("timeseries")[0].GetProperty("data")[0].GetProperty("percentile99").ToString());
        /// Console.WriteLine(result.GetProperty("value").GetProperty("timeseries")[0].GetProperty("metadatavalues")[0].GetProperty("name").GetProperty("localizedValue").ToString());
        /// Console.WriteLine(result.GetProperty("value").GetProperty("timeseries")[0].GetProperty("metadatavalues")[0].GetProperty("name").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("value").GetProperty("timeseries")[0].GetProperty("metadatavalues")[0].GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("value").GetProperty("unit").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>MetricRequestPayload</c>:
        /// <code>{
        ///   filters: [
        ///     {
        ///       name: string, # Optional. The invariant metadata name
        ///       values: [string], # Optional. The metadata values. Maximum values can be 20.
        ///     }
        ///   ], # Optional.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>Response</c>:
        /// <code>{
        ///   interval: string, # Optional. The interval (window size) for which the metric data was returned in. This may be adjusted in the future and returned back from what was originally requested. This is not present if a metadata request was made.
        ///   namespace: string, # Optional. The namespace of the metrics being queried.
        ///   timespan: string, # Optional. The timespan for which the data was retrieved. Its value consists of two datetimes concatenated, separated by &apos;/&apos;. This may be adjusted in the future and returned back from what was originally requested.
        ///   value: {
        ///     displayDescription: string, # Optional. Detailed description of this metric.
        ///     id: string, # Optional. The Metric Id.
        ///     name: {
        ///       localizedValue: string, # Optional. The locale specific value.
        ///       value: string, # Optional. The invariant value.
        ///     }, # Optional. The localizable string class.
        ///     timeseries: [
        ///       {
        ///         data: [
        ///           {
        ///             average: number, # Optional. The average value in the time range.
        ///             count: number, # Optional. The number of samples in the time range. Can be used to determine the number of values that contributed to the average value.
        ///             maximum: number, # Optional. The greatest value in the time range.
        ///             minimum: number, # Optional. The least value in the time range.
        ///             timeStamp: string, # Optional. The timestamp for the metric value in ISO 8601 format.
        ///             total: number, # Optional. The sum of all of the values in the time range.
        ///             percentile90: number, # Optional. 90th percentile value in the time range.
        ///             percentile95: number, # Optional. 95th percentile value in the time range.
        ///             percentile99: number, # Optional. 99th percentile value in the time range.
        ///           }
        ///         ], # Optional. An array of data points representing the metric values. This is only returned if a result type of data is specified.
        ///         metadatavalues: [
        ///           {
        ///             name: LocalizableString, # Optional. The localizable string class.
        ///             value: string, # Optional. The value of the metadata.
        ///           }
        ///         ], # Optional. The metadata values 
        ///       }
        ///     ], # Optional. The time series returned when a data query is performed.
        ///     unit: &quot;NotSpecified&quot; | &quot;Percent&quot; | &quot;Count&quot; | &quot;Seconds&quot; | &quot;Milliseconds&quot; | &quot;Bytes&quot; | &quot;BytesPerSecond&quot; | &quot;CountPerSecond&quot;, # Optional. The unit of the metric.
        ///   }, # Optional. The result data of a query.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> MetricsAsync(string testRunId, string metricname, string metricnamespace, string resultType, string timespan, RequestContent content, string aggregation = null, string interval = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testRunId, nameof(testRunId));
            Argument.AssertNotNull(metricname, nameof(metricname));
            Argument.AssertNotNull(metricnamespace, nameof(metricnamespace));
            Argument.AssertNotNull(resultType, nameof(resultType));
            Argument.AssertNotNull(timespan, nameof(timespan));

            using var scope = ClientDiagnostics.CreateScope("TestRunClient.Metrics");
            scope.Start();
            try
            {
                using HttpMessage message = CreateMetricsRequest(testRunId, metricname, metricnamespace, resultType, timespan, content, aggregation, interval, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Lists the metric values for a load test run. </summary>
        /// <param name="testRunId"> Unique name for the load test run, must contain only lower-case alphabetic, numeric, underscore or hyphen characters. </param>
        /// <param name="metricname"> Metric name. </param>
        /// <param name="metricnamespace"> Metric namespace to query metric definitions for. </param>
        /// <param name="resultType"> Reduces the set of data collected. The syntax allowed depends on the operation. See the operation&apos;s description for details. Allowed values: &quot;Data&quot; | &quot;Metadata&quot;. </param>
        /// <param name="timespan"> The timespan of the query. It is a string with the following format &apos;startDateTime_ISO/endDateTime_ISO&apos;. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="aggregation"> The list of aggregation types (comma separated) to retrieve. </param>
        /// <param name="interval"> The interval (i.e. timegrain) of the query. Allowed values: &quot;PT5S&quot; | &quot;PT10S&quot; | &quot;PT1M&quot; | &quot;PT5M&quot; | &quot;PT1H&quot;. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testRunId"/>, <paramref name="metricname"/>, <paramref name="metricnamespace"/>, <paramref name="resultType"/> or <paramref name="timespan"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testRunId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call Metrics with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestRunClient("<https://my-service.azure.com>", credential);
        /// 
        /// var data = new {};
        /// 
        /// Response response = client.Metrics("<testRunId>", "<metricname>", "<metricnamespace>", "<resultType>", "<timespan>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.ToString());
        /// ]]></code>
        /// This sample shows how to call Metrics with all parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestRunClient("<https://my-service.azure.com>", credential);
        /// 
        /// var data = new {
        ///     filters = new[] {
        ///         new {
        ///             name = "<name>",
        ///             values = new[] {
        ///                 "<String>"
        ///             },
        ///         }
        ///     },
        /// };
        /// 
        /// Response response = client.Metrics("<testRunId>", "<metricname>", "<metricnamespace>", "<resultType>", "<timespan>", RequestContent.Create(data), "<aggregation>", "<interval>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("interval").ToString());
        /// Console.WriteLine(result.GetProperty("namespace").ToString());
        /// Console.WriteLine(result.GetProperty("timespan").ToString());
        /// Console.WriteLine(result.GetProperty("value").GetProperty("displayDescription").ToString());
        /// Console.WriteLine(result.GetProperty("value").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("value").GetProperty("name").GetProperty("localizedValue").ToString());
        /// Console.WriteLine(result.GetProperty("value").GetProperty("name").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("value").GetProperty("timeseries")[0].GetProperty("data")[0].GetProperty("average").ToString());
        /// Console.WriteLine(result.GetProperty("value").GetProperty("timeseries")[0].GetProperty("data")[0].GetProperty("count").ToString());
        /// Console.WriteLine(result.GetProperty("value").GetProperty("timeseries")[0].GetProperty("data")[0].GetProperty("maximum").ToString());
        /// Console.WriteLine(result.GetProperty("value").GetProperty("timeseries")[0].GetProperty("data")[0].GetProperty("minimum").ToString());
        /// Console.WriteLine(result.GetProperty("value").GetProperty("timeseries")[0].GetProperty("data")[0].GetProperty("timeStamp").ToString());
        /// Console.WriteLine(result.GetProperty("value").GetProperty("timeseries")[0].GetProperty("data")[0].GetProperty("total").ToString());
        /// Console.WriteLine(result.GetProperty("value").GetProperty("timeseries")[0].GetProperty("data")[0].GetProperty("percentile90").ToString());
        /// Console.WriteLine(result.GetProperty("value").GetProperty("timeseries")[0].GetProperty("data")[0].GetProperty("percentile95").ToString());
        /// Console.WriteLine(result.GetProperty("value").GetProperty("timeseries")[0].GetProperty("data")[0].GetProperty("percentile99").ToString());
        /// Console.WriteLine(result.GetProperty("value").GetProperty("timeseries")[0].GetProperty("metadatavalues")[0].GetProperty("name").GetProperty("localizedValue").ToString());
        /// Console.WriteLine(result.GetProperty("value").GetProperty("timeseries")[0].GetProperty("metadatavalues")[0].GetProperty("name").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("value").GetProperty("timeseries")[0].GetProperty("metadatavalues")[0].GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("value").GetProperty("unit").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>MetricRequestPayload</c>:
        /// <code>{
        ///   filters: [
        ///     {
        ///       name: string, # Optional. The invariant metadata name
        ///       values: [string], # Optional. The metadata values. Maximum values can be 20.
        ///     }
        ///   ], # Optional.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>Response</c>:
        /// <code>{
        ///   interval: string, # Optional. The interval (window size) for which the metric data was returned in. This may be adjusted in the future and returned back from what was originally requested. This is not present if a metadata request was made.
        ///   namespace: string, # Optional. The namespace of the metrics being queried.
        ///   timespan: string, # Optional. The timespan for which the data was retrieved. Its value consists of two datetimes concatenated, separated by &apos;/&apos;. This may be adjusted in the future and returned back from what was originally requested.
        ///   value: {
        ///     displayDescription: string, # Optional. Detailed description of this metric.
        ///     id: string, # Optional. The Metric Id.
        ///     name: {
        ///       localizedValue: string, # Optional. The locale specific value.
        ///       value: string, # Optional. The invariant value.
        ///     }, # Optional. The localizable string class.
        ///     timeseries: [
        ///       {
        ///         data: [
        ///           {
        ///             average: number, # Optional. The average value in the time range.
        ///             count: number, # Optional. The number of samples in the time range. Can be used to determine the number of values that contributed to the average value.
        ///             maximum: number, # Optional. The greatest value in the time range.
        ///             minimum: number, # Optional. The least value in the time range.
        ///             timeStamp: string, # Optional. The timestamp for the metric value in ISO 8601 format.
        ///             total: number, # Optional. The sum of all of the values in the time range.
        ///             percentile90: number, # Optional. 90th percentile value in the time range.
        ///             percentile95: number, # Optional. 95th percentile value in the time range.
        ///             percentile99: number, # Optional. 99th percentile value in the time range.
        ///           }
        ///         ], # Optional. An array of data points representing the metric values. This is only returned if a result type of data is specified.
        ///         metadatavalues: [
        ///           {
        ///             name: LocalizableString, # Optional. The localizable string class.
        ///             value: string, # Optional. The value of the metadata.
        ///           }
        ///         ], # Optional. The metadata values 
        ///       }
        ///     ], # Optional. The time series returned when a data query is performed.
        ///     unit: &quot;NotSpecified&quot; | &quot;Percent&quot; | &quot;Count&quot; | &quot;Seconds&quot; | &quot;Milliseconds&quot; | &quot;Bytes&quot; | &quot;BytesPerSecond&quot; | &quot;CountPerSecond&quot;, # Optional. The unit of the metric.
        ///   }, # Optional. The result data of a query.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response Metrics(string testRunId, string metricname, string metricnamespace, string resultType, string timespan, RequestContent content, string aggregation = null, string interval = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testRunId, nameof(testRunId));
            Argument.AssertNotNull(metricname, nameof(metricname));
            Argument.AssertNotNull(metricnamespace, nameof(metricnamespace));
            Argument.AssertNotNull(resultType, nameof(resultType));
            Argument.AssertNotNull(timespan, nameof(timespan));

            using var scope = ClientDiagnostics.CreateScope("TestRunClient.Metrics");
            scope.Start();
            try
            {
                using HttpMessage message = CreateMetricsRequest(testRunId, metricname, metricnamespace, resultType, timespan, content, aggregation, interval, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get all test runs with given filters. </summary>
        /// <param name="orderBy"> Sort on one of the field - status, displayName, executedDateTime in (field asc/desc) format. eg: displayName asc. </param>
        /// <param name="continuationToken"> Continuation token to get the next page of response. </param>
        /// <param name="search"> Filter search based on searchable fields - description, executedUser. </param>
        /// <param name="executionFrom"> End DateTime(ISO 8601 literal format) of test-run execution time filter range. </param>
        /// <param name="executionTo"> Start DateTime(ISO 8601 literal format) of test-run execution time filter range. </param>
        /// <param name="status"> Comma separated list of test run status. </param>
        /// <param name="maxPageSize"> Number of results in response. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTestRunsAsync and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestRunClient("<https://my-service.azure.com>", credential);
        /// 
        /// await foreach (var data in client.GetTestRunsAsync())
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetTestRunsAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestRunClient("<https://my-service.azure.com>", credential);
        /// 
        /// await foreach (var data in client.GetTestRunsAsync("<orderBy>", "<continuationToken>", "<search>", DateTimeOffset.UtcNow, DateTimeOffset.UtcNow, "<status>", 1234))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("clientmetric").ToString());
        ///     Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("aggregate").ToString());
        ///     Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("condition").ToString());
        ///     Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("requestName").ToString());
        ///     Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("value").ToString());
        ///     Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("action").ToString());
        ///     Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("actualValue").ToString());
        ///     Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("result").ToString());
        ///     Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("value").ToString());
        ///     Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("type").ToString());
        ///     Console.WriteLine(result.GetProperty("certificate").GetProperty("value").ToString());
        ///     Console.WriteLine(result.GetProperty("certificate").GetProperty("type").ToString());
        ///     Console.WriteLine(result.GetProperty("certificate").GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("environmentVariables").GetProperty("<test>").ToString());
        ///     Console.WriteLine(result.GetProperty("errorDetails")[0].GetProperty("message").ToString());
        ///     Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("transaction").ToString());
        ///     Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("sampleCount").ToString());
        ///     Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("errorCount").ToString());
        ///     Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("errorPct").ToString());
        ///     Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("meanResTime").ToString());
        ///     Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("medianResTime").ToString());
        ///     Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("maxResTime").ToString());
        ///     Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("minResTime").ToString());
        ///     Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("pct1ResTime").ToString());
        ///     Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("pct2ResTime").ToString());
        ///     Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("pct3ResTime").ToString());
        ///     Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("throughput").ToString());
        ///     Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("receivedKBytesPerSec").ToString());
        ///     Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("sentKBytesPerSec").ToString());
        ///     Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("engineInstances").ToString());
        ///     Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("splitAllCSVs").ToString());
        ///     Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("quickStartTest").ToString());
        ///     Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("endpointUrl").ToString());
        ///     Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("vusers").ToString());
        ///     Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("rampUpTime").ToString());
        ///     Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("duration").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("url").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileId").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("filename").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileType").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("expireTime").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("validationStatus").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("url").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileId").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("filename").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileType").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("expireTime").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("validationStatus").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("url").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileId").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("filename").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileType").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("expireTime").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("validationStatus").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("url").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileId").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("filename").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileType").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("expireTime").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("validationStatus").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("url").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileId").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("filename").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileType").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("expireTime").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("validationStatus").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("url").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("fileId").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("filename").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("fileType").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("expireTime").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("validationStatus").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("url").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("fileId").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("filename").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("fileType").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("expireTime").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("validationStatus").ToString());
        ///     Console.WriteLine(result.GetProperty("testResult").ToString());
        ///     Console.WriteLine(result.GetProperty("testRunId").ToString());
        ///     Console.WriteLine(result.GetProperty("displayName").ToString());
        ///     Console.WriteLine(result.GetProperty("testId").ToString());
        ///     Console.WriteLine(result.GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("status").ToString());
        ///     Console.WriteLine(result.GetProperty("startDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("endDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("executedDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("vusers").ToString());
        ///     Console.WriteLine(result.GetProperty("portalUrl").ToString());
        ///     Console.WriteLine(result.GetProperty("duration").ToString());
        ///     Console.WriteLine(result.GetProperty("subnetId").ToString());
        ///     Console.WriteLine(result.GetProperty("resourceId").ToString());
        ///     Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("createdBy").ToString());
        ///     Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TestRunModel20221101ResourceListValue</c>:
        /// <code>{
        ///   passFailCriteria: {
        ///     passFailMetrics: Dictionary&lt;string, PassFailMetric20221101&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
        ///   }, # Optional. Pass fail criteria for a test.
        ///   secrets: Dictionary&lt;string, SecretMetadata20221101&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
        ///   certificate: {
        ///     value: string, # Optional. The value of the certificate for respective type
        ///     type: &quot;AKV_CERT_URI&quot;, # Optional. Type of certificate
        ///     name: string, # Optional. Name of the certificate.
        ///   }, # Optional.
        ///   environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
        ///   errorDetails: [
        ///     {
        ///       message: string, # Optional. Error details in case test run was not successfully run.
        ///     }
        ///   ], # Optional. Error details if there is any failure in load test run
        ///   testRunStatistics: Dictionary&lt;string, TestRunStatisticsModel&gt;, # Optional. Test run statistics.
        ///   loadTestConfig: {
        ///     engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
        ///     splitAllCSVs: boolean, # Optional. Whether all the input CSV files should be split evenly across all engines.
        ///     quickStartTest: boolean, # Optional. If true, optionalLoadTestConfig is required and JMX script for the load test is not required to upload.
        ///     optionalLoadTestConfig: {
        ///       endpointUrl: string, # Optional. Endpoint url
        ///       vusers: number, # Optional. No of virtual users 
        ///       rampUpTime: number, # Optional. ramp up time
        ///       duration: number, # Optional. duration
        ///     }, # Optional. Quick start load test config
        ///   }, # Optional. The load test configuration.
        ///   testArtifacts: {
        ///     inputArtifacts: {
        ///       configUrl: {
        ///         url: string, # Optional. File URL.
        ///         fileId: string, # Optional. File unique identifier.
        ///         filename: string, # Optional. Name of the file.
        ///         fileType: &quot;JMX_FILE&quot; | &quot;USER_PROPERTIES&quot; | &quot;ADDITIONAL_ARTIFACTS&quot;, # Optional. File type
        ///         expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///         validationStatus: &quot;NOT_VALIDATED&quot; | &quot;VALIDATION_SUCCESS&quot; | &quot;VALIDATION_FAILURE&quot; | &quot;VALIDATION_INITIATED&quot;, # Optional. Validation status of the file
        ///       }, # Optional. FileUrl Model.
        ///       testScriptUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///       userPropUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///       inputArtifactsZipFileurl: FileUrl20221101, # Optional. FileUrl Model.
        ///       additionalUrls: [FileUrl20221101], # Optional. Additional supported files for the test run
        ///     }, # Required. The input artifacts for the test.
        ///     outputArtifacts: {
        ///       resultUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///       logsUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///     }, # Optional. The output artifacts for the test run.
        ///   }, # Optional. test artifact 20221101
        ///   testResult: &quot;PASSED&quot; | &quot;NOT_APPLICABLE&quot; | &quot;FAILED&quot;, # Optional. Test result for pass/Fail criteria used during the test run.
        ///   testRunId: string, # Optional. Unique test run name as identifier
        ///   displayName: string, # Optional. Display name of a testRun.
        ///   testId: string, # Optional. Associated test Id.
        ///   description: string, # Optional. The test run description.
        ///   status: &quot;ACCEPTED&quot; | &quot;NOTSTARTED&quot; | &quot;PROVISIONING&quot; | &quot;PROVISIONED&quot; | &quot;CONFIGURING&quot; | &quot;CONFIGURED&quot; | &quot;EXECUTING&quot; | &quot;EXECUTED&quot; | &quot;DEPROVISIONING&quot; | &quot;DEPROVISIONED&quot; | &quot;DONE&quot; | &quot;CANCELLING&quot; | &quot;CANCELLED&quot; | &quot;FAILED&quot; | &quot;VALIDATION_SUCCESS&quot; | &quot;VALIDATION_FAILURE&quot;, # Optional. The test run status.
        ///   startDateTime: string (ISO 8601 Format), # Optional. The test run start DateTime(ISO 8601 literal format).
        ///   endDateTime: string (ISO 8601 Format), # Optional. The test run end DateTime(ISO 8601 literal format).
        ///   executedDateTime: string (ISO 8601 Format), # Optional. Test run initiated time.
        ///   vusers: number, # Optional. Number of virtual users, for which test has been run.
        ///   portalUrl: string, # Optional. Portal url.
        ///   duration: number, # Optional. Test run duration in milliseconds.
        ///   subnetId: string, # Optional. Subnet ID on which the load test instances should run.
        ///   resourceId: string, # Optional. Fully qualified resource Id e.g /subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}.
        ///   createdDateTime: string (ISO 8601 Format), # Optional. The created DateTime(ISO 8601 literal format) of the test model.
        ///   createdBy: string, # Optional. The user that created the test model.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified DateTime(ISO 8601 literal format) of the test model.
        ///   lastModifiedBy: string, # Optional. The user that last modified the test model.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetTestRunsAsync(string orderBy = null, string continuationToken = null, string search = null, DateTimeOffset? executionFrom = null, DateTimeOffset? executionTo = null, string status = null, int? maxPageSize = null, RequestContext context = null)
        {
            return GetTestRunsImplementationAsync("TestRunClient.GetTestRuns", orderBy, continuationToken, search, executionFrom, executionTo, status, maxPageSize, context);
        }

        private AsyncPageable<BinaryData> GetTestRunsImplementationAsync(string diagnosticsScopeName, string orderBy, string continuationToken, string search, DateTimeOffset? executionFrom, DateTimeOffset? executionTo, string status, int? maxPageSize, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetTestRunsRequest(orderBy, continuationToken, search, executionFrom, executionTo, status, maxPageSize, context)
                        : CreateGetTestRunsNextPageRequest(nextLink, orderBy, continuationToken, search, executionFrom, executionTo, status, maxPageSize, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Get all test runs with given filters. </summary>
        /// <param name="orderBy"> Sort on one of the field - status, displayName, executedDateTime in (field asc/desc) format. eg: displayName asc. </param>
        /// <param name="continuationToken"> Continuation token to get the next page of response. </param>
        /// <param name="search"> Filter search based on searchable fields - description, executedUser. </param>
        /// <param name="executionFrom"> End DateTime(ISO 8601 literal format) of test-run execution time filter range. </param>
        /// <param name="executionTo"> Start DateTime(ISO 8601 literal format) of test-run execution time filter range. </param>
        /// <param name="status"> Comma separated list of test run status. </param>
        /// <param name="maxPageSize"> Number of results in response. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTestRuns and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestRunClient("<https://my-service.azure.com>", credential);
        /// 
        /// foreach (var data in client.GetTestRuns())
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetTestRuns with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestRunClient("<https://my-service.azure.com>", credential);
        /// 
        /// foreach (var data in client.GetTestRuns("<orderBy>", "<continuationToken>", "<search>", DateTimeOffset.UtcNow, DateTimeOffset.UtcNow, "<status>", 1234))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("clientmetric").ToString());
        ///     Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("aggregate").ToString());
        ///     Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("condition").ToString());
        ///     Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("requestName").ToString());
        ///     Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("value").ToString());
        ///     Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("action").ToString());
        ///     Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("actualValue").ToString());
        ///     Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("result").ToString());
        ///     Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("value").ToString());
        ///     Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("type").ToString());
        ///     Console.WriteLine(result.GetProperty("certificate").GetProperty("value").ToString());
        ///     Console.WriteLine(result.GetProperty("certificate").GetProperty("type").ToString());
        ///     Console.WriteLine(result.GetProperty("certificate").GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("environmentVariables").GetProperty("<test>").ToString());
        ///     Console.WriteLine(result.GetProperty("errorDetails")[0].GetProperty("message").ToString());
        ///     Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("transaction").ToString());
        ///     Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("sampleCount").ToString());
        ///     Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("errorCount").ToString());
        ///     Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("errorPct").ToString());
        ///     Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("meanResTime").ToString());
        ///     Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("medianResTime").ToString());
        ///     Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("maxResTime").ToString());
        ///     Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("minResTime").ToString());
        ///     Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("pct1ResTime").ToString());
        ///     Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("pct2ResTime").ToString());
        ///     Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("pct3ResTime").ToString());
        ///     Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("throughput").ToString());
        ///     Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("receivedKBytesPerSec").ToString());
        ///     Console.WriteLine(result.GetProperty("testRunStatistics").GetProperty("<test>").GetProperty("sentKBytesPerSec").ToString());
        ///     Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("engineInstances").ToString());
        ///     Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("splitAllCSVs").ToString());
        ///     Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("quickStartTest").ToString());
        ///     Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("endpointUrl").ToString());
        ///     Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("vusers").ToString());
        ///     Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("rampUpTime").ToString());
        ///     Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("optionalLoadTestConfig").GetProperty("duration").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("url").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileId").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("filename").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileType").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("expireTime").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("validationStatus").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("url").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileId").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("filename").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileType").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("expireTime").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("validationStatus").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("url").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileId").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("filename").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileType").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("expireTime").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("validationStatus").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("url").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileId").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("filename").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileType").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("expireTime").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("validationStatus").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("url").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileId").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("filename").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileType").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("expireTime").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("validationStatus").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("url").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("fileId").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("filename").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("fileType").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("expireTime").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("resultUrl").GetProperty("validationStatus").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("url").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("fileId").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("filename").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("fileType").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("expireTime").ToString());
        ///     Console.WriteLine(result.GetProperty("testArtifacts").GetProperty("outputArtifacts").GetProperty("logsUrl").GetProperty("validationStatus").ToString());
        ///     Console.WriteLine(result.GetProperty("testResult").ToString());
        ///     Console.WriteLine(result.GetProperty("testRunId").ToString());
        ///     Console.WriteLine(result.GetProperty("displayName").ToString());
        ///     Console.WriteLine(result.GetProperty("testId").ToString());
        ///     Console.WriteLine(result.GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("status").ToString());
        ///     Console.WriteLine(result.GetProperty("startDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("endDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("executedDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("vusers").ToString());
        ///     Console.WriteLine(result.GetProperty("portalUrl").ToString());
        ///     Console.WriteLine(result.GetProperty("duration").ToString());
        ///     Console.WriteLine(result.GetProperty("subnetId").ToString());
        ///     Console.WriteLine(result.GetProperty("resourceId").ToString());
        ///     Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("createdBy").ToString());
        ///     Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TestRunModel20221101ResourceListValue</c>:
        /// <code>{
        ///   passFailCriteria: {
        ///     passFailMetrics: Dictionary&lt;string, PassFailMetric20221101&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
        ///   }, # Optional. Pass fail criteria for a test.
        ///   secrets: Dictionary&lt;string, SecretMetadata20221101&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
        ///   certificate: {
        ///     value: string, # Optional. The value of the certificate for respective type
        ///     type: &quot;AKV_CERT_URI&quot;, # Optional. Type of certificate
        ///     name: string, # Optional. Name of the certificate.
        ///   }, # Optional.
        ///   environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
        ///   errorDetails: [
        ///     {
        ///       message: string, # Optional. Error details in case test run was not successfully run.
        ///     }
        ///   ], # Optional. Error details if there is any failure in load test run
        ///   testRunStatistics: Dictionary&lt;string, TestRunStatisticsModel&gt;, # Optional. Test run statistics.
        ///   loadTestConfig: {
        ///     engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
        ///     splitAllCSVs: boolean, # Optional. Whether all the input CSV files should be split evenly across all engines.
        ///     quickStartTest: boolean, # Optional. If true, optionalLoadTestConfig is required and JMX script for the load test is not required to upload.
        ///     optionalLoadTestConfig: {
        ///       endpointUrl: string, # Optional. Endpoint url
        ///       vusers: number, # Optional. No of virtual users 
        ///       rampUpTime: number, # Optional. ramp up time
        ///       duration: number, # Optional. duration
        ///     }, # Optional. Quick start load test config
        ///   }, # Optional. The load test configuration.
        ///   testArtifacts: {
        ///     inputArtifacts: {
        ///       configUrl: {
        ///         url: string, # Optional. File URL.
        ///         fileId: string, # Optional. File unique identifier.
        ///         filename: string, # Optional. Name of the file.
        ///         fileType: &quot;JMX_FILE&quot; | &quot;USER_PROPERTIES&quot; | &quot;ADDITIONAL_ARTIFACTS&quot;, # Optional. File type
        ///         expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///         validationStatus: &quot;NOT_VALIDATED&quot; | &quot;VALIDATION_SUCCESS&quot; | &quot;VALIDATION_FAILURE&quot; | &quot;VALIDATION_INITIATED&quot;, # Optional. Validation status of the file
        ///       }, # Optional. FileUrl Model.
        ///       testScriptUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///       userPropUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///       inputArtifactsZipFileurl: FileUrl20221101, # Optional. FileUrl Model.
        ///       additionalUrls: [FileUrl20221101], # Optional. Additional supported files for the test run
        ///     }, # Required. The input artifacts for the test.
        ///     outputArtifacts: {
        ///       resultUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///       logsUrl: FileUrl20221101, # Optional. FileUrl Model.
        ///     }, # Optional. The output artifacts for the test run.
        ///   }, # Optional. test artifact 20221101
        ///   testResult: &quot;PASSED&quot; | &quot;NOT_APPLICABLE&quot; | &quot;FAILED&quot;, # Optional. Test result for pass/Fail criteria used during the test run.
        ///   testRunId: string, # Optional. Unique test run name as identifier
        ///   displayName: string, # Optional. Display name of a testRun.
        ///   testId: string, # Optional. Associated test Id.
        ///   description: string, # Optional. The test run description.
        ///   status: &quot;ACCEPTED&quot; | &quot;NOTSTARTED&quot; | &quot;PROVISIONING&quot; | &quot;PROVISIONED&quot; | &quot;CONFIGURING&quot; | &quot;CONFIGURED&quot; | &quot;EXECUTING&quot; | &quot;EXECUTED&quot; | &quot;DEPROVISIONING&quot; | &quot;DEPROVISIONED&quot; | &quot;DONE&quot; | &quot;CANCELLING&quot; | &quot;CANCELLED&quot; | &quot;FAILED&quot; | &quot;VALIDATION_SUCCESS&quot; | &quot;VALIDATION_FAILURE&quot;, # Optional. The test run status.
        ///   startDateTime: string (ISO 8601 Format), # Optional. The test run start DateTime(ISO 8601 literal format).
        ///   endDateTime: string (ISO 8601 Format), # Optional. The test run end DateTime(ISO 8601 literal format).
        ///   executedDateTime: string (ISO 8601 Format), # Optional. Test run initiated time.
        ///   vusers: number, # Optional. Number of virtual users, for which test has been run.
        ///   portalUrl: string, # Optional. Portal url.
        ///   duration: number, # Optional. Test run duration in milliseconds.
        ///   subnetId: string, # Optional. Subnet ID on which the load test instances should run.
        ///   resourceId: string, # Optional. Fully qualified resource Id e.g /subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}.
        ///   createdDateTime: string (ISO 8601 Format), # Optional. The created DateTime(ISO 8601 literal format) of the test model.
        ///   createdBy: string, # Optional. The user that created the test model.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified DateTime(ISO 8601 literal format) of the test model.
        ///   lastModifiedBy: string, # Optional. The user that last modified the test model.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetTestRuns(string orderBy = null, string continuationToken = null, string search = null, DateTimeOffset? executionFrom = null, DateTimeOffset? executionTo = null, string status = null, int? maxPageSize = null, RequestContext context = null)
        {
            return GetTestRunsImplementation("TestRunClient.GetTestRuns", orderBy, continuationToken, search, executionFrom, executionTo, status, maxPageSize, context);
        }

        private Pageable<BinaryData> GetTestRunsImplementation(string diagnosticsScopeName, string orderBy, string continuationToken, string search, DateTimeOffset? executionFrom, DateTimeOffset? executionTo, string status, int? maxPageSize, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetTestRunsRequest(orderBy, continuationToken, search, executionFrom, executionTo, status, maxPageSize, context)
                        : CreateGetTestRunsNextPageRequest(nextLink, orderBy, continuationToken, search, executionFrom, executionTo, status, maxPageSize, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        internal HttpMessage CreateDeleteRequest(string testRunId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_endpoint, false);
            uri.AppendPath("/testruns/", false);
            uri.AppendPath(testRunId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCreateOrUpdateRequest(string testRunId, RequestContent content, string oldTestRunId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_endpoint, false);
            uri.AppendPath("/testruns/", false);
            uri.AppendPath(testRunId, true);
            if (oldTestRunId != null)
            {
                uri.AppendQuery("oldTestRunId", oldTestRunId, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/merge-patch+json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetTestRunRequest(string testRunId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_endpoint, false);
            uri.AppendPath("/testruns/", false);
            uri.AppendPath(testRunId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetFileRequest(string testRunId, string fileId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_endpoint, false);
            uri.AppendPath("/testruns/", false);
            uri.AppendPath(testRunId, true);
            uri.AppendPath("/files/", false);
            uri.AppendPath(fileId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetTestRunsRequest(string orderBy, string continuationToken, string search, DateTimeOffset? executionFrom, DateTimeOffset? executionTo, string status, int? maxPageSize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_endpoint, false);
            uri.AppendPath("/testruns/sortAndFilter", false);
            if (orderBy != null)
            {
                uri.AppendQuery("orderBy", orderBy, true);
            }
            if (continuationToken != null)
            {
                uri.AppendQuery("continuationToken", continuationToken, true);
            }
            if (search != null)
            {
                uri.AppendQuery("search", search, true);
            }
            if (_testId != null)
            {
                uri.AppendQuery("testId", _testId, true);
            }
            if (executionFrom != null)
            {
                uri.AppendQuery("executionFrom", executionFrom.Value, "O", true);
            }
            if (executionTo != null)
            {
                uri.AppendQuery("executionTo", executionTo.Value, "O", true);
            }
            if (status != null)
            {
                uri.AppendQuery("status", status, true);
            }
            if (maxPageSize != null)
            {
                uri.AppendQuery("maxPageSize", maxPageSize.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateStopRequest(string testRunId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_endpoint, false);
            uri.AppendPath("/testruns/", false);
            uri.AppendPath(testRunId, true);
            uri.AppendPath(":stop", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateMetricNamespacesRequest(string testRunId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_endpoint, false);
            uri.AppendPath("/testRuns/", false);
            uri.AppendPath(testRunId, true);
            uri.AppendPath("/metricNamespaces", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateMetricDefinitionsRequest(string testRunId, string metricnamespace, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_endpoint, false);
            uri.AppendPath("/testRuns/", false);
            uri.AppendPath(testRunId, true);
            uri.AppendPath("/metricDefinitions", false);
            uri.AppendQuery("metricnamespace", metricnamespace, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateMetricsRequest(string testRunId, string metricname, string metricnamespace, string resultType, string timespan, RequestContent content, string aggregation, string interval, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_endpoint, false);
            uri.AppendPath("/testRuns/", false);
            uri.AppendPath(testRunId, true);
            uri.AppendPath("/metrics", false);
            uri.AppendQuery("metricname", metricname, true);
            uri.AppendQuery("metricnamespace", metricnamespace, true);
            uri.AppendQuery("resultType", resultType, true);
            uri.AppendQuery("timespan", timespan, true);
            if (aggregation != null)
            {
                uri.AppendQuery("aggregation", aggregation, true);
            }
            if (interval != null)
            {
                uri.AppendQuery("interval", interval, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetTestRunsNextPageRequest(string nextLink, string orderBy, string continuationToken, string search, DateTimeOffset? executionFrom, DateTimeOffset? executionTo, string status, int? maxPageSize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_endpoint, false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        private static ResponseClassifier _responseClassifier204;
        private static ResponseClassifier ResponseClassifier204 => _responseClassifier204 ??= new StatusCodeClassifier(stackalloc ushort[] { 204 });
        private static ResponseClassifier _responseClassifier200;
        private static ResponseClassifier ResponseClassifier200 => _responseClassifier200 ??= new StatusCodeClassifier(stackalloc ushort[] { 200 });
    }
}
