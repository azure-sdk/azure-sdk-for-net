// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.Search.Documents.Models;

namespace Azure.Search.Documents
{
    // Data plane generated sub-client.
    /// <summary> The Documents sub-client. </summary>
    public partial class Documents
    {
        private const string AuthorizationHeader = "api-key";
        private readonly AzureKeyCredential _keyCredential;
        private static readonly string[] AuthorizationScopes = new string[] { "https://search.azure.com/.default" };
        private readonly TokenCredential _tokenCredential;
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;
        private readonly string _apiVersion;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of Documents for mocking. </summary>
        protected Documents()
        {
        }

        /// <summary> Initializes a new instance of Documents. </summary>
        /// <param name="clientDiagnostics"> The handler for diagnostic messaging in the client. </param>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="keyCredential"> The key credential to copy. </param>
        /// <param name="tokenCredential"> The token credential to copy. </param>
        /// <param name="endpoint"> Service host. </param>
        /// <param name="apiVersion"> The API version to use for this operation. </param>
        internal Documents(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, AzureKeyCredential keyCredential, TokenCredential tokenCredential, Uri endpoint, string apiVersion)
        {
            ClientDiagnostics = clientDiagnostics;
            _pipeline = pipeline;
            _keyCredential = keyCredential;
            _tokenCredential = tokenCredential;
            _endpoint = endpoint;
            _apiVersion = apiVersion;
        }

        /// <summary> Queries the number of documents in the index. </summary>
        /// <param name="indexName"> The name of the index. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="indexName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="indexName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Documents.xml" path="doc/members/member[@name='CountAsync(string,CancellationToken)']/*" />
        public virtual async Task<Response<int>> CountAsync(string indexName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(indexName, nameof(indexName));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await CountAsync(indexName, context).ConfigureAwait(false);
            return Response.FromValue(response.Content.ToObjectFromJson<int>(), response);
        }

        /// <summary> Queries the number of documents in the index. </summary>
        /// <param name="indexName"> The name of the index. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="indexName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="indexName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Documents.xml" path="doc/members/member[@name='Count(string,CancellationToken)']/*" />
        public virtual Response<int> Count(string indexName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(indexName, nameof(indexName));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = Count(indexName, context);
            return Response.FromValue(response.Content.ToObjectFromJson<int>(), response);
        }

        /// <summary>
        /// [Protocol Method] Queries the number of documents in the index.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CountAsync(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="indexName"> The name of the index. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="indexName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="indexName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Documents.xml" path="doc/members/member[@name='CountAsync(string,RequestContext)']/*" />
        public virtual async Task<Response> CountAsync(string indexName, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(indexName, nameof(indexName));

            using var scope = ClientDiagnostics.CreateScope("Documents.Count");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCountRequest(indexName, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Queries the number of documents in the index.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="Count(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="indexName"> The name of the index. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="indexName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="indexName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Documents.xml" path="doc/members/member[@name='Count(string,RequestContext)']/*" />
        public virtual Response Count(string indexName, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(indexName, nameof(indexName));

            using var scope = ClientDiagnostics.CreateScope("Documents.Count");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCountRequest(indexName, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Searches for documents in the index. </summary>
        /// <param name="indexName"> The name of the index. </param>
        /// <param name="searchText">
        /// A full-text search query expression; Use "*" or omit this parameter to match
        /// all documents.
        /// </param>
        /// <param name="includeTotalResultCount">
        /// A value that specifies whether to fetch the total count of results. Default is
        /// false. Setting this value to true may have a performance impact. Note that the
        /// count returned is an approximation.
        /// </param>
        /// <param name="facets">
        /// The list of facet expressions to apply to the search query. Each facet
        /// expression contains a field name, optionally followed by a comma-separated list
        /// of name:value pairs.
        /// </param>
        /// <param name="filter"> The OData $filter expression to apply to the search query. </param>
        /// <param name="highlightFields">
        /// The list of field names to use for hit highlights. Only searchable fields can
        /// be used for hit highlighting.
        /// </param>
        /// <param name="highlightPostTag">
        /// A string tag that is appended to hit highlights. Must be set with
        /// highlightPreTag. Default is &lt;/em&gt;.
        /// </param>
        /// <param name="highlightPreTag">
        /// A string tag that is prepended to hit highlights. Must be set with
        /// highlightPostTag. Default is &lt;em&gt;.
        /// </param>
        /// <param name="minimumCoverage">
        /// A number between 0 and 100 indicating the percentage of the index that must be
        /// covered by a search query in order for the query to be reported as a success.
        /// This parameter can be useful for ensuring search availability even for services
        /// with only one replica. The default is 100.
        /// </param>
        /// <param name="orderBy">
        /// The list of OData $orderby expressions by which to sort the results. Each
        /// expression can be either a field name or a call to either the geo.distance() or
        /// the search.score() functions. Each expression can be followed by asc to
        /// indicate ascending, and desc to indicate descending. The default is ascending
        /// order. Ties will be broken by the match scores of documents. If no OrderBy is
        /// specified, the default sort order is descending by document match score. There
        /// can be at most 32 $orderby clauses.
        /// </param>
        /// <param name="queryType">
        /// A value that specifies the syntax of the search query. The default is 'simple'.
        /// Use 'full' if your query uses the Lucene query syntax.
        /// </param>
        /// <param name="scoringParameters">
        /// The list of parameter values to be used in scoring functions (for example,
        /// referencePointParameter) using the format name-values. For example, if the
        /// scoring profile defines a function with a parameter called 'mylocation' the
        /// parameter string would be "mylocation--122.2,44.8" (without the quotes).
        /// </param>
        /// <param name="scoringProfile">
        /// The name of a scoring profile to evaluate match scores for matching documents
        /// in order to sort the results.
        /// </param>
        /// <param name="searchFields">
        /// The list of field names to which to scope the full-text search. When using
        /// fielded search (fieldName:searchExpression) in a full Lucene query, the field
        /// names of each fielded search expression take precedence over any field names
        /// listed in this parameter.
        /// </param>
        /// <param name="searchMode">
        /// A value that specifies whether any or all of the search terms must be matched
        /// in order to count the document as a match.
        /// </param>
        /// <param name="scoringStatistics">
        /// A value that specifies whether we want to calculate scoring statistics (such as
        /// document frequency) globally for more consistent scoring, or locally, for lower
        /// latency.
        /// </param>
        /// <param name="sessionId">
        /// A value to be used to create a sticky session, which can help to get more
        /// consistent results. As long as the same sessionId is used, a best-effort
        /// attempt will be made to target the same replica set. Be wary that reusing the
        /// same sessionID values repeatedly can interfere with the load balancing of the
        /// requests across replicas and adversely affect the performance of the search
        /// service. The value used as sessionId cannot start with a '_' character.
        /// </param>
        /// <param name="select">
        /// The list of fields to retrieve. If unspecified, all fields marked as
        /// retrievable in the schema are included.
        /// </param>
        /// <param name="skip">
        /// The number of search results to skip. This value cannot be greater than
        /// 100,000. If you need to scan documents in sequence, but cannot use $skip due to
        /// this limitation, consider using $orderby on a totally-ordered key and $filter
        /// with a range query instead.
        /// </param>
        /// <param name="top">
        /// The number of search results to retrieve. This can be used in conjunction with
        /// $skip to implement client-side paging of search results. If results are
        /// truncated due to server-side paging, the response will include a continuation
        /// token that can be used to issue another Search request for the next page of
        /// results.
        /// </param>
        /// <param name="semanticConfiguration">
        /// The name of the semantic configuration that lists which fields should be used
        /// for semantic ranking, captions, highlights, and answers
        /// </param>
        /// <param name="semanticErrorHandling">
        /// Allows the user to choose whether a semantic call should fail completely, or to
        /// return partial results (default).
        /// </param>
        /// <param name="semanticMaxWaitInMilliseconds">
        /// Allows the user to set an upper bound on the amount of time it takes for
        /// semantic enrichment to finish processing before the request fails.
        /// </param>
        /// <param name="answers">
        /// This parameter is only valid if the query type is `semantic`. If set, the query
        /// returns answers extracted from key passages in the highest ranked documents.
        /// The number of answers returned can be configured by appending the pipe
        /// character `|` followed by the `count-&lt;number of answers&gt;` option after the
        /// answers parameter value, such as `extractive|count-3`. Default count is 1. The
        /// confidence threshold can be configured by appending the pipe character `|`
        /// followed by the `threshold-&lt;confidence threshold&gt;` option after the answers
        /// parameter value, such as `extractive|threshold-0.9`. Default threshold is 0.7.
        /// </param>
        /// <param name="captions">
        /// This parameter is only valid if the query type is `semantic`. If set, the query
        /// returns captions extracted from key passages in the highest ranked documents.
        /// When Captions is set to `extractive`, highlighting is enabled by default, and
        /// can be configured by appending the pipe character `|` followed by the
        /// `highlight-&lt;true/false&gt;` option, such as `extractive|highlight-true`. Defaults
        /// to `None`.
        /// </param>
        /// <param name="semanticQuery">
        /// Allows setting a separate search query that will be solely used for semantic
        /// reranking, semantic captions and semantic answers. Is useful for scenarios
        /// where there is a need to use different queries between the base retrieval and
        /// ranking phase, and the L2 semantic phase.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="indexName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="indexName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Documents.xml" path="doc/members/member[@name='SearchGetAsync(string,string,bool?,IEnumerable{string},string,IEnumerable{string},string,string,double?,IEnumerable{string},SearchQueryType?,IEnumerable{string},string,IEnumerable{string},SearchMode?,ScoringStatistics?,string,IEnumerable{string},int?,int?,string,SemanticErrorMode?,int?,QueryAnswerType?,QueryCaptionType?,string,CancellationToken)']/*" />
        public virtual async Task<Response<SearchDocumentsResult>> SearchGetAsync(string indexName, string searchText = null, bool? includeTotalResultCount = null, IEnumerable<string> facets = null, string filter = null, IEnumerable<string> highlightFields = null, string highlightPostTag = null, string highlightPreTag = null, double? minimumCoverage = null, IEnumerable<string> orderBy = null, SearchQueryType? queryType = null, IEnumerable<string> scoringParameters = null, string scoringProfile = null, IEnumerable<string> searchFields = null, SearchMode? searchMode = null, ScoringStatistics? scoringStatistics = null, string sessionId = null, IEnumerable<string> select = null, int? skip = null, int? top = null, string semanticConfiguration = null, SemanticErrorMode? semanticErrorHandling = null, int? semanticMaxWaitInMilliseconds = null, QueryAnswerType? answers = null, QueryCaptionType? captions = null, string semanticQuery = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(indexName, nameof(indexName));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await SearchGetAsync(indexName, searchText, includeTotalResultCount, facets, filter, highlightFields, highlightPostTag, highlightPreTag, minimumCoverage, orderBy, queryType?.ToSerialString(), scoringParameters, scoringProfile, searchFields, searchMode?.ToString(), scoringStatistics?.ToString(), sessionId, select, skip, top, semanticConfiguration, semanticErrorHandling?.ToString(), semanticMaxWaitInMilliseconds, answers?.ToString(), captions?.ToString(), semanticQuery, context).ConfigureAwait(false);
            return Response.FromValue(SearchDocumentsResult.FromResponse(response), response);
        }

        /// <summary> Searches for documents in the index. </summary>
        /// <param name="indexName"> The name of the index. </param>
        /// <param name="searchText">
        /// A full-text search query expression; Use "*" or omit this parameter to match
        /// all documents.
        /// </param>
        /// <param name="includeTotalResultCount">
        /// A value that specifies whether to fetch the total count of results. Default is
        /// false. Setting this value to true may have a performance impact. Note that the
        /// count returned is an approximation.
        /// </param>
        /// <param name="facets">
        /// The list of facet expressions to apply to the search query. Each facet
        /// expression contains a field name, optionally followed by a comma-separated list
        /// of name:value pairs.
        /// </param>
        /// <param name="filter"> The OData $filter expression to apply to the search query. </param>
        /// <param name="highlightFields">
        /// The list of field names to use for hit highlights. Only searchable fields can
        /// be used for hit highlighting.
        /// </param>
        /// <param name="highlightPostTag">
        /// A string tag that is appended to hit highlights. Must be set with
        /// highlightPreTag. Default is &lt;/em&gt;.
        /// </param>
        /// <param name="highlightPreTag">
        /// A string tag that is prepended to hit highlights. Must be set with
        /// highlightPostTag. Default is &lt;em&gt;.
        /// </param>
        /// <param name="minimumCoverage">
        /// A number between 0 and 100 indicating the percentage of the index that must be
        /// covered by a search query in order for the query to be reported as a success.
        /// This parameter can be useful for ensuring search availability even for services
        /// with only one replica. The default is 100.
        /// </param>
        /// <param name="orderBy">
        /// The list of OData $orderby expressions by which to sort the results. Each
        /// expression can be either a field name or a call to either the geo.distance() or
        /// the search.score() functions. Each expression can be followed by asc to
        /// indicate ascending, and desc to indicate descending. The default is ascending
        /// order. Ties will be broken by the match scores of documents. If no OrderBy is
        /// specified, the default sort order is descending by document match score. There
        /// can be at most 32 $orderby clauses.
        /// </param>
        /// <param name="queryType">
        /// A value that specifies the syntax of the search query. The default is 'simple'.
        /// Use 'full' if your query uses the Lucene query syntax.
        /// </param>
        /// <param name="scoringParameters">
        /// The list of parameter values to be used in scoring functions (for example,
        /// referencePointParameter) using the format name-values. For example, if the
        /// scoring profile defines a function with a parameter called 'mylocation' the
        /// parameter string would be "mylocation--122.2,44.8" (without the quotes).
        /// </param>
        /// <param name="scoringProfile">
        /// The name of a scoring profile to evaluate match scores for matching documents
        /// in order to sort the results.
        /// </param>
        /// <param name="searchFields">
        /// The list of field names to which to scope the full-text search. When using
        /// fielded search (fieldName:searchExpression) in a full Lucene query, the field
        /// names of each fielded search expression take precedence over any field names
        /// listed in this parameter.
        /// </param>
        /// <param name="searchMode">
        /// A value that specifies whether any or all of the search terms must be matched
        /// in order to count the document as a match.
        /// </param>
        /// <param name="scoringStatistics">
        /// A value that specifies whether we want to calculate scoring statistics (such as
        /// document frequency) globally for more consistent scoring, or locally, for lower
        /// latency.
        /// </param>
        /// <param name="sessionId">
        /// A value to be used to create a sticky session, which can help to get more
        /// consistent results. As long as the same sessionId is used, a best-effort
        /// attempt will be made to target the same replica set. Be wary that reusing the
        /// same sessionID values repeatedly can interfere with the load balancing of the
        /// requests across replicas and adversely affect the performance of the search
        /// service. The value used as sessionId cannot start with a '_' character.
        /// </param>
        /// <param name="select">
        /// The list of fields to retrieve. If unspecified, all fields marked as
        /// retrievable in the schema are included.
        /// </param>
        /// <param name="skip">
        /// The number of search results to skip. This value cannot be greater than
        /// 100,000. If you need to scan documents in sequence, but cannot use $skip due to
        /// this limitation, consider using $orderby on a totally-ordered key and $filter
        /// with a range query instead.
        /// </param>
        /// <param name="top">
        /// The number of search results to retrieve. This can be used in conjunction with
        /// $skip to implement client-side paging of search results. If results are
        /// truncated due to server-side paging, the response will include a continuation
        /// token that can be used to issue another Search request for the next page of
        /// results.
        /// </param>
        /// <param name="semanticConfiguration">
        /// The name of the semantic configuration that lists which fields should be used
        /// for semantic ranking, captions, highlights, and answers
        /// </param>
        /// <param name="semanticErrorHandling">
        /// Allows the user to choose whether a semantic call should fail completely, or to
        /// return partial results (default).
        /// </param>
        /// <param name="semanticMaxWaitInMilliseconds">
        /// Allows the user to set an upper bound on the amount of time it takes for
        /// semantic enrichment to finish processing before the request fails.
        /// </param>
        /// <param name="answers">
        /// This parameter is only valid if the query type is `semantic`. If set, the query
        /// returns answers extracted from key passages in the highest ranked documents.
        /// The number of answers returned can be configured by appending the pipe
        /// character `|` followed by the `count-&lt;number of answers&gt;` option after the
        /// answers parameter value, such as `extractive|count-3`. Default count is 1. The
        /// confidence threshold can be configured by appending the pipe character `|`
        /// followed by the `threshold-&lt;confidence threshold&gt;` option after the answers
        /// parameter value, such as `extractive|threshold-0.9`. Default threshold is 0.7.
        /// </param>
        /// <param name="captions">
        /// This parameter is only valid if the query type is `semantic`. If set, the query
        /// returns captions extracted from key passages in the highest ranked documents.
        /// When Captions is set to `extractive`, highlighting is enabled by default, and
        /// can be configured by appending the pipe character `|` followed by the
        /// `highlight-&lt;true/false&gt;` option, such as `extractive|highlight-true`. Defaults
        /// to `None`.
        /// </param>
        /// <param name="semanticQuery">
        /// Allows setting a separate search query that will be solely used for semantic
        /// reranking, semantic captions and semantic answers. Is useful for scenarios
        /// where there is a need to use different queries between the base retrieval and
        /// ranking phase, and the L2 semantic phase.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="indexName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="indexName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Documents.xml" path="doc/members/member[@name='SearchGet(string,string,bool?,IEnumerable{string},string,IEnumerable{string},string,string,double?,IEnumerable{string},SearchQueryType?,IEnumerable{string},string,IEnumerable{string},SearchMode?,ScoringStatistics?,string,IEnumerable{string},int?,int?,string,SemanticErrorMode?,int?,QueryAnswerType?,QueryCaptionType?,string,CancellationToken)']/*" />
        public virtual Response<SearchDocumentsResult> SearchGet(string indexName, string searchText = null, bool? includeTotalResultCount = null, IEnumerable<string> facets = null, string filter = null, IEnumerable<string> highlightFields = null, string highlightPostTag = null, string highlightPreTag = null, double? minimumCoverage = null, IEnumerable<string> orderBy = null, SearchQueryType? queryType = null, IEnumerable<string> scoringParameters = null, string scoringProfile = null, IEnumerable<string> searchFields = null, SearchMode? searchMode = null, ScoringStatistics? scoringStatistics = null, string sessionId = null, IEnumerable<string> select = null, int? skip = null, int? top = null, string semanticConfiguration = null, SemanticErrorMode? semanticErrorHandling = null, int? semanticMaxWaitInMilliseconds = null, QueryAnswerType? answers = null, QueryCaptionType? captions = null, string semanticQuery = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(indexName, nameof(indexName));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = SearchGet(indexName, searchText, includeTotalResultCount, facets, filter, highlightFields, highlightPostTag, highlightPreTag, minimumCoverage, orderBy, queryType?.ToSerialString(), scoringParameters, scoringProfile, searchFields, searchMode?.ToString(), scoringStatistics?.ToString(), sessionId, select, skip, top, semanticConfiguration, semanticErrorHandling?.ToString(), semanticMaxWaitInMilliseconds, answers?.ToString(), captions?.ToString(), semanticQuery, context);
            return Response.FromValue(SearchDocumentsResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Searches for documents in the index.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="SearchGetAsync(string,string,bool?,IEnumerable{string},string,IEnumerable{string},string,string,double?,IEnumerable{string},SearchQueryType?,IEnumerable{string},string,IEnumerable{string},SearchMode?,ScoringStatistics?,string,IEnumerable{string},int?,int?,string,SemanticErrorMode?,int?,QueryAnswerType?,QueryCaptionType?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="indexName"> The name of the index. </param>
        /// <param name="searchText">
        /// A full-text search query expression; Use "*" or omit this parameter to match
        /// all documents.
        /// </param>
        /// <param name="includeTotalResultCount">
        /// A value that specifies whether to fetch the total count of results. Default is
        /// false. Setting this value to true may have a performance impact. Note that the
        /// count returned is an approximation.
        /// </param>
        /// <param name="facets">
        /// The list of facet expressions to apply to the search query. Each facet
        /// expression contains a field name, optionally followed by a comma-separated list
        /// of name:value pairs.
        /// </param>
        /// <param name="filter"> The OData $filter expression to apply to the search query. </param>
        /// <param name="highlightFields">
        /// The list of field names to use for hit highlights. Only searchable fields can
        /// be used for hit highlighting.
        /// </param>
        /// <param name="highlightPostTag">
        /// A string tag that is appended to hit highlights. Must be set with
        /// highlightPreTag. Default is &lt;/em&gt;.
        /// </param>
        /// <param name="highlightPreTag">
        /// A string tag that is prepended to hit highlights. Must be set with
        /// highlightPostTag. Default is &lt;em&gt;.
        /// </param>
        /// <param name="minimumCoverage">
        /// A number between 0 and 100 indicating the percentage of the index that must be
        /// covered by a search query in order for the query to be reported as a success.
        /// This parameter can be useful for ensuring search availability even for services
        /// with only one replica. The default is 100.
        /// </param>
        /// <param name="orderBy">
        /// The list of OData $orderby expressions by which to sort the results. Each
        /// expression can be either a field name or a call to either the geo.distance() or
        /// the search.score() functions. Each expression can be followed by asc to
        /// indicate ascending, and desc to indicate descending. The default is ascending
        /// order. Ties will be broken by the match scores of documents. If no OrderBy is
        /// specified, the default sort order is descending by document match score. There
        /// can be at most 32 $orderby clauses.
        /// </param>
        /// <param name="queryType">
        /// A value that specifies the syntax of the search query. The default is 'simple'.
        /// Use 'full' if your query uses the Lucene query syntax. Allowed values: "simple" | "full" | "semantic"
        /// </param>
        /// <param name="scoringParameters">
        /// The list of parameter values to be used in scoring functions (for example,
        /// referencePointParameter) using the format name-values. For example, if the
        /// scoring profile defines a function with a parameter called 'mylocation' the
        /// parameter string would be "mylocation--122.2,44.8" (without the quotes).
        /// </param>
        /// <param name="scoringProfile">
        /// The name of a scoring profile to evaluate match scores for matching documents
        /// in order to sort the results.
        /// </param>
        /// <param name="searchFields">
        /// The list of field names to which to scope the full-text search. When using
        /// fielded search (fieldName:searchExpression) in a full Lucene query, the field
        /// names of each fielded search expression take precedence over any field names
        /// listed in this parameter.
        /// </param>
        /// <param name="searchMode">
        /// A value that specifies whether any or all of the search terms must be matched
        /// in order to count the document as a match. Allowed values: "any" | "all"
        /// </param>
        /// <param name="scoringStatistics">
        /// A value that specifies whether we want to calculate scoring statistics (such as
        /// document frequency) globally for more consistent scoring, or locally, for lower
        /// latency. Allowed values: "local" | "global"
        /// </param>
        /// <param name="sessionId">
        /// A value to be used to create a sticky session, which can help to get more
        /// consistent results. As long as the same sessionId is used, a best-effort
        /// attempt will be made to target the same replica set. Be wary that reusing the
        /// same sessionID values repeatedly can interfere with the load balancing of the
        /// requests across replicas and adversely affect the performance of the search
        /// service. The value used as sessionId cannot start with a '_' character.
        /// </param>
        /// <param name="select">
        /// The list of fields to retrieve. If unspecified, all fields marked as
        /// retrievable in the schema are included.
        /// </param>
        /// <param name="skip">
        /// The number of search results to skip. This value cannot be greater than
        /// 100,000. If you need to scan documents in sequence, but cannot use $skip due to
        /// this limitation, consider using $orderby on a totally-ordered key and $filter
        /// with a range query instead.
        /// </param>
        /// <param name="top">
        /// The number of search results to retrieve. This can be used in conjunction with
        /// $skip to implement client-side paging of search results. If results are
        /// truncated due to server-side paging, the response will include a continuation
        /// token that can be used to issue another Search request for the next page of
        /// results.
        /// </param>
        /// <param name="semanticConfiguration">
        /// The name of the semantic configuration that lists which fields should be used
        /// for semantic ranking, captions, highlights, and answers
        /// </param>
        /// <param name="semanticErrorHandling">
        /// Allows the user to choose whether a semantic call should fail completely, or to
        /// return partial results (default). Allowed values: "partial" | "fail"
        /// </param>
        /// <param name="semanticMaxWaitInMilliseconds">
        /// Allows the user to set an upper bound on the amount of time it takes for
        /// semantic enrichment to finish processing before the request fails.
        /// </param>
        /// <param name="answers">
        /// This parameter is only valid if the query type is `semantic`. If set, the query
        /// returns answers extracted from key passages in the highest ranked documents.
        /// The number of answers returned can be configured by appending the pipe
        /// character `|` followed by the `count-&lt;number of answers&gt;` option after the
        /// answers parameter value, such as `extractive|count-3`. Default count is 1. The
        /// confidence threshold can be configured by appending the pipe character `|`
        /// followed by the `threshold-&lt;confidence threshold&gt;` option after the answers
        /// parameter value, such as `extractive|threshold-0.9`. Default threshold is 0.7. Allowed values: "none" | "extractive"
        /// </param>
        /// <param name="captions">
        /// This parameter is only valid if the query type is `semantic`. If set, the query
        /// returns captions extracted from key passages in the highest ranked documents.
        /// When Captions is set to `extractive`, highlighting is enabled by default, and
        /// can be configured by appending the pipe character `|` followed by the
        /// `highlight-&lt;true/false&gt;` option, such as `extractive|highlight-true`. Defaults
        /// to `None`. Allowed values: "none" | "extractive"
        /// </param>
        /// <param name="semanticQuery">
        /// Allows setting a separate search query that will be solely used for semantic
        /// reranking, semantic captions and semantic answers. Is useful for scenarios
        /// where there is a need to use different queries between the base retrieval and
        /// ranking phase, and the L2 semantic phase.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="indexName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="indexName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Documents.xml" path="doc/members/member[@name='SearchGetAsync(string,string,bool?,IEnumerable{string},string,IEnumerable{string},string,string,double?,IEnumerable{string},string,IEnumerable{string},string,IEnumerable{string},string,string,string,IEnumerable{string},int?,int?,string,string,int?,string,string,string,RequestContext)']/*" />
        public virtual async Task<Response> SearchGetAsync(string indexName, string searchText, bool? includeTotalResultCount, IEnumerable<string> facets, string filter, IEnumerable<string> highlightFields, string highlightPostTag, string highlightPreTag, double? minimumCoverage, IEnumerable<string> orderBy, string queryType, IEnumerable<string> scoringParameters, string scoringProfile, IEnumerable<string> searchFields, string searchMode, string scoringStatistics, string sessionId, IEnumerable<string> select, int? skip, int? top, string semanticConfiguration, string semanticErrorHandling, int? semanticMaxWaitInMilliseconds, string answers, string captions, string semanticQuery, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(indexName, nameof(indexName));

            using var scope = ClientDiagnostics.CreateScope("Documents.SearchGet");
            scope.Start();
            try
            {
                using HttpMessage message = CreateSearchGetRequest(indexName, searchText, includeTotalResultCount, facets, filter, highlightFields, highlightPostTag, highlightPreTag, minimumCoverage, orderBy, queryType, scoringParameters, scoringProfile, searchFields, searchMode, scoringStatistics, sessionId, select, skip, top, semanticConfiguration, semanticErrorHandling, semanticMaxWaitInMilliseconds, answers, captions, semanticQuery, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Searches for documents in the index.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="SearchGet(string,string,bool?,IEnumerable{string},string,IEnumerable{string},string,string,double?,IEnumerable{string},SearchQueryType?,IEnumerable{string},string,IEnumerable{string},SearchMode?,ScoringStatistics?,string,IEnumerable{string},int?,int?,string,SemanticErrorMode?,int?,QueryAnswerType?,QueryCaptionType?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="indexName"> The name of the index. </param>
        /// <param name="searchText">
        /// A full-text search query expression; Use "*" or omit this parameter to match
        /// all documents.
        /// </param>
        /// <param name="includeTotalResultCount">
        /// A value that specifies whether to fetch the total count of results. Default is
        /// false. Setting this value to true may have a performance impact. Note that the
        /// count returned is an approximation.
        /// </param>
        /// <param name="facets">
        /// The list of facet expressions to apply to the search query. Each facet
        /// expression contains a field name, optionally followed by a comma-separated list
        /// of name:value pairs.
        /// </param>
        /// <param name="filter"> The OData $filter expression to apply to the search query. </param>
        /// <param name="highlightFields">
        /// The list of field names to use for hit highlights. Only searchable fields can
        /// be used for hit highlighting.
        /// </param>
        /// <param name="highlightPostTag">
        /// A string tag that is appended to hit highlights. Must be set with
        /// highlightPreTag. Default is &lt;/em&gt;.
        /// </param>
        /// <param name="highlightPreTag">
        /// A string tag that is prepended to hit highlights. Must be set with
        /// highlightPostTag. Default is &lt;em&gt;.
        /// </param>
        /// <param name="minimumCoverage">
        /// A number between 0 and 100 indicating the percentage of the index that must be
        /// covered by a search query in order for the query to be reported as a success.
        /// This parameter can be useful for ensuring search availability even for services
        /// with only one replica. The default is 100.
        /// </param>
        /// <param name="orderBy">
        /// The list of OData $orderby expressions by which to sort the results. Each
        /// expression can be either a field name or a call to either the geo.distance() or
        /// the search.score() functions. Each expression can be followed by asc to
        /// indicate ascending, and desc to indicate descending. The default is ascending
        /// order. Ties will be broken by the match scores of documents. If no OrderBy is
        /// specified, the default sort order is descending by document match score. There
        /// can be at most 32 $orderby clauses.
        /// </param>
        /// <param name="queryType">
        /// A value that specifies the syntax of the search query. The default is 'simple'.
        /// Use 'full' if your query uses the Lucene query syntax. Allowed values: "simple" | "full" | "semantic"
        /// </param>
        /// <param name="scoringParameters">
        /// The list of parameter values to be used in scoring functions (for example,
        /// referencePointParameter) using the format name-values. For example, if the
        /// scoring profile defines a function with a parameter called 'mylocation' the
        /// parameter string would be "mylocation--122.2,44.8" (without the quotes).
        /// </param>
        /// <param name="scoringProfile">
        /// The name of a scoring profile to evaluate match scores for matching documents
        /// in order to sort the results.
        /// </param>
        /// <param name="searchFields">
        /// The list of field names to which to scope the full-text search. When using
        /// fielded search (fieldName:searchExpression) in a full Lucene query, the field
        /// names of each fielded search expression take precedence over any field names
        /// listed in this parameter.
        /// </param>
        /// <param name="searchMode">
        /// A value that specifies whether any or all of the search terms must be matched
        /// in order to count the document as a match. Allowed values: "any" | "all"
        /// </param>
        /// <param name="scoringStatistics">
        /// A value that specifies whether we want to calculate scoring statistics (such as
        /// document frequency) globally for more consistent scoring, or locally, for lower
        /// latency. Allowed values: "local" | "global"
        /// </param>
        /// <param name="sessionId">
        /// A value to be used to create a sticky session, which can help to get more
        /// consistent results. As long as the same sessionId is used, a best-effort
        /// attempt will be made to target the same replica set. Be wary that reusing the
        /// same sessionID values repeatedly can interfere with the load balancing of the
        /// requests across replicas and adversely affect the performance of the search
        /// service. The value used as sessionId cannot start with a '_' character.
        /// </param>
        /// <param name="select">
        /// The list of fields to retrieve. If unspecified, all fields marked as
        /// retrievable in the schema are included.
        /// </param>
        /// <param name="skip">
        /// The number of search results to skip. This value cannot be greater than
        /// 100,000. If you need to scan documents in sequence, but cannot use $skip due to
        /// this limitation, consider using $orderby on a totally-ordered key and $filter
        /// with a range query instead.
        /// </param>
        /// <param name="top">
        /// The number of search results to retrieve. This can be used in conjunction with
        /// $skip to implement client-side paging of search results. If results are
        /// truncated due to server-side paging, the response will include a continuation
        /// token that can be used to issue another Search request for the next page of
        /// results.
        /// </param>
        /// <param name="semanticConfiguration">
        /// The name of the semantic configuration that lists which fields should be used
        /// for semantic ranking, captions, highlights, and answers
        /// </param>
        /// <param name="semanticErrorHandling">
        /// Allows the user to choose whether a semantic call should fail completely, or to
        /// return partial results (default). Allowed values: "partial" | "fail"
        /// </param>
        /// <param name="semanticMaxWaitInMilliseconds">
        /// Allows the user to set an upper bound on the amount of time it takes for
        /// semantic enrichment to finish processing before the request fails.
        /// </param>
        /// <param name="answers">
        /// This parameter is only valid if the query type is `semantic`. If set, the query
        /// returns answers extracted from key passages in the highest ranked documents.
        /// The number of answers returned can be configured by appending the pipe
        /// character `|` followed by the `count-&lt;number of answers&gt;` option after the
        /// answers parameter value, such as `extractive|count-3`. Default count is 1. The
        /// confidence threshold can be configured by appending the pipe character `|`
        /// followed by the `threshold-&lt;confidence threshold&gt;` option after the answers
        /// parameter value, such as `extractive|threshold-0.9`. Default threshold is 0.7. Allowed values: "none" | "extractive"
        /// </param>
        /// <param name="captions">
        /// This parameter is only valid if the query type is `semantic`. If set, the query
        /// returns captions extracted from key passages in the highest ranked documents.
        /// When Captions is set to `extractive`, highlighting is enabled by default, and
        /// can be configured by appending the pipe character `|` followed by the
        /// `highlight-&lt;true/false&gt;` option, such as `extractive|highlight-true`. Defaults
        /// to `None`. Allowed values: "none" | "extractive"
        /// </param>
        /// <param name="semanticQuery">
        /// Allows setting a separate search query that will be solely used for semantic
        /// reranking, semantic captions and semantic answers. Is useful for scenarios
        /// where there is a need to use different queries between the base retrieval and
        /// ranking phase, and the L2 semantic phase.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="indexName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="indexName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Documents.xml" path="doc/members/member[@name='SearchGet(string,string,bool?,IEnumerable{string},string,IEnumerable{string},string,string,double?,IEnumerable{string},string,IEnumerable{string},string,IEnumerable{string},string,string,string,IEnumerable{string},int?,int?,string,string,int?,string,string,string,RequestContext)']/*" />
        public virtual Response SearchGet(string indexName, string searchText, bool? includeTotalResultCount, IEnumerable<string> facets, string filter, IEnumerable<string> highlightFields, string highlightPostTag, string highlightPreTag, double? minimumCoverage, IEnumerable<string> orderBy, string queryType, IEnumerable<string> scoringParameters, string scoringProfile, IEnumerable<string> searchFields, string searchMode, string scoringStatistics, string sessionId, IEnumerable<string> select, int? skip, int? top, string semanticConfiguration, string semanticErrorHandling, int? semanticMaxWaitInMilliseconds, string answers, string captions, string semanticQuery, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(indexName, nameof(indexName));

            using var scope = ClientDiagnostics.CreateScope("Documents.SearchGet");
            scope.Start();
            try
            {
                using HttpMessage message = CreateSearchGetRequest(indexName, searchText, includeTotalResultCount, facets, filter, highlightFields, highlightPostTag, highlightPreTag, minimumCoverage, orderBy, queryType, scoringParameters, scoringProfile, searchFields, searchMode, scoringStatistics, sessionId, select, skip, top, semanticConfiguration, semanticErrorHandling, semanticMaxWaitInMilliseconds, answers, captions, semanticQuery, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Searches for documents in the index. </summary>
        /// <param name="indexName"> The name of the index. </param>
        /// <param name="searchOptions"> The definition of the Search request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="indexName"/> or <paramref name="searchOptions"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="indexName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Documents.xml" path="doc/members/member[@name='SearchPostAsync(string,SearchOptions,CancellationToken)']/*" />
        public virtual async Task<Response<SearchDocumentsResult>> SearchPostAsync(string indexName, SearchOptions searchOptions, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(indexName, nameof(indexName));
            Argument.AssertNotNull(searchOptions, nameof(searchOptions));

            using RequestContent content = searchOptions.ToRequestContent();
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await SearchPostAsync(indexName, content, context).ConfigureAwait(false);
            return Response.FromValue(SearchDocumentsResult.FromResponse(response), response);
        }

        /// <summary> Searches for documents in the index. </summary>
        /// <param name="indexName"> The name of the index. </param>
        /// <param name="searchOptions"> The definition of the Search request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="indexName"/> or <paramref name="searchOptions"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="indexName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Documents.xml" path="doc/members/member[@name='SearchPost(string,SearchOptions,CancellationToken)']/*" />
        public virtual Response<SearchDocumentsResult> SearchPost(string indexName, SearchOptions searchOptions, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(indexName, nameof(indexName));
            Argument.AssertNotNull(searchOptions, nameof(searchOptions));

            using RequestContent content = searchOptions.ToRequestContent();
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = SearchPost(indexName, content, context);
            return Response.FromValue(SearchDocumentsResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Searches for documents in the index.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="SearchPostAsync(string,SearchOptions,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="indexName"> The name of the index. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="indexName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="indexName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Documents.xml" path="doc/members/member[@name='SearchPostAsync(string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> SearchPostAsync(string indexName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(indexName, nameof(indexName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Documents.SearchPost");
            scope.Start();
            try
            {
                using HttpMessage message = CreateSearchPostRequest(indexName, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Searches for documents in the index.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="SearchPost(string,SearchOptions,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="indexName"> The name of the index. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="indexName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="indexName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Documents.xml" path="doc/members/member[@name='SearchPost(string,RequestContent,RequestContext)']/*" />
        public virtual Response SearchPost(string indexName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(indexName, nameof(indexName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Documents.SearchPost");
            scope.Start();
            try
            {
                using HttpMessage message = CreateSearchPostRequest(indexName, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieves a document from the index. </summary>
        /// <param name="indexName"> The name of the index. </param>
        /// <param name="key"> The key of the document to retrieve. </param>
        /// <param name="selectedFields">
        /// List of field names to retrieve for the document; Any field not retrieved will
        /// be missing from the returned document.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="indexName"/> or <paramref name="key"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="indexName"/> or <paramref name="key"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Documents.xml" path="doc/members/member[@name='GetDocumentAsync(string,string,IEnumerable{string},CancellationToken)']/*" />
        public virtual async Task<Response<LookupDocument>> GetDocumentAsync(string indexName, string key, IEnumerable<string> selectedFields = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(indexName, nameof(indexName));
            Argument.AssertNotNullOrEmpty(key, nameof(key));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetDocumentAsync(indexName, key, selectedFields, context).ConfigureAwait(false);
            return Response.FromValue(LookupDocument.FromResponse(response), response);
        }

        /// <summary> Retrieves a document from the index. </summary>
        /// <param name="indexName"> The name of the index. </param>
        /// <param name="key"> The key of the document to retrieve. </param>
        /// <param name="selectedFields">
        /// List of field names to retrieve for the document; Any field not retrieved will
        /// be missing from the returned document.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="indexName"/> or <paramref name="key"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="indexName"/> or <paramref name="key"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Documents.xml" path="doc/members/member[@name='GetDocument(string,string,IEnumerable{string},CancellationToken)']/*" />
        public virtual Response<LookupDocument> GetDocument(string indexName, string key, IEnumerable<string> selectedFields = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(indexName, nameof(indexName));
            Argument.AssertNotNullOrEmpty(key, nameof(key));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetDocument(indexName, key, selectedFields, context);
            return Response.FromValue(LookupDocument.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Retrieves a document from the index.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDocumentAsync(string,string,IEnumerable{string},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="indexName"> The name of the index. </param>
        /// <param name="key"> The key of the document to retrieve. </param>
        /// <param name="selectedFields">
        /// List of field names to retrieve for the document; Any field not retrieved will
        /// be missing from the returned document.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="indexName"/> or <paramref name="key"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="indexName"/> or <paramref name="key"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Documents.xml" path="doc/members/member[@name='GetDocumentAsync(string,string,IEnumerable{string},RequestContext)']/*" />
        public virtual async Task<Response> GetDocumentAsync(string indexName, string key, IEnumerable<string> selectedFields, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(indexName, nameof(indexName));
            Argument.AssertNotNullOrEmpty(key, nameof(key));

            using var scope = ClientDiagnostics.CreateScope("Documents.GetDocument");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDocumentRequest(indexName, key, selectedFields, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Retrieves a document from the index.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDocument(string,string,IEnumerable{string},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="indexName"> The name of the index. </param>
        /// <param name="key"> The key of the document to retrieve. </param>
        /// <param name="selectedFields">
        /// List of field names to retrieve for the document; Any field not retrieved will
        /// be missing from the returned document.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="indexName"/> or <paramref name="key"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="indexName"/> or <paramref name="key"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Documents.xml" path="doc/members/member[@name='GetDocument(string,string,IEnumerable{string},RequestContext)']/*" />
        public virtual Response GetDocument(string indexName, string key, IEnumerable<string> selectedFields, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(indexName, nameof(indexName));
            Argument.AssertNotNullOrEmpty(key, nameof(key));

            using var scope = ClientDiagnostics.CreateScope("Documents.GetDocument");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDocumentRequest(indexName, key, selectedFields, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Suggests documents in the index that match the given partial query text. </summary>
        /// <param name="indexName"> The name of the index. </param>
        /// <param name="searchText">
        /// The search text to use to suggest documents. Must be at least 1 character, and
        /// no more than 100 characters.
        /// </param>
        /// <param name="suggesterName">
        /// The name of the suggester as specified in the suggesters collection that's part
        /// of the index definition.
        /// </param>
        /// <param name="filter"> An OData expression that filters the documents considered for suggestions. </param>
        /// <param name="useFuzzyMatching">
        /// A value indicating whether to use fuzzy matching for the suggestions query.
        /// Default is false. When set to true, the query will find terms even if there's a
        /// substituted or missing character in the search text. While this provides a
        /// better experience in some scenarios, it comes at a performance cost as fuzzy
        /// suggestions queries are slower and consume more resources.
        /// </param>
        /// <param name="highlightPostTag">
        /// A string tag that is appended to hit highlights. Must be set with
        /// highlightPreTag. If omitted, hit highlighting of suggestions is disabled.
        /// </param>
        /// <param name="highlightPreTag">
        /// A string tag that is prepended to hit highlights. Must be set with
        /// highlightPostTag. If omitted, hit highlighting of suggestions is disabled.
        /// </param>
        /// <param name="minimumCoverage">
        /// A number between 0 and 100 indicating the percentage of the index that must be
        /// covered by a suggestions query in order for the query to be reported as a
        /// success. This parameter can be useful for ensuring search availability even for
        /// services with only one replica. The default is 80.
        /// </param>
        /// <param name="orderBy">
        /// The list of OData $orderby expressions by which to sort the results. Each
        /// expression can be either a field name or a call to either the geo.distance() or
        /// the search.score() functions. Each expression can be followed by asc to
        /// indicate ascending, or desc to indicate descending. The default is ascending
        /// order. Ties will be broken by the match scores of documents. If no $orderby is
        /// specified, the default sort order is descending by document match score. There
        /// can be at most 32 $orderby clauses.
        /// </param>
        /// <param name="searchFields">
        /// The list of field names to search for the specified search text. Target fields
        /// must be included in the specified suggester.
        /// </param>
        /// <param name="select">
        /// The list of fields to retrieve. If unspecified, only the key field will be
        /// included in the results.
        /// </param>
        /// <param name="top">
        /// The number of suggestions to retrieve. The value must be a number between 1 and
        /// 100. The default is 5.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="indexName"/>, <paramref name="searchText"/> or <paramref name="suggesterName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="indexName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Documents.xml" path="doc/members/member[@name='SuggestGetAsync(string,string,string,string,bool?,string,string,double?,IEnumerable{string},IEnumerable{string},IEnumerable{string},int?,CancellationToken)']/*" />
        public virtual async Task<Response<SuggestDocumentsResult>> SuggestGetAsync(string indexName, string searchText, string suggesterName, string filter = null, bool? useFuzzyMatching = null, string highlightPostTag = null, string highlightPreTag = null, double? minimumCoverage = null, IEnumerable<string> orderBy = null, IEnumerable<string> searchFields = null, IEnumerable<string> select = null, int? top = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(indexName, nameof(indexName));
            Argument.AssertNotNull(searchText, nameof(searchText));
            Argument.AssertNotNull(suggesterName, nameof(suggesterName));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await SuggestGetAsync(indexName, searchText, suggesterName, filter, useFuzzyMatching, highlightPostTag, highlightPreTag, minimumCoverage, orderBy, searchFields, select, top, context).ConfigureAwait(false);
            return Response.FromValue(SuggestDocumentsResult.FromResponse(response), response);
        }

        /// <summary> Suggests documents in the index that match the given partial query text. </summary>
        /// <param name="indexName"> The name of the index. </param>
        /// <param name="searchText">
        /// The search text to use to suggest documents. Must be at least 1 character, and
        /// no more than 100 characters.
        /// </param>
        /// <param name="suggesterName">
        /// The name of the suggester as specified in the suggesters collection that's part
        /// of the index definition.
        /// </param>
        /// <param name="filter"> An OData expression that filters the documents considered for suggestions. </param>
        /// <param name="useFuzzyMatching">
        /// A value indicating whether to use fuzzy matching for the suggestions query.
        /// Default is false. When set to true, the query will find terms even if there's a
        /// substituted or missing character in the search text. While this provides a
        /// better experience in some scenarios, it comes at a performance cost as fuzzy
        /// suggestions queries are slower and consume more resources.
        /// </param>
        /// <param name="highlightPostTag">
        /// A string tag that is appended to hit highlights. Must be set with
        /// highlightPreTag. If omitted, hit highlighting of suggestions is disabled.
        /// </param>
        /// <param name="highlightPreTag">
        /// A string tag that is prepended to hit highlights. Must be set with
        /// highlightPostTag. If omitted, hit highlighting of suggestions is disabled.
        /// </param>
        /// <param name="minimumCoverage">
        /// A number between 0 and 100 indicating the percentage of the index that must be
        /// covered by a suggestions query in order for the query to be reported as a
        /// success. This parameter can be useful for ensuring search availability even for
        /// services with only one replica. The default is 80.
        /// </param>
        /// <param name="orderBy">
        /// The list of OData $orderby expressions by which to sort the results. Each
        /// expression can be either a field name or a call to either the geo.distance() or
        /// the search.score() functions. Each expression can be followed by asc to
        /// indicate ascending, or desc to indicate descending. The default is ascending
        /// order. Ties will be broken by the match scores of documents. If no $orderby is
        /// specified, the default sort order is descending by document match score. There
        /// can be at most 32 $orderby clauses.
        /// </param>
        /// <param name="searchFields">
        /// The list of field names to search for the specified search text. Target fields
        /// must be included in the specified suggester.
        /// </param>
        /// <param name="select">
        /// The list of fields to retrieve. If unspecified, only the key field will be
        /// included in the results.
        /// </param>
        /// <param name="top">
        /// The number of suggestions to retrieve. The value must be a number between 1 and
        /// 100. The default is 5.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="indexName"/>, <paramref name="searchText"/> or <paramref name="suggesterName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="indexName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Documents.xml" path="doc/members/member[@name='SuggestGet(string,string,string,string,bool?,string,string,double?,IEnumerable{string},IEnumerable{string},IEnumerable{string},int?,CancellationToken)']/*" />
        public virtual Response<SuggestDocumentsResult> SuggestGet(string indexName, string searchText, string suggesterName, string filter = null, bool? useFuzzyMatching = null, string highlightPostTag = null, string highlightPreTag = null, double? minimumCoverage = null, IEnumerable<string> orderBy = null, IEnumerable<string> searchFields = null, IEnumerable<string> select = null, int? top = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(indexName, nameof(indexName));
            Argument.AssertNotNull(searchText, nameof(searchText));
            Argument.AssertNotNull(suggesterName, nameof(suggesterName));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = SuggestGet(indexName, searchText, suggesterName, filter, useFuzzyMatching, highlightPostTag, highlightPreTag, minimumCoverage, orderBy, searchFields, select, top, context);
            return Response.FromValue(SuggestDocumentsResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Suggests documents in the index that match the given partial query text.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="SuggestGetAsync(string,string,string,string,bool?,string,string,double?,IEnumerable{string},IEnumerable{string},IEnumerable{string},int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="indexName"> The name of the index. </param>
        /// <param name="searchText">
        /// The search text to use to suggest documents. Must be at least 1 character, and
        /// no more than 100 characters.
        /// </param>
        /// <param name="suggesterName">
        /// The name of the suggester as specified in the suggesters collection that's part
        /// of the index definition.
        /// </param>
        /// <param name="filter"> An OData expression that filters the documents considered for suggestions. </param>
        /// <param name="useFuzzyMatching">
        /// A value indicating whether to use fuzzy matching for the suggestions query.
        /// Default is false. When set to true, the query will find terms even if there's a
        /// substituted or missing character in the search text. While this provides a
        /// better experience in some scenarios, it comes at a performance cost as fuzzy
        /// suggestions queries are slower and consume more resources.
        /// </param>
        /// <param name="highlightPostTag">
        /// A string tag that is appended to hit highlights. Must be set with
        /// highlightPreTag. If omitted, hit highlighting of suggestions is disabled.
        /// </param>
        /// <param name="highlightPreTag">
        /// A string tag that is prepended to hit highlights. Must be set with
        /// highlightPostTag. If omitted, hit highlighting of suggestions is disabled.
        /// </param>
        /// <param name="minimumCoverage">
        /// A number between 0 and 100 indicating the percentage of the index that must be
        /// covered by a suggestions query in order for the query to be reported as a
        /// success. This parameter can be useful for ensuring search availability even for
        /// services with only one replica. The default is 80.
        /// </param>
        /// <param name="orderBy">
        /// The list of OData $orderby expressions by which to sort the results. Each
        /// expression can be either a field name or a call to either the geo.distance() or
        /// the search.score() functions. Each expression can be followed by asc to
        /// indicate ascending, or desc to indicate descending. The default is ascending
        /// order. Ties will be broken by the match scores of documents. If no $orderby is
        /// specified, the default sort order is descending by document match score. There
        /// can be at most 32 $orderby clauses.
        /// </param>
        /// <param name="searchFields">
        /// The list of field names to search for the specified search text. Target fields
        /// must be included in the specified suggester.
        /// </param>
        /// <param name="select">
        /// The list of fields to retrieve. If unspecified, only the key field will be
        /// included in the results.
        /// </param>
        /// <param name="top">
        /// The number of suggestions to retrieve. The value must be a number between 1 and
        /// 100. The default is 5.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="indexName"/>, <paramref name="searchText"/> or <paramref name="suggesterName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="indexName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Documents.xml" path="doc/members/member[@name='SuggestGetAsync(string,string,string,string,bool?,string,string,double?,IEnumerable{string},IEnumerable{string},IEnumerable{string},int?,RequestContext)']/*" />
        public virtual async Task<Response> SuggestGetAsync(string indexName, string searchText, string suggesterName, string filter, bool? useFuzzyMatching, string highlightPostTag, string highlightPreTag, double? minimumCoverage, IEnumerable<string> orderBy, IEnumerable<string> searchFields, IEnumerable<string> select, int? top, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(indexName, nameof(indexName));
            Argument.AssertNotNull(searchText, nameof(searchText));
            Argument.AssertNotNull(suggesterName, nameof(suggesterName));

            using var scope = ClientDiagnostics.CreateScope("Documents.SuggestGet");
            scope.Start();
            try
            {
                using HttpMessage message = CreateSuggestGetRequest(indexName, searchText, suggesterName, filter, useFuzzyMatching, highlightPostTag, highlightPreTag, minimumCoverage, orderBy, searchFields, select, top, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Suggests documents in the index that match the given partial query text.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="SuggestGet(string,string,string,string,bool?,string,string,double?,IEnumerable{string},IEnumerable{string},IEnumerable{string},int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="indexName"> The name of the index. </param>
        /// <param name="searchText">
        /// The search text to use to suggest documents. Must be at least 1 character, and
        /// no more than 100 characters.
        /// </param>
        /// <param name="suggesterName">
        /// The name of the suggester as specified in the suggesters collection that's part
        /// of the index definition.
        /// </param>
        /// <param name="filter"> An OData expression that filters the documents considered for suggestions. </param>
        /// <param name="useFuzzyMatching">
        /// A value indicating whether to use fuzzy matching for the suggestions query.
        /// Default is false. When set to true, the query will find terms even if there's a
        /// substituted or missing character in the search text. While this provides a
        /// better experience in some scenarios, it comes at a performance cost as fuzzy
        /// suggestions queries are slower and consume more resources.
        /// </param>
        /// <param name="highlightPostTag">
        /// A string tag that is appended to hit highlights. Must be set with
        /// highlightPreTag. If omitted, hit highlighting of suggestions is disabled.
        /// </param>
        /// <param name="highlightPreTag">
        /// A string tag that is prepended to hit highlights. Must be set with
        /// highlightPostTag. If omitted, hit highlighting of suggestions is disabled.
        /// </param>
        /// <param name="minimumCoverage">
        /// A number between 0 and 100 indicating the percentage of the index that must be
        /// covered by a suggestions query in order for the query to be reported as a
        /// success. This parameter can be useful for ensuring search availability even for
        /// services with only one replica. The default is 80.
        /// </param>
        /// <param name="orderBy">
        /// The list of OData $orderby expressions by which to sort the results. Each
        /// expression can be either a field name or a call to either the geo.distance() or
        /// the search.score() functions. Each expression can be followed by asc to
        /// indicate ascending, or desc to indicate descending. The default is ascending
        /// order. Ties will be broken by the match scores of documents. If no $orderby is
        /// specified, the default sort order is descending by document match score. There
        /// can be at most 32 $orderby clauses.
        /// </param>
        /// <param name="searchFields">
        /// The list of field names to search for the specified search text. Target fields
        /// must be included in the specified suggester.
        /// </param>
        /// <param name="select">
        /// The list of fields to retrieve. If unspecified, only the key field will be
        /// included in the results.
        /// </param>
        /// <param name="top">
        /// The number of suggestions to retrieve. The value must be a number between 1 and
        /// 100. The default is 5.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="indexName"/>, <paramref name="searchText"/> or <paramref name="suggesterName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="indexName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Documents.xml" path="doc/members/member[@name='SuggestGet(string,string,string,string,bool?,string,string,double?,IEnumerable{string},IEnumerable{string},IEnumerable{string},int?,RequestContext)']/*" />
        public virtual Response SuggestGet(string indexName, string searchText, string suggesterName, string filter, bool? useFuzzyMatching, string highlightPostTag, string highlightPreTag, double? minimumCoverage, IEnumerable<string> orderBy, IEnumerable<string> searchFields, IEnumerable<string> select, int? top, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(indexName, nameof(indexName));
            Argument.AssertNotNull(searchText, nameof(searchText));
            Argument.AssertNotNull(suggesterName, nameof(suggesterName));

            using var scope = ClientDiagnostics.CreateScope("Documents.SuggestGet");
            scope.Start();
            try
            {
                using HttpMessage message = CreateSuggestGetRequest(indexName, searchText, suggesterName, filter, useFuzzyMatching, highlightPostTag, highlightPreTag, minimumCoverage, orderBy, searchFields, select, top, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Suggests documents in the index that match the given partial query text. </summary>
        /// <param name="indexName"> The name of the index. </param>
        /// <param name="suggestOptions"> The Suggest request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="indexName"/> or <paramref name="suggestOptions"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="indexName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Documents.xml" path="doc/members/member[@name='SuggestPostAsync(string,SuggestOptions,CancellationToken)']/*" />
        public virtual async Task<Response<SuggestDocumentsResult>> SuggestPostAsync(string indexName, SuggestOptions suggestOptions, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(indexName, nameof(indexName));
            Argument.AssertNotNull(suggestOptions, nameof(suggestOptions));

            using RequestContent content = suggestOptions.ToRequestContent();
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await SuggestPostAsync(indexName, content, context).ConfigureAwait(false);
            return Response.FromValue(SuggestDocumentsResult.FromResponse(response), response);
        }

        /// <summary> Suggests documents in the index that match the given partial query text. </summary>
        /// <param name="indexName"> The name of the index. </param>
        /// <param name="suggestOptions"> The Suggest request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="indexName"/> or <paramref name="suggestOptions"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="indexName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Documents.xml" path="doc/members/member[@name='SuggestPost(string,SuggestOptions,CancellationToken)']/*" />
        public virtual Response<SuggestDocumentsResult> SuggestPost(string indexName, SuggestOptions suggestOptions, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(indexName, nameof(indexName));
            Argument.AssertNotNull(suggestOptions, nameof(suggestOptions));

            using RequestContent content = suggestOptions.ToRequestContent();
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = SuggestPost(indexName, content, context);
            return Response.FromValue(SuggestDocumentsResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Suggests documents in the index that match the given partial query text.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="SuggestPostAsync(string,SuggestOptions,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="indexName"> The name of the index. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="indexName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="indexName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Documents.xml" path="doc/members/member[@name='SuggestPostAsync(string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> SuggestPostAsync(string indexName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(indexName, nameof(indexName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Documents.SuggestPost");
            scope.Start();
            try
            {
                using HttpMessage message = CreateSuggestPostRequest(indexName, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Suggests documents in the index that match the given partial query text.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="SuggestPost(string,SuggestOptions,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="indexName"> The name of the index. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="indexName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="indexName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Documents.xml" path="doc/members/member[@name='SuggestPost(string,RequestContent,RequestContext)']/*" />
        public virtual Response SuggestPost(string indexName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(indexName, nameof(indexName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Documents.SuggestPost");
            scope.Start();
            try
            {
                using HttpMessage message = CreateSuggestPostRequest(indexName, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Sends a batch of document write actions to the index. </summary>
        /// <param name="indexName"> The name of the index. </param>
        /// <param name="batch"> The batch of index actions. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="indexName"/> or <paramref name="batch"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="indexName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Documents.xml" path="doc/members/member[@name='IndexAsync(string,IndexBatch,CancellationToken)']/*" />
        public virtual async Task<Response<IndexDocumentsResult>> IndexAsync(string indexName, IndexBatch batch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(indexName, nameof(indexName));
            Argument.AssertNotNull(batch, nameof(batch));

            using RequestContent content = batch.ToRequestContent();
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await IndexAsync(indexName, content, context).ConfigureAwait(false);
            return Response.FromValue(IndexDocumentsResult.FromResponse(response), response);
        }

        /// <summary> Sends a batch of document write actions to the index. </summary>
        /// <param name="indexName"> The name of the index. </param>
        /// <param name="batch"> The batch of index actions. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="indexName"/> or <paramref name="batch"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="indexName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Documents.xml" path="doc/members/member[@name='Index(string,IndexBatch,CancellationToken)']/*" />
        public virtual Response<IndexDocumentsResult> Index(string indexName, IndexBatch batch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(indexName, nameof(indexName));
            Argument.AssertNotNull(batch, nameof(batch));

            using RequestContent content = batch.ToRequestContent();
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = Index(indexName, content, context);
            return Response.FromValue(IndexDocumentsResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Sends a batch of document write actions to the index.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="IndexAsync(string,IndexBatch,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="indexName"> The name of the index. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="indexName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="indexName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Documents.xml" path="doc/members/member[@name='IndexAsync(string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> IndexAsync(string indexName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(indexName, nameof(indexName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Documents.Index");
            scope.Start();
            try
            {
                using HttpMessage message = CreateIndexRequest(indexName, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Sends a batch of document write actions to the index.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="Index(string,IndexBatch,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="indexName"> The name of the index. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="indexName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="indexName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Documents.xml" path="doc/members/member[@name='Index(string,RequestContent,RequestContext)']/*" />
        public virtual Response Index(string indexName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(indexName, nameof(indexName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Documents.Index");
            scope.Start();
            try
            {
                using HttpMessage message = CreateIndexRequest(indexName, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Autocompletes incomplete query terms based on input text and matching terms in
        /// the index.
        /// </summary>
        /// <param name="indexName"> The name of the index. </param>
        /// <param name="searchText"> The incomplete term which should be auto-completed. </param>
        /// <param name="suggesterName">
        /// The name of the suggester as specified in the suggesters collection that's part
        /// of the index definition.
        /// </param>
        /// <param name="autocompleteMode">
        /// Specifies the mode for Autocomplete. The default is 'oneTerm'. Use 'twoTerms'
        /// to get shingles and 'oneTermWithContext' to use the current context while
        /// producing auto-completed terms.
        /// </param>
        /// <param name="filter">
        /// An OData expression that filters the documents used to produce completed terms
        /// for the Autocomplete result.
        /// </param>
        /// <param name="useFuzzyMatching">
        /// A value indicating whether to use fuzzy matching for the autocomplete query.
        /// Default is false. When set to true, the query will find terms even if there's a
        /// substituted or missing character in the search text. While this provides a
        /// better experience in some scenarios, it comes at a performance cost as fuzzy
        /// autocomplete queries are slower and consume more resources.
        /// </param>
        /// <param name="highlightPostTag">
        /// A string tag that is appended to hit highlights. Must be set with
        /// highlightPreTag. If omitted, hit highlighting is disabled.
        /// </param>
        /// <param name="highlightPreTag">
        /// A string tag that is prepended to hit highlights. Must be set with
        /// highlightPostTag. If omitted, hit highlighting is disabled.
        /// </param>
        /// <param name="minimumCoverage">
        /// A number between 0 and 100 indicating the percentage of the index that must be
        /// covered by an autocomplete query in order for the query to be reported as a
        /// success. This parameter can be useful for ensuring search availability even for
        /// services with only one replica. The default is 80.
        /// </param>
        /// <param name="searchFields">
        /// The list of field names to consider when querying for auto-completed terms.
        /// Target fields must be included in the specified suggester.
        /// </param>
        /// <param name="top">
        /// The number of auto-completed terms to retrieve. This must be a value between 1
        /// and 100. The default is 5.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="indexName"/>, <paramref name="searchText"/> or <paramref name="suggesterName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="indexName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Documents.xml" path="doc/members/member[@name='AutocompleteGetAsync(string,string,string,AutocompleteMode?,string,bool?,string,string,double?,IEnumerable{string},int?,CancellationToken)']/*" />
        public virtual async Task<Response<AutocompleteResults>> AutocompleteGetAsync(string indexName, string searchText, string suggesterName, AutocompleteMode? autocompleteMode = null, string filter = null, bool? useFuzzyMatching = null, string highlightPostTag = null, string highlightPreTag = null, double? minimumCoverage = null, IEnumerable<string> searchFields = null, int? top = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(indexName, nameof(indexName));
            Argument.AssertNotNull(searchText, nameof(searchText));
            Argument.AssertNotNull(suggesterName, nameof(suggesterName));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await AutocompleteGetAsync(indexName, searchText, suggesterName, autocompleteMode?.ToString(), filter, useFuzzyMatching, highlightPostTag, highlightPreTag, minimumCoverage, searchFields, top, context).ConfigureAwait(false);
            return Response.FromValue(AutocompleteResults.FromResponse(response), response);
        }

        /// <summary>
        /// Autocompletes incomplete query terms based on input text and matching terms in
        /// the index.
        /// </summary>
        /// <param name="indexName"> The name of the index. </param>
        /// <param name="searchText"> The incomplete term which should be auto-completed. </param>
        /// <param name="suggesterName">
        /// The name of the suggester as specified in the suggesters collection that's part
        /// of the index definition.
        /// </param>
        /// <param name="autocompleteMode">
        /// Specifies the mode for Autocomplete. The default is 'oneTerm'. Use 'twoTerms'
        /// to get shingles and 'oneTermWithContext' to use the current context while
        /// producing auto-completed terms.
        /// </param>
        /// <param name="filter">
        /// An OData expression that filters the documents used to produce completed terms
        /// for the Autocomplete result.
        /// </param>
        /// <param name="useFuzzyMatching">
        /// A value indicating whether to use fuzzy matching for the autocomplete query.
        /// Default is false. When set to true, the query will find terms even if there's a
        /// substituted or missing character in the search text. While this provides a
        /// better experience in some scenarios, it comes at a performance cost as fuzzy
        /// autocomplete queries are slower and consume more resources.
        /// </param>
        /// <param name="highlightPostTag">
        /// A string tag that is appended to hit highlights. Must be set with
        /// highlightPreTag. If omitted, hit highlighting is disabled.
        /// </param>
        /// <param name="highlightPreTag">
        /// A string tag that is prepended to hit highlights. Must be set with
        /// highlightPostTag. If omitted, hit highlighting is disabled.
        /// </param>
        /// <param name="minimumCoverage">
        /// A number between 0 and 100 indicating the percentage of the index that must be
        /// covered by an autocomplete query in order for the query to be reported as a
        /// success. This parameter can be useful for ensuring search availability even for
        /// services with only one replica. The default is 80.
        /// </param>
        /// <param name="searchFields">
        /// The list of field names to consider when querying for auto-completed terms.
        /// Target fields must be included in the specified suggester.
        /// </param>
        /// <param name="top">
        /// The number of auto-completed terms to retrieve. This must be a value between 1
        /// and 100. The default is 5.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="indexName"/>, <paramref name="searchText"/> or <paramref name="suggesterName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="indexName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Documents.xml" path="doc/members/member[@name='AutocompleteGet(string,string,string,AutocompleteMode?,string,bool?,string,string,double?,IEnumerable{string},int?,CancellationToken)']/*" />
        public virtual Response<AutocompleteResults> AutocompleteGet(string indexName, string searchText, string suggesterName, AutocompleteMode? autocompleteMode = null, string filter = null, bool? useFuzzyMatching = null, string highlightPostTag = null, string highlightPreTag = null, double? minimumCoverage = null, IEnumerable<string> searchFields = null, int? top = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(indexName, nameof(indexName));
            Argument.AssertNotNull(searchText, nameof(searchText));
            Argument.AssertNotNull(suggesterName, nameof(suggesterName));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = AutocompleteGet(indexName, searchText, suggesterName, autocompleteMode?.ToString(), filter, useFuzzyMatching, highlightPostTag, highlightPreTag, minimumCoverage, searchFields, top, context);
            return Response.FromValue(AutocompleteResults.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Autocompletes incomplete query terms based on input text and matching terms in
        /// the index.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AutocompleteGetAsync(string,string,string,AutocompleteMode?,string,bool?,string,string,double?,IEnumerable{string},int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="indexName"> The name of the index. </param>
        /// <param name="searchText"> The incomplete term which should be auto-completed. </param>
        /// <param name="suggesterName">
        /// The name of the suggester as specified in the suggesters collection that's part
        /// of the index definition.
        /// </param>
        /// <param name="autocompleteMode">
        /// Specifies the mode for Autocomplete. The default is 'oneTerm'. Use 'twoTerms'
        /// to get shingles and 'oneTermWithContext' to use the current context while
        /// producing auto-completed terms. Allowed values: "oneTerm" | "twoTerms" | "oneTermWithContext"
        /// </param>
        /// <param name="filter">
        /// An OData expression that filters the documents used to produce completed terms
        /// for the Autocomplete result.
        /// </param>
        /// <param name="useFuzzyMatching">
        /// A value indicating whether to use fuzzy matching for the autocomplete query.
        /// Default is false. When set to true, the query will find terms even if there's a
        /// substituted or missing character in the search text. While this provides a
        /// better experience in some scenarios, it comes at a performance cost as fuzzy
        /// autocomplete queries are slower and consume more resources.
        /// </param>
        /// <param name="highlightPostTag">
        /// A string tag that is appended to hit highlights. Must be set with
        /// highlightPreTag. If omitted, hit highlighting is disabled.
        /// </param>
        /// <param name="highlightPreTag">
        /// A string tag that is prepended to hit highlights. Must be set with
        /// highlightPostTag. If omitted, hit highlighting is disabled.
        /// </param>
        /// <param name="minimumCoverage">
        /// A number between 0 and 100 indicating the percentage of the index that must be
        /// covered by an autocomplete query in order for the query to be reported as a
        /// success. This parameter can be useful for ensuring search availability even for
        /// services with only one replica. The default is 80.
        /// </param>
        /// <param name="searchFields">
        /// The list of field names to consider when querying for auto-completed terms.
        /// Target fields must be included in the specified suggester.
        /// </param>
        /// <param name="top">
        /// The number of auto-completed terms to retrieve. This must be a value between 1
        /// and 100. The default is 5.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="indexName"/>, <paramref name="searchText"/> or <paramref name="suggesterName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="indexName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Documents.xml" path="doc/members/member[@name='AutocompleteGetAsync(string,string,string,string,string,bool?,string,string,double?,IEnumerable{string},int?,RequestContext)']/*" />
        public virtual async Task<Response> AutocompleteGetAsync(string indexName, string searchText, string suggesterName, string autocompleteMode, string filter, bool? useFuzzyMatching, string highlightPostTag, string highlightPreTag, double? minimumCoverage, IEnumerable<string> searchFields, int? top, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(indexName, nameof(indexName));
            Argument.AssertNotNull(searchText, nameof(searchText));
            Argument.AssertNotNull(suggesterName, nameof(suggesterName));

            using var scope = ClientDiagnostics.CreateScope("Documents.AutocompleteGet");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAutocompleteGetRequest(indexName, searchText, suggesterName, autocompleteMode, filter, useFuzzyMatching, highlightPostTag, highlightPreTag, minimumCoverage, searchFields, top, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Autocompletes incomplete query terms based on input text and matching terms in
        /// the index.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AutocompleteGet(string,string,string,AutocompleteMode?,string,bool?,string,string,double?,IEnumerable{string},int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="indexName"> The name of the index. </param>
        /// <param name="searchText"> The incomplete term which should be auto-completed. </param>
        /// <param name="suggesterName">
        /// The name of the suggester as specified in the suggesters collection that's part
        /// of the index definition.
        /// </param>
        /// <param name="autocompleteMode">
        /// Specifies the mode for Autocomplete. The default is 'oneTerm'. Use 'twoTerms'
        /// to get shingles and 'oneTermWithContext' to use the current context while
        /// producing auto-completed terms. Allowed values: "oneTerm" | "twoTerms" | "oneTermWithContext"
        /// </param>
        /// <param name="filter">
        /// An OData expression that filters the documents used to produce completed terms
        /// for the Autocomplete result.
        /// </param>
        /// <param name="useFuzzyMatching">
        /// A value indicating whether to use fuzzy matching for the autocomplete query.
        /// Default is false. When set to true, the query will find terms even if there's a
        /// substituted or missing character in the search text. While this provides a
        /// better experience in some scenarios, it comes at a performance cost as fuzzy
        /// autocomplete queries are slower and consume more resources.
        /// </param>
        /// <param name="highlightPostTag">
        /// A string tag that is appended to hit highlights. Must be set with
        /// highlightPreTag. If omitted, hit highlighting is disabled.
        /// </param>
        /// <param name="highlightPreTag">
        /// A string tag that is prepended to hit highlights. Must be set with
        /// highlightPostTag. If omitted, hit highlighting is disabled.
        /// </param>
        /// <param name="minimumCoverage">
        /// A number between 0 and 100 indicating the percentage of the index that must be
        /// covered by an autocomplete query in order for the query to be reported as a
        /// success. This parameter can be useful for ensuring search availability even for
        /// services with only one replica. The default is 80.
        /// </param>
        /// <param name="searchFields">
        /// The list of field names to consider when querying for auto-completed terms.
        /// Target fields must be included in the specified suggester.
        /// </param>
        /// <param name="top">
        /// The number of auto-completed terms to retrieve. This must be a value between 1
        /// and 100. The default is 5.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="indexName"/>, <paramref name="searchText"/> or <paramref name="suggesterName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="indexName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Documents.xml" path="doc/members/member[@name='AutocompleteGet(string,string,string,string,string,bool?,string,string,double?,IEnumerable{string},int?,RequestContext)']/*" />
        public virtual Response AutocompleteGet(string indexName, string searchText, string suggesterName, string autocompleteMode, string filter, bool? useFuzzyMatching, string highlightPostTag, string highlightPreTag, double? minimumCoverage, IEnumerable<string> searchFields, int? top, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(indexName, nameof(indexName));
            Argument.AssertNotNull(searchText, nameof(searchText));
            Argument.AssertNotNull(suggesterName, nameof(suggesterName));

            using var scope = ClientDiagnostics.CreateScope("Documents.AutocompleteGet");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAutocompleteGetRequest(indexName, searchText, suggesterName, autocompleteMode, filter, useFuzzyMatching, highlightPostTag, highlightPreTag, minimumCoverage, searchFields, top, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Autocompletes incomplete query terms based on input text and matching terms in
        /// the index.
        /// </summary>
        /// <param name="indexName"> The name of the index. </param>
        /// <param name="autocompleteOptions"> The definition of the Autocomplete request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="indexName"/> or <paramref name="autocompleteOptions"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="indexName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Documents.xml" path="doc/members/member[@name='AutocompletePostAsync(string,AutocompleteOptions,CancellationToken)']/*" />
        public virtual async Task<Response<AutocompleteResults>> AutocompletePostAsync(string indexName, AutocompleteOptions autocompleteOptions, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(indexName, nameof(indexName));
            Argument.AssertNotNull(autocompleteOptions, nameof(autocompleteOptions));

            using RequestContent content = autocompleteOptions.ToRequestContent();
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await AutocompletePostAsync(indexName, content, context).ConfigureAwait(false);
            return Response.FromValue(AutocompleteResults.FromResponse(response), response);
        }

        /// <summary>
        /// Autocompletes incomplete query terms based on input text and matching terms in
        /// the index.
        /// </summary>
        /// <param name="indexName"> The name of the index. </param>
        /// <param name="autocompleteOptions"> The definition of the Autocomplete request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="indexName"/> or <paramref name="autocompleteOptions"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="indexName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Documents.xml" path="doc/members/member[@name='AutocompletePost(string,AutocompleteOptions,CancellationToken)']/*" />
        public virtual Response<AutocompleteResults> AutocompletePost(string indexName, AutocompleteOptions autocompleteOptions, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(indexName, nameof(indexName));
            Argument.AssertNotNull(autocompleteOptions, nameof(autocompleteOptions));

            using RequestContent content = autocompleteOptions.ToRequestContent();
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = AutocompletePost(indexName, content, context);
            return Response.FromValue(AutocompleteResults.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Autocompletes incomplete query terms based on input text and matching terms in
        /// the index.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AutocompletePostAsync(string,AutocompleteOptions,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="indexName"> The name of the index. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="indexName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="indexName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Documents.xml" path="doc/members/member[@name='AutocompletePostAsync(string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> AutocompletePostAsync(string indexName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(indexName, nameof(indexName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Documents.AutocompletePost");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAutocompletePostRequest(indexName, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Autocompletes incomplete query terms based on input text and matching terms in
        /// the index.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AutocompletePost(string,AutocompleteOptions,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="indexName"> The name of the index. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="indexName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="indexName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Documents.xml" path="doc/members/member[@name='AutocompletePost(string,RequestContent,RequestContext)']/*" />
        public virtual Response AutocompletePost(string indexName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(indexName, nameof(indexName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Documents.AutocompletePost");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAutocompletePostRequest(indexName, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateCountRequest(string indexName, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/indexes('", false);
            uri.AppendPath(indexName, true);
            uri.AppendPath("')/docs/$count", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateSearchGetRequest(string indexName, string searchText, bool? includeTotalResultCount, IEnumerable<string> facets, string filter, IEnumerable<string> highlightFields, string highlightPostTag, string highlightPreTag, double? minimumCoverage, IEnumerable<string> orderBy, string queryType, IEnumerable<string> scoringParameters, string scoringProfile, IEnumerable<string> searchFields, string searchMode, string scoringStatistics, string sessionId, IEnumerable<string> select, int? skip, int? top, string semanticConfiguration, string semanticErrorHandling, int? semanticMaxWaitInMilliseconds, string answers, string captions, string semanticQuery, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/indexes('", false);
            uri.AppendPath(indexName, true);
            uri.AppendPath("')/docs", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (searchText != null)
            {
                uri.AppendQuery("search", searchText, true);
            }
            if (includeTotalResultCount != null)
            {
                uri.AppendQuery("$count", includeTotalResultCount.Value, true);
            }
            if (facets != null && !(facets is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                foreach (var param in facets)
                {
                    uri.AppendQuery("facet", param, true);
                }
            }
            if (filter != null)
            {
                uri.AppendQuery("$filter", filter, true);
            }
            if (highlightFields != null && !(highlightFields is ChangeTrackingList<string> changeTrackingList0 && changeTrackingList0.IsUndefined))
            {
                uri.AppendQueryDelimited("highlight", highlightFields, ",", true);
            }
            if (highlightPostTag != null)
            {
                uri.AppendQuery("highlightPostTag", highlightPostTag, true);
            }
            if (highlightPreTag != null)
            {
                uri.AppendQuery("highlightPreTag", highlightPreTag, true);
            }
            if (minimumCoverage != null)
            {
                uri.AppendQuery("minimumCoverage", minimumCoverage.Value, true);
            }
            if (orderBy != null && !(orderBy is ChangeTrackingList<string> changeTrackingList1 && changeTrackingList1.IsUndefined))
            {
                uri.AppendQueryDelimited("$orderby", orderBy, ",", true);
            }
            if (queryType != null)
            {
                uri.AppendQuery("queryType", queryType, true);
            }
            if (scoringParameters != null && !(scoringParameters is ChangeTrackingList<string> changeTrackingList2 && changeTrackingList2.IsUndefined))
            {
                foreach (var param in scoringParameters)
                {
                    uri.AppendQuery("scoringParameter", param, true);
                }
            }
            if (scoringProfile != null)
            {
                uri.AppendQuery("scoringProfile", scoringProfile, true);
            }
            if (searchFields != null && !(searchFields is ChangeTrackingList<string> changeTrackingList3 && changeTrackingList3.IsUndefined))
            {
                uri.AppendQueryDelimited("searchFields", searchFields, ",", true);
            }
            if (searchMode != null)
            {
                uri.AppendQuery("searchMode", searchMode, true);
            }
            if (scoringStatistics != null)
            {
                uri.AppendQuery("scoringStatistics", scoringStatistics, true);
            }
            if (sessionId != null)
            {
                uri.AppendQuery("sessionId", sessionId, true);
            }
            if (select != null && !(select is ChangeTrackingList<string> changeTrackingList4 && changeTrackingList4.IsUndefined))
            {
                uri.AppendQueryDelimited("$select", select, ",", true);
            }
            if (skip != null)
            {
                uri.AppendQuery("$skip", skip.Value, true);
            }
            if (top != null)
            {
                uri.AppendQuery("$top", top.Value, true);
            }
            if (semanticConfiguration != null)
            {
                uri.AppendQuery("semanticConfiguration", semanticConfiguration, true);
            }
            if (semanticErrorHandling != null)
            {
                uri.AppendQuery("semanticErrorHandling", semanticErrorHandling, true);
            }
            if (semanticMaxWaitInMilliseconds != null)
            {
                uri.AppendQuery("semanticMaxWaitInMilliseconds", semanticMaxWaitInMilliseconds.Value, true);
            }
            if (answers != null)
            {
                uri.AppendQuery("answers", answers, true);
            }
            if (captions != null)
            {
                uri.AppendQuery("captions", captions, true);
            }
            if (semanticQuery != null)
            {
                uri.AppendQuery("semanticQuery", semanticQuery, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateSearchPostRequest(string indexName, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/indexes('", false);
            uri.AppendPath(indexName, true);
            uri.AppendPath("')/docs/search.post.search", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetDocumentRequest(string indexName, string key, IEnumerable<string> selectedFields, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/indexes('", false);
            uri.AppendPath(indexName, true);
            uri.AppendPath("')/docs('", false);
            uri.AppendPath(key, true);
            uri.AppendPath("')", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (selectedFields != null && !(selectedFields is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                uri.AppendQueryDelimited("$select", selectedFields, ",", true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateSuggestGetRequest(string indexName, string searchText, string suggesterName, string filter, bool? useFuzzyMatching, string highlightPostTag, string highlightPreTag, double? minimumCoverage, IEnumerable<string> orderBy, IEnumerable<string> searchFields, IEnumerable<string> select, int? top, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/indexes('", false);
            uri.AppendPath(indexName, true);
            uri.AppendPath("')/docs/search.suggest", false);
            uri.AppendQuery("search", searchText, true);
            uri.AppendQuery("suggesterName", suggesterName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (filter != null)
            {
                uri.AppendQuery("$filter", filter, true);
            }
            if (useFuzzyMatching != null)
            {
                uri.AppendQuery("fuzzy", useFuzzyMatching.Value, true);
            }
            if (highlightPostTag != null)
            {
                uri.AppendQuery("highlightPostTag", highlightPostTag, true);
            }
            if (highlightPreTag != null)
            {
                uri.AppendQuery("highlightPreTag", highlightPreTag, true);
            }
            if (minimumCoverage != null)
            {
                uri.AppendQuery("minimumCoverage", minimumCoverage.Value, true);
            }
            if (orderBy != null && !(orderBy is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                uri.AppendQueryDelimited("$orderby", orderBy, ",", true);
            }
            if (searchFields != null && !(searchFields is ChangeTrackingList<string> changeTrackingList0 && changeTrackingList0.IsUndefined))
            {
                uri.AppendQueryDelimited("searchFields", searchFields, ",", true);
            }
            if (select != null && !(select is ChangeTrackingList<string> changeTrackingList1 && changeTrackingList1.IsUndefined))
            {
                uri.AppendQueryDelimited("$select", select, ",", true);
            }
            if (top != null)
            {
                uri.AppendQuery("$top", top.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateSuggestPostRequest(string indexName, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/indexes('", false);
            uri.AppendPath(indexName, true);
            uri.AppendPath("')/docs/search.post.suggest", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateIndexRequest(string indexName, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200207);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/indexes('", false);
            uri.AppendPath(indexName, true);
            uri.AppendPath("')/docs/search.index", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateAutocompleteGetRequest(string indexName, string searchText, string suggesterName, string autocompleteMode, string filter, bool? useFuzzyMatching, string highlightPostTag, string highlightPreTag, double? minimumCoverage, IEnumerable<string> searchFields, int? top, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/indexes('", false);
            uri.AppendPath(indexName, true);
            uri.AppendPath("')/docs/search.autocomplete", false);
            uri.AppendQuery("search", searchText, true);
            uri.AppendQuery("suggesterName", suggesterName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (autocompleteMode != null)
            {
                uri.AppendQuery("autocompleteMode", autocompleteMode, true);
            }
            if (filter != null)
            {
                uri.AppendQuery("$filter", filter, true);
            }
            if (useFuzzyMatching != null)
            {
                uri.AppendQuery("fuzzy", useFuzzyMatching.Value, true);
            }
            if (highlightPostTag != null)
            {
                uri.AppendQuery("highlightPostTag", highlightPostTag, true);
            }
            if (highlightPreTag != null)
            {
                uri.AppendQuery("highlightPreTag", highlightPreTag, true);
            }
            if (minimumCoverage != null)
            {
                uri.AppendQuery("minimumCoverage", minimumCoverage.Value, true);
            }
            if (searchFields != null && !(searchFields is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                uri.AppendQueryDelimited("searchFields", searchFields, ",", true);
            }
            if (top != null)
            {
                uri.AppendQuery("$top", top.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateAutocompletePostRequest(string indexName, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/indexes('", false);
            uri.AppendPath(indexName, true);
            uri.AppendPath("')/docs/search.post.autocomplete", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        private static RequestContext DefaultRequestContext = new RequestContext();
        internal static RequestContext FromCancellationToken(CancellationToken cancellationToken = default)
        {
            if (!cancellationToken.CanBeCanceled)
            {
                return DefaultRequestContext;
            }

            return new RequestContext() { CancellationToken = cancellationToken };
        }

        private static ResponseClassifier _responseClassifier200;
        private static ResponseClassifier ResponseClassifier200 => _responseClassifier200 ??= new StatusCodeClassifier(stackalloc ushort[] { 200 });
        private static ResponseClassifier _responseClassifier200207;
        private static ResponseClassifier ResponseClassifier200207 => _responseClassifier200207 ??= new StatusCodeClassifier(stackalloc ushort[] { 200, 207 });
    }
}
