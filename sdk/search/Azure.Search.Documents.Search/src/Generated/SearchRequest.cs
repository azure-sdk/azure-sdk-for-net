// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.Search.Documents.Search
{
    /// <summary>
    /// Parameters for filtering, sorting, faceting, paging, and other search query
    /// behaviors.
    /// </summary>
    public partial class SearchRequest
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="SearchRequest"/>. </summary>
        public SearchRequest()
        {
            Facets = new ChangeTrackingList<string>();
            ScoringParameters = new ChangeTrackingList<string>();
            VectorQueries = new ChangeTrackingList<VectorQuery>();
        }

        /// <summary> Initializes a new instance of <see cref="SearchRequest"/>. </summary>
        /// <param name="count">
        /// A value that specifies whether to fetch the total count of results. Default is
        /// false. Setting this value to true may have a performance impact. Note that the
        /// count returned is an approximation.
        /// </param>
        /// <param name="facets">
        /// The list of facet expressions to apply to the search query. Each facet
        /// expression contains a field name, optionally followed by a comma-separated list
        /// of name:value pairs.
        /// </param>
        /// <param name="filter"> The OData $filter expression to apply to the search query. </param>
        /// <param name="highlight">
        /// The comma-separated list of field names to use for hit highlights. Only
        /// searchable fields can be used for hit highlighting.
        /// </param>
        /// <param name="highlightPostTag">
        /// A string tag that is appended to hit highlights. Must be set with
        /// highlightPreTag. Default is &lt;/em&gt;.
        /// </param>
        /// <param name="highlightPreTag">
        /// A string tag that is prepended to hit highlights. Must be set with
        /// highlightPostTag. Default is &lt;em&gt;.
        /// </param>
        /// <param name="minimumCoverage">
        /// A number between 0 and 100 indicating the percentage of the index that must be
        /// covered by a search query in order for the query to be reported as a success.
        /// This parameter can be useful for ensuring search availability even for services
        /// with only one replica. The default is 100.
        /// </param>
        /// <param name="orderby">
        /// The comma-separated list of OData $orderby expressions by which to sort the
        /// results. Each expression can be either a field name or a call to either the
        /// geo.distance() or the search.score() functions. Each expression can be followed
        /// by asc to indicate ascending, or desc to indicate descending. The default is
        /// ascending order. Ties will be broken by the match scores of documents. If no
        /// $orderby is specified, the default sort order is descending by document match
        /// score. There can be at most 32 $orderby clauses.
        /// </param>
        /// <param name="queryType">
        /// A value that specifies the syntax of the search query. The default is 'simple'.
        /// Use 'full' if your query uses the Lucene query syntax.
        /// </param>
        /// <param name="scoringStatistics">
        /// A value that specifies whether we want to calculate scoring statistics (such as
        /// document frequency) globally for more consistent scoring, or locally, for lower
        /// latency. The default is 'local'. Use 'global' to aggregate scoring statistics
        /// globally before scoring. Using global scoring statistics can increase latency
        /// of search queries.
        /// </param>
        /// <param name="sessionId">
        /// A value to be used to create a sticky session, which can help getting more
        /// consistent results. As long as the same sessionId is used, a best-effort
        /// attempt will be made to target the same replica set. Be wary that reusing the
        /// same sessionID values repeatedly can interfere with the load balancing of the
        /// requests across replicas and adversely affect the performance of the search
        /// service. The value used as sessionId cannot start with a '_' character.
        /// </param>
        /// <param name="scoringParameters">
        /// The list of parameter values to be used in scoring functions (for example,
        /// referencePointParameter) using the format name-values. For example, if the
        /// scoring profile defines a function with a parameter called 'mylocation' the
        /// parameter string would be "mylocation--122.2,44.8" (without the quotes).
        /// </param>
        /// <param name="scoringProfile">
        /// The name of a scoring profile to evaluate match scores for matching documents
        /// in order to sort the results.
        /// </param>
        /// <param name="search">
        /// A full-text search query expression; Use "*" or omit this parameter to match
        /// all documents.
        /// </param>
        /// <param name="searchFields">
        /// The comma-separated list of field names to which to scope the full-text search.
        /// When using fielded search (fieldName:searchExpression) in a full Lucene query,
        /// the field names of each fielded search expression take precedence over any
        /// field names listed in this parameter.
        /// </param>
        /// <param name="searchMode">
        /// A value that specifies whether any or all of the search terms must be matched
        /// in order to count the document as a match.
        /// </param>
        /// <param name="select">
        /// The comma-separated list of fields to retrieve. If unspecified, all fields
        /// marked as retrievable in the schema are included.
        /// </param>
        /// <param name="skip">
        /// The number of search results to skip. This value cannot be greater than
        /// 100,000. If you need to scan documents in sequence, but cannot use skip due to
        /// this limitation, consider using orderby on a totally-ordered key and filter
        /// with a range query instead.
        /// </param>
        /// <param name="top">
        /// The number of search results to retrieve. This can be used in conjunction with
        /// $skip to implement client-side paging of search results. If results are
        /// truncated due to server-side paging, the response will include a continuation
        /// token that can be used to issue another Search request for the next page of
        /// results.
        /// </param>
        /// <param name="semanticConfiguration">
        /// The name of a semantic configuration that will be used when processing
        /// documents for queries of type semantic.
        /// </param>
        /// <param name="semanticErrorHandling">
        /// Allows the user to choose whether a semantic call should fail completely
        /// (default / current behavior), or to return partial results.
        /// </param>
        /// <param name="semanticMaxWaitInMilliseconds">
        /// Allows the user to set an upper bound on the amount of time it takes for
        /// semantic enrichment to finish processing before the request fails.
        /// </param>
        /// <param name="semanticQuery">
        /// Allows setting a separate search query that will be solely used for semantic
        /// reranking, semantic captions and semantic answers. Is useful for scenarios
        /// where there is a need to use different queries between the base retrieval and
        /// ranking phase, and the L2 semantic phase.
        /// </param>
        /// <param name="answers">
        /// A value that specifies whether answers should be returned as part of the search
        /// response.
        /// </param>
        /// <param name="captions">
        /// A value that specifies whether captions should be returned as part of the
        /// search response.
        /// </param>
        /// <param name="vectorQueries">
        /// The query parameters for vector and hybrid search queries.
        /// Please note <see cref="VectorQuery"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="VectorizableTextQuery"/> and <see cref="VectorizedQuery"/>.
        /// </param>
        /// <param name="vectorFilterMode">
        /// Determines whether or not filters are applied before or after the vector search
        /// is performed. Default is 'preFilter' for new indexes.
        /// </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal SearchRequest(bool? count, IList<string> facets, string filter, string highlight, string highlightPostTag, string highlightPreTag, double? minimumCoverage, string orderby, QueryType? queryType, ScoringStatistics? scoringStatistics, string sessionId, IList<string> scoringParameters, string scoringProfile, string search, string searchFields, SearchMode? searchMode, string select, int? skip, int? top, string semanticConfiguration, SemanticErrorMode? semanticErrorHandling, int? semanticMaxWaitInMilliseconds, string semanticQuery, QueryAnswerType? answers, QueryCaptionType? captions, IList<VectorQuery> vectorQueries, VectorFilterMode? vectorFilterMode, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Count = count;
            Facets = facets;
            Filter = filter;
            Highlight = highlight;
            HighlightPostTag = highlightPostTag;
            HighlightPreTag = highlightPreTag;
            MinimumCoverage = minimumCoverage;
            Orderby = orderby;
            QueryType = queryType;
            ScoringStatistics = scoringStatistics;
            SessionId = sessionId;
            ScoringParameters = scoringParameters;
            ScoringProfile = scoringProfile;
            Search = search;
            SearchFields = searchFields;
            SearchMode = searchMode;
            Select = select;
            Skip = skip;
            Top = top;
            SemanticConfiguration = semanticConfiguration;
            SemanticErrorHandling = semanticErrorHandling;
            SemanticMaxWaitInMilliseconds = semanticMaxWaitInMilliseconds;
            SemanticQuery = semanticQuery;
            Answers = answers;
            Captions = captions;
            VectorQueries = vectorQueries;
            VectorFilterMode = vectorFilterMode;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary>
        /// A value that specifies whether to fetch the total count of results. Default is
        /// false. Setting this value to true may have a performance impact. Note that the
        /// count returned is an approximation.
        /// </summary>
        public bool? Count { get; set; }
        /// <summary>
        /// The list of facet expressions to apply to the search query. Each facet
        /// expression contains a field name, optionally followed by a comma-separated list
        /// of name:value pairs.
        /// </summary>
        public IList<string> Facets { get; }
        /// <summary> The OData $filter expression to apply to the search query. </summary>
        public string Filter { get; set; }
        /// <summary>
        /// The comma-separated list of field names to use for hit highlights. Only
        /// searchable fields can be used for hit highlighting.
        /// </summary>
        public string Highlight { get; set; }
        /// <summary>
        /// A string tag that is appended to hit highlights. Must be set with
        /// highlightPreTag. Default is &lt;/em&gt;.
        /// </summary>
        public string HighlightPostTag { get; set; }
        /// <summary>
        /// A string tag that is prepended to hit highlights. Must be set with
        /// highlightPostTag. Default is &lt;em&gt;.
        /// </summary>
        public string HighlightPreTag { get; set; }
        /// <summary>
        /// A number between 0 and 100 indicating the percentage of the index that must be
        /// covered by a search query in order for the query to be reported as a success.
        /// This parameter can be useful for ensuring search availability even for services
        /// with only one replica. The default is 100.
        /// </summary>
        public double? MinimumCoverage { get; set; }
        /// <summary>
        /// The comma-separated list of OData $orderby expressions by which to sort the
        /// results. Each expression can be either a field name or a call to either the
        /// geo.distance() or the search.score() functions. Each expression can be followed
        /// by asc to indicate ascending, or desc to indicate descending. The default is
        /// ascending order. Ties will be broken by the match scores of documents. If no
        /// $orderby is specified, the default sort order is descending by document match
        /// score. There can be at most 32 $orderby clauses.
        /// </summary>
        public string Orderby { get; set; }
        /// <summary>
        /// A value that specifies the syntax of the search query. The default is 'simple'.
        /// Use 'full' if your query uses the Lucene query syntax.
        /// </summary>
        public QueryType? QueryType { get; set; }
        /// <summary>
        /// A value that specifies whether we want to calculate scoring statistics (such as
        /// document frequency) globally for more consistent scoring, or locally, for lower
        /// latency. The default is 'local'. Use 'global' to aggregate scoring statistics
        /// globally before scoring. Using global scoring statistics can increase latency
        /// of search queries.
        /// </summary>
        public ScoringStatistics? ScoringStatistics { get; set; }
        /// <summary>
        /// A value to be used to create a sticky session, which can help getting more
        /// consistent results. As long as the same sessionId is used, a best-effort
        /// attempt will be made to target the same replica set. Be wary that reusing the
        /// same sessionID values repeatedly can interfere with the load balancing of the
        /// requests across replicas and adversely affect the performance of the search
        /// service. The value used as sessionId cannot start with a '_' character.
        /// </summary>
        public string SessionId { get; set; }
        /// <summary>
        /// The list of parameter values to be used in scoring functions (for example,
        /// referencePointParameter) using the format name-values. For example, if the
        /// scoring profile defines a function with a parameter called 'mylocation' the
        /// parameter string would be "mylocation--122.2,44.8" (without the quotes).
        /// </summary>
        public IList<string> ScoringParameters { get; }
        /// <summary>
        /// The name of a scoring profile to evaluate match scores for matching documents
        /// in order to sort the results.
        /// </summary>
        public string ScoringProfile { get; set; }
        /// <summary>
        /// A full-text search query expression; Use "*" or omit this parameter to match
        /// all documents.
        /// </summary>
        public string Search { get; set; }
        /// <summary>
        /// The comma-separated list of field names to which to scope the full-text search.
        /// When using fielded search (fieldName:searchExpression) in a full Lucene query,
        /// the field names of each fielded search expression take precedence over any
        /// field names listed in this parameter.
        /// </summary>
        public string SearchFields { get; set; }
        /// <summary>
        /// A value that specifies whether any or all of the search terms must be matched
        /// in order to count the document as a match.
        /// </summary>
        public SearchMode? SearchMode { get; set; }
        /// <summary>
        /// The comma-separated list of fields to retrieve. If unspecified, all fields
        /// marked as retrievable in the schema are included.
        /// </summary>
        public string Select { get; set; }
        /// <summary>
        /// The number of search results to skip. This value cannot be greater than
        /// 100,000. If you need to scan documents in sequence, but cannot use skip due to
        /// this limitation, consider using orderby on a totally-ordered key and filter
        /// with a range query instead.
        /// </summary>
        public int? Skip { get; set; }
        /// <summary>
        /// The number of search results to retrieve. This can be used in conjunction with
        /// $skip to implement client-side paging of search results. If results are
        /// truncated due to server-side paging, the response will include a continuation
        /// token that can be used to issue another Search request for the next page of
        /// results.
        /// </summary>
        public int? Top { get; set; }
        /// <summary>
        /// The name of a semantic configuration that will be used when processing
        /// documents for queries of type semantic.
        /// </summary>
        public string SemanticConfiguration { get; set; }
        /// <summary>
        /// Allows the user to choose whether a semantic call should fail completely
        /// (default / current behavior), or to return partial results.
        /// </summary>
        public SemanticErrorMode? SemanticErrorHandling { get; set; }
        /// <summary>
        /// Allows the user to set an upper bound on the amount of time it takes for
        /// semantic enrichment to finish processing before the request fails.
        /// </summary>
        public int? SemanticMaxWaitInMilliseconds { get; set; }
        /// <summary>
        /// Allows setting a separate search query that will be solely used for semantic
        /// reranking, semantic captions and semantic answers. Is useful for scenarios
        /// where there is a need to use different queries between the base retrieval and
        /// ranking phase, and the L2 semantic phase.
        /// </summary>
        public string SemanticQuery { get; set; }
        /// <summary>
        /// A value that specifies whether answers should be returned as part of the search
        /// response.
        /// </summary>
        public QueryAnswerType? Answers { get; set; }
        /// <summary>
        /// A value that specifies whether captions should be returned as part of the
        /// search response.
        /// </summary>
        public QueryCaptionType? Captions { get; set; }
        /// <summary>
        /// The query parameters for vector and hybrid search queries.
        /// Please note <see cref="VectorQuery"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="VectorizableTextQuery"/> and <see cref="VectorizedQuery"/>.
        /// </summary>
        public IList<VectorQuery> VectorQueries { get; }
        /// <summary>
        /// Determines whether or not filters are applied before or after the vector search
        /// is performed. Default is 'preFilter' for new indexes.
        /// </summary>
        public VectorFilterMode? VectorFilterMode { get; set; }
    }
}
