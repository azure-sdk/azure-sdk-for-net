// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;

namespace Azure.Search.Documents.Indexes
{
    /// <summary> Model factory for models. </summary>
    public static partial class SearchDocumentsIndexesModelFactory
    {
        /// <summary> Initializes a new instance of <see cref="Documents.Indexes.SearchServiceStatistics"/>. </summary>
        /// <param name="counters"> Service level resource counters. </param>
        /// <param name="limits"> Service level general limits. </param>
        /// <returns> A new <see cref="Documents.Indexes.SearchServiceStatistics"/> instance for mocking. </returns>
        public static SearchServiceStatistics SearchServiceStatistics(SearchServiceCounters counters = null, SearchServiceLimits limits = null)
        {
            return new SearchServiceStatistics(counters, limits, serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Documents.Indexes.SearchServiceCounters"/>. </summary>
        /// <param name="aliasesCount"> Total number of aliases. </param>
        /// <param name="documentCount"> Total number of documents across all indexes in the service. </param>
        /// <param name="indexesCount"> Total number of indexes. </param>
        /// <param name="indexersCount"> Total number of indexers. </param>
        /// <param name="dataSourcesCount"> Total number of data sources. </param>
        /// <param name="storageSize"> Total size of used storage in bytes. </param>
        /// <param name="synonymMaps"> Total number of synonym maps. </param>
        /// <param name="skillsetCount"> Total number of skillsets. </param>
        /// <param name="vectorIndexSize"> Total memory consumption of all vector indexes within the service, in bytes. </param>
        /// <returns> A new <see cref="Documents.Indexes.SearchServiceCounters"/> instance for mocking. </returns>
        public static SearchServiceCounters SearchServiceCounters(ResourceCounter aliasesCount = null, ResourceCounter documentCount = null, ResourceCounter indexesCount = null, ResourceCounter indexersCount = null, ResourceCounter dataSourcesCount = null, ResourceCounter storageSize = null, ResourceCounter synonymMaps = null, ResourceCounter skillsetCount = null, ResourceCounter vectorIndexSize = null)
        {
            return new SearchServiceCounters(
                aliasesCount,
                documentCount,
                indexesCount,
                indexersCount,
                dataSourcesCount,
                storageSize,
                synonymMaps,
                skillsetCount,
                vectorIndexSize,
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Documents.Indexes.ResourceCounter"/>. </summary>
        /// <param name="usage"> The resource usage amount. </param>
        /// <param name="quota"> The resource amount quota. </param>
        /// <returns> A new <see cref="Documents.Indexes.ResourceCounter"/> instance for mocking. </returns>
        public static ResourceCounter ResourceCounter(long usage = default, long? quota = null)
        {
            return new ResourceCounter(usage, quota, serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Documents.Indexes.SearchServiceLimits"/>. </summary>
        /// <param name="maxFieldsPerIndex"> The maximum allowed fields per index. </param>
        /// <param name="maxFieldNestingDepthPerIndex">
        /// The maximum depth which you can nest sub-fields in an index, including the
        /// top-level complex field. For example, a/b/c has a nesting depth of 3.
        /// </param>
        /// <param name="maxComplexCollectionFieldsPerIndex">
        /// The maximum number of fields of type Collection(Edm.ComplexType) allowed in an
        /// index.
        /// </param>
        /// <param name="maxComplexObjectsInCollectionsPerDocument"> The maximum number of objects in complex collections allowed per document. </param>
        /// <param name="maxStoragePerIndex"> The maximum amount of storage in bytes allowed per index. </param>
        /// <returns> A new <see cref="Documents.Indexes.SearchServiceLimits"/> instance for mocking. </returns>
        public static SearchServiceLimits SearchServiceLimits(int? maxFieldsPerIndex = null, int? maxFieldNestingDepthPerIndex = null, int? maxComplexCollectionFieldsPerIndex = null, int? maxComplexObjectsInCollectionsPerDocument = null, long? maxStoragePerIndex = null)
        {
            return new SearchServiceLimits(
                maxFieldsPerIndex,
                maxFieldNestingDepthPerIndex,
                maxComplexCollectionFieldsPerIndex,
                maxComplexObjectsInCollectionsPerDocument,
                maxStoragePerIndex,
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Documents.Indexes.IndexStatisticsSummary"/>. </summary>
        /// <param name="name"> The name of the index. </param>
        /// <param name="documentCount"> The number of documents in the index. </param>
        /// <param name="storageSize"> The amount of storage in bytes consumed by the index. </param>
        /// <param name="vectorIndexSize"> The amount of memory in bytes consumed by vectors in the index. </param>
        /// <returns> A new <see cref="Documents.Indexes.IndexStatisticsSummary"/> instance for mocking. </returns>
        public static IndexStatisticsSummary IndexStatisticsSummary(string name = null, long documentCount = default, long storageSize = default, long? vectorIndexSize = null)
        {
            return new IndexStatisticsSummary(name, documentCount, storageSize, vectorIndexSize, serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Documents.Indexes.SearchSuggester"/>. </summary>
        /// <param name="name"> The name of the suggester. </param>
        /// <param name="searchMode"> A value indicating the capabilities of the suggester. </param>
        /// <param name="sourceFields">
        /// The list of field names to which the suggester applies. Each field must be
        /// searchable.
        /// </param>
        /// <returns> A new <see cref="Documents.Indexes.SearchSuggester"/> instance for mocking. </returns>
        public static SearchSuggester SearchSuggester(string name = null, SearchSuggesterSearchMode searchMode = default, IEnumerable<string> sourceFields = null)
        {
            sourceFields ??= new List<string>();

            return new SearchSuggester(name, searchMode, sourceFields?.ToList(), serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Documents.Indexes.GetIndexStatisticsResult"/>. </summary>
        /// <param name="documentCount"> The number of documents in the index. </param>
        /// <param name="storageSize"> The amount of storage in bytes consumed by the index. </param>
        /// <param name="vectorIndexSize"> The amount of memory in bytes consumed by vectors in the index. </param>
        /// <returns> A new <see cref="Documents.Indexes.GetIndexStatisticsResult"/> instance for mocking. </returns>
        public static GetIndexStatisticsResult GetIndexStatisticsResult(long documentCount = default, long storageSize = default, long vectorIndexSize = default)
        {
            return new GetIndexStatisticsResult(documentCount, storageSize, vectorIndexSize, serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Documents.Indexes.AnalyzeRequest"/>. </summary>
        /// <param name="text"> The text to break into tokens. </param>
        /// <param name="analyzer">
        /// The name of the analyzer to use to break the given text. If this parameter is
        /// not specified, you must specify a tokenizer instead. The tokenizer and analyzer
        /// parameters are mutually exclusive.
        /// </param>
        /// <param name="tokenizer">
        /// The name of the tokenizer to use to break the given text. If this parameter is
        /// not specified, you must specify an analyzer instead. The tokenizer and analyzer
        /// parameters are mutually exclusive.
        /// </param>
        /// <param name="normalizer"> The name of the normalizer to use to normalize the given text. </param>
        /// <param name="tokenFilters">
        /// An optional list of token filters to use when breaking the given text. This
        /// parameter can only be set when using the tokenizer parameter.
        /// </param>
        /// <param name="charFilters">
        /// An optional list of character filters to use when breaking the given text. This
        /// parameter can only be set when using the tokenizer parameter.
        /// </param>
        /// <returns> A new <see cref="Documents.Indexes.AnalyzeRequest"/> instance for mocking. </returns>
        public static AnalyzeRequest AnalyzeRequest(string text = null, LexicalAnalyzerName? analyzer = null, LexicalTokenizerName? tokenizer = null, LexicalNormalizerName? normalizer = null, IEnumerable<TokenFilterName> tokenFilters = null, IEnumerable<CharFilterName> charFilters = null)
        {
            tokenFilters ??= new List<TokenFilterName>();
            charFilters ??= new List<CharFilterName>();

            return new AnalyzeRequest(
                text,
                analyzer,
                tokenizer,
                normalizer,
                tokenFilters?.ToList(),
                charFilters?.ToList(),
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Documents.Indexes.AnalyzeResult"/>. </summary>
        /// <param name="tokens"> The list of tokens returned by the analyzer specified in the request. </param>
        /// <returns> A new <see cref="Documents.Indexes.AnalyzeResult"/> instance for mocking. </returns>
        public static AnalyzeResult AnalyzeResult(IEnumerable<AnalyzedTokenInfo> tokens = null)
        {
            tokens ??= new List<AnalyzedTokenInfo>();

            return new AnalyzeResult(tokens?.ToList(), serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Documents.Indexes.AnalyzedTokenInfo"/>. </summary>
        /// <param name="token"> The token returned by the analyzer. </param>
        /// <param name="startOffset"> The index of the first character of the token in the input text. </param>
        /// <param name="endOffset"> The index of the last character of the token in the input text. </param>
        /// <param name="position">
        /// The position of the token in the input text relative to other tokens. The first
        /// token in the input text has position 0, the next has position 1, and so on.
        /// Depending on the analyzer used, some tokens might have the same position, for
        /// example if they are synonyms of each other.
        /// </param>
        /// <returns> A new <see cref="Documents.Indexes.AnalyzedTokenInfo"/> instance for mocking. </returns>
        public static AnalyzedTokenInfo AnalyzedTokenInfo(string token = null, int startOffset = default, int endOffset = default, int position = default)
        {
            return new AnalyzedTokenInfo(token, startOffset, endOffset, position, serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Documents.Indexes.SynonymMap"/>. </summary>
        /// <param name="name"> The name of the synonym map. </param>
        /// <param name="format"> The format of the synonym map. Only the 'solr' format is currently supported. </param>
        /// <param name="synonyms">
        /// A series of synonym rules in the specified synonym map format. The rules must
        /// be separated by newlines.
        /// </param>
        /// <param name="encryptionKey">
        /// A description of an encryption key that you create in Azure Key Vault. This key
        /// is used to provide an additional level of encryption-at-rest for your data when
        /// you want full assurance that no one, not even Microsoft, can decrypt your data.
        /// Once you have encrypted your data, it will always remain encrypted. The search
        /// service will ignore attempts to set this property to null. You can change this
        /// property as needed if you want to rotate your encryption key; Your data will be
        /// unaffected. Encryption with customer-managed keys is not available for free
        /// search services, and is only available for paid services created on or after
        /// January 1, 2019.
        /// </param>
        /// <param name="eTag"> The ETag of the synonym map. </param>
        /// <returns> A new <see cref="Documents.Indexes.SynonymMap"/> instance for mocking. </returns>
        public static SynonymMap SynonymMap(string name = null, SynonymMapFormat format = default, string synonyms = null, SearchResourceEncryptionKey encryptionKey = null, string eTag = null)
        {
            return new SynonymMap(
                name,
                format,
                synonyms,
                encryptionKey,
                eTag,
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Documents.Indexes.ListSynonymMapsResult"/>. </summary>
        /// <param name="value"> The synonym maps in the Search service. </param>
        /// <returns> A new <see cref="Documents.Indexes.ListSynonymMapsResult"/> instance for mocking. </returns>
        public static ListSynonymMapsResult ListSynonymMapsResult(IEnumerable<SynonymMap> value = null)
        {
            value ??= new List<SynonymMap>();

            return new ListSynonymMapsResult(value?.ToList(), serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Documents.Indexes.ListSkillsetsResult"/>. </summary>
        /// <param name="value"> The skillsets defined in the Search service. </param>
        /// <returns> A new <see cref="Documents.Indexes.ListSkillsetsResult"/> instance for mocking. </returns>
        public static ListSkillsetsResult ListSkillsetsResult(IEnumerable<SearchIndexerSkillset> value = null)
        {
            value ??= new List<SearchIndexerSkillset>();

            return new ListSkillsetsResult(value?.ToList(), serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Documents.Indexes.ListIndexersResult"/>. </summary>
        /// <param name="value"> The indexers in the Search service. </param>
        /// <returns> A new <see cref="Documents.Indexes.ListIndexersResult"/> instance for mocking. </returns>
        public static ListIndexersResult ListIndexersResult(IEnumerable<SearchIndexer> value = null)
        {
            value ??= new List<SearchIndexer>();

            return new ListIndexersResult(value?.ToList(), serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Documents.Indexes.SearchIndexerStatus"/>. </summary>
        /// <param name="status"> Overall indexer status. </param>
        /// <param name="lastResult"> The result of the most recent or an in-progress indexer execution. </param>
        /// <param name="executionHistory"> History of the recent indexer executions, sorted in reverse chronological order. </param>
        /// <param name="limits"> The execution limits for the indexer. </param>
        /// <returns> A new <see cref="Documents.Indexes.SearchIndexerStatus"/> instance for mocking. </returns>
        public static SearchIndexerStatus SearchIndexerStatus(IndexerStatus status = default, IndexerExecutionResult lastResult = null, IEnumerable<IndexerExecutionResult> executionHistory = null, SearchIndexerLimits limits = null)
        {
            executionHistory ??= new List<IndexerExecutionResult>();

            return new SearchIndexerStatus(status, lastResult, executionHistory?.ToList(), limits, serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Documents.Indexes.IndexerExecutionResult"/>. </summary>
        /// <param name="status"> The outcome of this indexer execution. </param>
        /// <param name="statusDetail"> The outcome of this indexer execution. </param>
        /// <param name="currentState"> All of the state that defines and dictates the indexer's current execution. </param>
        /// <param name="errorMessage"> The error message indicating the top-level error, if any. </param>
        /// <param name="startTime"> The start time of this indexer execution. </param>
        /// <param name="endTime"> The end time of this indexer execution, if the execution has already completed. </param>
        /// <param name="errors"> The item-level indexing errors. </param>
        /// <param name="warnings"> The item-level indexing warnings. </param>
        /// <param name="itemsProcessed">
        /// The number of items that were processed during this indexer execution. This
        /// includes both successfully processed items and items where indexing was
        /// attempted but failed.
        /// </param>
        /// <param name="itemsFailed"> The number of items that failed to be indexed during this indexer execution. </param>
        /// <param name="initialTrackingState"> Change tracking state with which an indexer execution started. </param>
        /// <param name="finalTrackingState"> Change tracking state with which an indexer execution finished. </param>
        /// <returns> A new <see cref="Documents.Indexes.IndexerExecutionResult"/> instance for mocking. </returns>
        public static IndexerExecutionResult IndexerExecutionResult(IndexerExecutionStatus status = default, IndexerExecutionStatusDetail? statusDetail = null, IndexerCurrentState currentState = null, string errorMessage = null, DateTimeOffset? startTime = null, DateTimeOffset? endTime = null, IEnumerable<SearchIndexerError> errors = null, IEnumerable<SearchIndexerWarning> warnings = null, int itemsProcessed = default, int itemsFailed = default, string initialTrackingState = null, string finalTrackingState = null)
        {
            errors ??= new List<SearchIndexerError>();
            warnings ??= new List<SearchIndexerWarning>();

            return new IndexerExecutionResult(
                status,
                statusDetail,
                currentState,
                errorMessage,
                startTime,
                endTime,
                errors?.ToList(),
                warnings?.ToList(),
                itemsProcessed,
                itemsFailed,
                initialTrackingState,
                finalTrackingState,
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Documents.Indexes.IndexerCurrentState"/>. </summary>
        /// <param name="mode"> The mode the indexer is running in. </param>
        /// <param name="allDocsInitialChangeTrackingState">
        /// Change tracking state used when indexing starts on all documents in the
        /// datasource.
        /// </param>
        /// <param name="allDocsFinalChangeTrackingState">
        /// Change tracking state value when indexing finishes on all documents in the
        /// datasource.
        /// </param>
        /// <param name="resetDocsInitialChangeTrackingState">
        /// Change tracking state used when indexing starts on select, reset documents in
        /// the datasource.
        /// </param>
        /// <param name="resetDocsFinalChangeTrackingState">
        /// Change tracking state value when indexing finishes on select, reset documents
        /// in the datasource.
        /// </param>
        /// <param name="resetDocumentKeys">
        /// The list of document keys that have been reset. The document key is the
        /// document's unique identifier for the data in the search index. The indexer will
        /// prioritize selectively re-ingesting these keys.
        /// </param>
        /// <param name="resetDatasourceDocumentIds">
        /// The list of datasource document ids that have been reset. The datasource
        /// document id is the unique identifier for the data in the datasource. The
        /// indexer will prioritize selectively re-ingesting these ids.
        /// </param>
        /// <returns> A new <see cref="Documents.Indexes.IndexerCurrentState"/> instance for mocking. </returns>
        public static IndexerCurrentState IndexerCurrentState(IndexingMode? mode = null, string allDocsInitialChangeTrackingState = null, string allDocsFinalChangeTrackingState = null, string resetDocsInitialChangeTrackingState = null, string resetDocsFinalChangeTrackingState = null, IEnumerable<string> resetDocumentKeys = null, IEnumerable<string> resetDatasourceDocumentIds = null)
        {
            resetDocumentKeys ??= new List<string>();
            resetDatasourceDocumentIds ??= new List<string>();

            return new IndexerCurrentState(
                mode,
                allDocsInitialChangeTrackingState,
                allDocsFinalChangeTrackingState,
                resetDocsInitialChangeTrackingState,
                resetDocsFinalChangeTrackingState,
                resetDocumentKeys?.ToList(),
                resetDatasourceDocumentIds?.ToList(),
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Documents.Indexes.SearchIndexerError"/>. </summary>
        /// <param name="key"> The key of the item for which indexing failed. </param>
        /// <param name="errorMessage"> The message describing the error that occurred while processing the item. </param>
        /// <param name="statusCode">
        /// The status code indicating why the indexing operation failed. Possible values
        /// include: 400 for a malformed input document, 404 for document not found, 409
        /// for a version conflict, 422 when the index is temporarily unavailable, or 503
        /// for when the service is too busy.
        /// </param>
        /// <param name="name">
        /// The name of the source at which the error originated. For example, this could
        /// refer to a particular skill in the attached skillset. This may not be always
        /// available.
        /// </param>
        /// <param name="details">
        /// Additional, verbose details about the error to assist in debugging the indexer.
        /// This may not be always available.
        /// </param>
        /// <param name="documentationLink">
        /// A link to a troubleshooting guide for these classes of errors. This may not be
        /// always available.
        /// </param>
        /// <returns> A new <see cref="Documents.Indexes.SearchIndexerError"/> instance for mocking. </returns>
        public static SearchIndexerError SearchIndexerError(string key = null, string errorMessage = null, int statusCode = default, string name = null, string details = null, string documentationLink = null)
        {
            return new SearchIndexerError(
                key,
                errorMessage,
                statusCode,
                name,
                details,
                documentationLink,
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Documents.Indexes.SearchIndexerWarning"/>. </summary>
        /// <param name="key"> The key of the item which generated a warning. </param>
        /// <param name="message"> The message describing the warning that occurred while processing the item. </param>
        /// <param name="name">
        /// The name of the source at which the warning originated. For example, this could
        /// refer to a particular skill in the attached skillset. This may not be always
        /// available.
        /// </param>
        /// <param name="details">
        /// Additional, verbose details about the warning to assist in debugging the
        /// indexer. This may not be always available.
        /// </param>
        /// <param name="documentationLink">
        /// A link to a troubleshooting guide for these classes of warnings. This may not
        /// be always available.
        /// </param>
        /// <returns> A new <see cref="Documents.Indexes.SearchIndexerWarning"/> instance for mocking. </returns>
        public static SearchIndexerWarning SearchIndexerWarning(string key = null, string message = null, string name = null, string details = null, string documentationLink = null)
        {
            return new SearchIndexerWarning(
                key,
                message,
                name,
                details,
                documentationLink,
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Documents.Indexes.SearchIndexerLimits"/>. </summary>
        /// <param name="maxRunTime"> The maximum duration that the indexer is permitted to run for one execution. </param>
        /// <param name="maxDocumentExtractionSize">
        /// The maximum size of a document, in bytes, which will be considered valid for
        /// indexing.
        /// </param>
        /// <param name="maxDocumentContentCharactersToExtract">
        /// The maximum number of characters that will be extracted from a document picked
        /// up for indexing.
        /// </param>
        /// <returns> A new <see cref="Documents.Indexes.SearchIndexerLimits"/> instance for mocking. </returns>
        public static SearchIndexerLimits SearchIndexerLimits(TimeSpan? maxRunTime = null, long? maxDocumentExtractionSize = null, long? maxDocumentContentCharactersToExtract = null)
        {
            return new SearchIndexerLimits(maxRunTime, maxDocumentExtractionSize, maxDocumentContentCharactersToExtract, serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Documents.Indexes.ListDataSourcesResult"/>. </summary>
        /// <param name="value"> The datasources in the Search service. </param>
        /// <returns> A new <see cref="Documents.Indexes.ListDataSourcesResult"/> instance for mocking. </returns>
        public static ListDataSourcesResult ListDataSourcesResult(IEnumerable<SearchIndexerDataSource> value = null)
        {
            value ??= new List<SearchIndexerDataSource>();

            return new ListDataSourcesResult(value?.ToList(), serializedAdditionalRawData: null);
        }
    }
}
