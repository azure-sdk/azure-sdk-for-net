// <auto-generated>
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for
// license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>

namespace Microsoft.Azure.Management.DataCollaboration.Models
{
    using Microsoft.Rest;
    using Microsoft.Rest.Serialization;
    using Newtonsoft.Json;
    using System.Collections;
    using System.Collections.Generic;
    using System.Linq;

    /// <summary>
    /// A Synapse Spark based pipeline step.
    /// </summary>
    [Newtonsoft.Json.JsonObject("SynapseSpark")]
    [Rest.Serialization.JsonTransformation]
    public partial class SynapseSparkPipelineStep : PipelineStep
    {
        /// <summary>
        /// Initializes a new instance of the SynapseSparkPipelineStep class.
        /// </summary>
        public SynapseSparkPipelineStep()
        {
            CustomInit();
        }

        /// <summary>
        /// Initializes a new instance of the SynapseSparkPipelineStep class.
        /// </summary>
        /// <param name="computationId">The computation Id that the pipeline
        /// step should execute</param>
        /// <param name="computationRevision">The computation's revision that
        /// the pipeline step should execute</param>
        /// <param name="computationSinkBindings">Bindings between the
        /// computation's sink keys and data assets</param>
        /// <param name="computationSourceBindings">Bindings between the
        /// computation's source keys and data assets</param>
        /// <param name="executorNodeSize">The node size to use per executor.
        /// Possible values include: 'None', 'Small', 'Medium', 'Large',
        /// 'XLarge', 'XXLarge', 'XXXLarge'</param>
        /// <param name="executorsCount">Number of executors to execute this
        /// step.</param>
        /// <param name="synapseSparkPoolId">The Synapse Spark pool that will
        /// execute this step</param>
        /// <param name="id">The resource id of the azure resource</param>
        /// <param name="name">Name of the azure resource</param>
        /// <param name="systemData">System Data of the Azure resource.</param>
        /// <param name="type">Type of the azure resource</param>
        /// <param name="computationExecutionTimeout">The upper boundary of
        /// computation execution time. Pattern:
        /// ((\\d+)\\.)?(\\d\\d):(60|([0-5][0-9])):(60|([0-5][0-9])).</param>
        /// <param name="computationParameterBindings">Binding between the
        /// computation parameter and pipeline parameters</param>
        /// <param name="computationParameters">List of pipeline step level
        /// computation parameters</param>
        /// <param name="dependencies">List of other steps names, in the same
        /// pipeline, which this step is depended on
        /// and should run only when they finish.</param>
        /// <param name="diagnosticsLogBindings">Bindings between the
        /// diagnostics logs and data assets</param>
        /// <param name="parameters">The list of overridable pipeline step
        /// parameters</param>
        public SynapseSparkPipelineStep(string computationId, int computationRevision, IList<ComputationAdaptedDataAssetBinding> computationSinkBindings, IList<ComputationAdaptedDataAssetBinding> computationSourceBindings, string executorNodeSize, int executorsCount, string synapseSparkPoolId, string id = default(string), string name = default(string), SystemData systemData = default(SystemData), string type = default(string), string computationExecutionTimeout = default(string), IList<ComputationParameterBinding> computationParameterBindings = default(IList<ComputationParameterBinding>), IList<ComputationParameter> computationParameters = default(IList<ComputationParameter>), IList<string> dependencies = default(IList<string>), IList<DiagnosticsLog> diagnosticsLogBindings = default(IList<DiagnosticsLog>), IList<PipelineStepParameter> parameters = default(IList<PipelineStepParameter>))
            : base(id, name, systemData, type)
        {
            ComputationExecutionTimeout = computationExecutionTimeout;
            ComputationId = computationId;
            ComputationParameterBindings = computationParameterBindings;
            ComputationParameters = computationParameters;
            ComputationRevision = computationRevision;
            ComputationSinkBindings = computationSinkBindings;
            ComputationSourceBindings = computationSourceBindings;
            Dependencies = dependencies;
            DiagnosticsLogBindings = diagnosticsLogBindings;
            ExecutorNodeSize = executorNodeSize;
            ExecutorsCount = executorsCount;
            Parameters = parameters;
            SynapseSparkPoolId = synapseSparkPoolId;
            CustomInit();
        }

        /// <summary>
        /// An initialization method that performs custom operations like setting defaults
        /// </summary>
        partial void CustomInit();

        /// <summary>
        /// Gets or sets the upper boundary of computation execution time.
        /// Pattern: ((\\d+)\\.)?(\\d\\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        /// </summary>
        [JsonProperty(PropertyName = "properties.computationExecutionTimeout")]
        public string ComputationExecutionTimeout { get; set; }

        /// <summary>
        /// Gets or sets the computation Id that the pipeline step should
        /// execute
        /// </summary>
        [JsonProperty(PropertyName = "properties.computationId")]
        public string ComputationId { get; set; }

        /// <summary>
        /// Gets or sets binding between the computation parameter and pipeline
        /// parameters
        /// </summary>
        [JsonProperty(PropertyName = "properties.computationParameterBindings")]
        public IList<ComputationParameterBinding> ComputationParameterBindings { get; set; }

        /// <summary>
        /// Gets or sets list of pipeline step level computation parameters
        /// </summary>
        [JsonProperty(PropertyName = "properties.computationParameters")]
        public IList<ComputationParameter> ComputationParameters { get; set; }

        /// <summary>
        /// Gets or sets the computation's revision that the pipeline step
        /// should execute
        /// </summary>
        [JsonProperty(PropertyName = "properties.computationRevision")]
        public int ComputationRevision { get; set; }

        /// <summary>
        /// Gets or sets bindings between the computation's sink keys and data
        /// assets
        /// </summary>
        [JsonProperty(PropertyName = "properties.computationSinkBindings")]
        public IList<ComputationAdaptedDataAssetBinding> ComputationSinkBindings { get; set; }

        /// <summary>
        /// Gets or sets bindings between the computation's source keys and
        /// data assets
        /// </summary>
        [JsonProperty(PropertyName = "properties.computationSourceBindings")]
        public IList<ComputationAdaptedDataAssetBinding> ComputationSourceBindings { get; set; }

        /// <summary>
        /// Gets or sets list of other steps names, in the same pipeline, which
        /// this step is depended on
        /// and should run only when they finish.
        /// </summary>
        [JsonProperty(PropertyName = "properties.dependencies")]
        public IList<string> Dependencies { get; set; }

        /// <summary>
        /// Gets or sets bindings between the diagnostics logs and data assets
        /// </summary>
        [JsonProperty(PropertyName = "properties.diagnosticsLogBindings")]
        public IList<DiagnosticsLog> DiagnosticsLogBindings { get; set; }

        /// <summary>
        /// Gets or sets the node size to use per executor. Possible values
        /// include: 'None', 'Small', 'Medium', 'Large', 'XLarge', 'XXLarge',
        /// 'XXXLarge'
        /// </summary>
        [JsonProperty(PropertyName = "properties.executorNodeSize")]
        public string ExecutorNodeSize { get; set; }

        /// <summary>
        /// Gets or sets number of executors to execute this step.
        /// </summary>
        [JsonProperty(PropertyName = "properties.executorsCount")]
        public int ExecutorsCount { get; set; }

        /// <summary>
        /// Gets or sets the list of overridable pipeline step parameters
        /// </summary>
        [JsonProperty(PropertyName = "properties.parameters")]
        public IList<PipelineStepParameter> Parameters { get; set; }

        /// <summary>
        /// Gets or sets the Synapse Spark pool that will execute this step
        /// </summary>
        [JsonProperty(PropertyName = "properties.synapseSparkPoolId")]
        public string SynapseSparkPoolId { get; set; }

        /// <summary>
        /// Validate the object.
        /// </summary>
        /// <exception cref="ValidationException">
        /// Thrown if validation fails
        /// </exception>
        public virtual void Validate()
        {
            if (ComputationId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "ComputationId");
            }
            if (ComputationSinkBindings == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "ComputationSinkBindings");
            }
            if (ComputationSourceBindings == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "ComputationSourceBindings");
            }
            if (ExecutorNodeSize == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "ExecutorNodeSize");
            }
            if (SynapseSparkPoolId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "SynapseSparkPoolId");
            }
            if (ComputationParameterBindings != null)
            {
                foreach (var element in ComputationParameterBindings)
                {
                    if (element != null)
                    {
                        element.Validate();
                    }
                }
            }
            if (ComputationParameters != null)
            {
                foreach (var element1 in ComputationParameters)
                {
                    if (element1 != null)
                    {
                        element1.Validate();
                    }
                }
            }
            if (ComputationSinkBindings != null)
            {
                foreach (var element2 in ComputationSinkBindings)
                {
                    if (element2 != null)
                    {
                        element2.Validate();
                    }
                }
            }
            if (ComputationSourceBindings != null)
            {
                foreach (var element3 in ComputationSourceBindings)
                {
                    if (element3 != null)
                    {
                        element3.Validate();
                    }
                }
            }
            if (DiagnosticsLogBindings != null)
            {
                foreach (var element4 in DiagnosticsLogBindings)
                {
                    if (element4 != null)
                    {
                        element4.Validate();
                    }
                }
            }
            if (Parameters != null)
            {
                foreach (var element5 in Parameters)
                {
                    if (element5 != null)
                    {
                        element5.Validate();
                    }
                }
            }
        }
    }
}
